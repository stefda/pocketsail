(
        function e(t, n, r) {

        function s(o, u) {
        if (!n[o]) {
        if (!t[o]) {
        var a = typeof require == "function" && require;
                if (!u && a)
                return a(o, !0);
                if (i)
                return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
        }
        var l = n[o] = {
        exports:{}
        };
                t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
                return s(n?n:e)
        }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
        }
        var i = typeof require == "function" && require;
                for (var o = 0; o < r.length; o++)
                s(r[o]);
                return s
        }
)({1:[

        function(require, module, exports) {

        'use strict';
// a simple wrapper around a single arraybuffer

                module.exports = Buffer;
                function Buffer(buffer) {
                if (!buffer) {
                this.array = new ArrayBuffer(this.defaultLength);
                        this.length = this.defaultLength;
                        this.setupViews();
                } else {
                // we only recreate buffers after receiving them from workers for binding to gl,
                // so we only need these 2 properties
                this.array = buffer.array;
                        this.pos = buffer.pos;
                }
                }

        Buffer.prototype = {
        pos: 0,
                itemSize: 4, // bytes in one item
                defaultLength: 8192, // initial buffer size
                arrayType: 'ARRAY_BUFFER', // gl buffer type

                get index() {
        return this.pos / this.itemSize;
        },
                setupViews: function() {
                // set up views for each type to add data of different types to the same buffer
                this.ubytes = new Uint8Array(this.array);
                        this.bytes = new Int8Array(this.array);
                        this.ushorts = new Uint16Array(this.array);
                        this.shorts = new Int16Array(this.array);
                },
                // binds the buffer to a webgl context
                bind: function(gl) {
                var type = gl[this.arrayType];
                        if (!this.buffer) {
                this.buffer = gl.createBuffer();
                        gl.bindBuffer(type, this.buffer);
                        gl.bufferData(type, new DataView(this.array, 0, this.pos), gl.STATIC_DRAW);
                        // dump array buffer once it's bound to gl
                        this.array = null;
                } else {
                gl.bindBuffer(type, this.buffer);
                }
                },
                destroy: function(gl) {
                if (this.buffer) {
                gl.deleteBuffer(this.buffer);
                }
                },
                // increase the buffer size by 50% if a new item doesn't fit
                resize: function() {
                if (this.length < this.pos + this.itemSize) {

                while (this.length < this.pos + this.itemSize) {
                // increase the length by 50% but keep it even
                this.length = Math.round(this.length * 1.5 / 2) * 2;
                }

                // array buffers can't be resized, so we create a new one and reset all bytes there
                this.array = new ArrayBuffer(this.length);
                        var ubytes = new Uint8Array(this.array);
                        ubytes.set(this.ubytes);
                        this.setupViews();
                }
                }
        };
                }, {}], 2:[function(require, module, exports){
'use strict';
        var LineVertexBuffer = require('./linevertexbuffer.js');
        var LineElementBuffer = require('./lineelementbuffer.js');
        var FillVertexBuffer = require('./fillvertexbuffer.js');
        var FillElementBuffer = require('./fillelementsbuffer.js');
        var OutlineElementBuffer = require('./outlineelementsbuffer.js');
        var GlyphVertexBuffer = require('./glyphvertexbuffer.js');
        var IconVertexBuffer = require('./iconvertexbuffer.js');
        module.exports = function(bufferset) {
        bufferset = bufferset || {};
                return {
                glyphVertex: new GlyphVertexBuffer(bufferset.glyphVertex),
                        iconVertex: new IconVertexBuffer(bufferset.iconVertex),
                        fillVertex: new FillVertexBuffer(bufferset.fillVertex),
                        fillElement: new FillElementBuffer(bufferset.fillElement),
                        outlineElement: new OutlineElementBuffer(bufferset.outlineElement),
                        lineVertex: new LineVertexBuffer(bufferset.lineVertex),
                        lineElement: new LineElementBuffer(bufferset.lineElement)
                };
        };
        }, {"./fillelementsbuffer.js":3, "./fillvertexbuffer.js":4, "./glyphvertexbuffer.js":5, "./iconvertexbuffer.js":6, "./lineelementbuffer.js":7, "./linevertexbuffer.js":8, "./outlineelementsbuffer.js":9}], 3:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = FillElementsBuffer;
        function FillElementsBuffer(buffer) {
        Buffer.call(this, buffer);
        }

FillElementsBuffer.prototype = Object.create(Buffer.prototype);
        FillElementsBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
        FillElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';
        FillElementsBuffer.prototype.add = function(a, b, c) {
        var pos2 = this.pos / 2;
                this.resize();
                this.ushorts[pos2 + 0] = a;
                this.ushorts[pos2 + 1] = b;
                this.ushorts[pos2 + 2] = c;
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 4:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = FillVertexBuffer;
        function FillVertexBuffer(buffer) {
        Buffer.call(this, buffer);
        }

FillVertexBuffer.prototype = Object.create(Buffer.prototype);
        FillVertexBuffer.prototype.itemSize = 4; // bytes per vertex (2 * short == 4 bytes)

        FillVertexBuffer.prototype.add = function(x, y) {
        var pos2 = this.pos / 2;
                this.resize();
                this.shorts[pos2 + 0] = x;
                this.shorts[pos2 + 1] = y;
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 5:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = GlyphVertexBuffer;
        function GlyphVertexBuffer(buffer) {
        Buffer.call(this, buffer);
        }

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);
        GlyphVertexBuffer.prototype.defaultLength = 2048 * 16;
        GlyphVertexBuffer.prototype.itemSize = 16;
// Converts the 0..2pi to an int16 range
        GlyphVertexBuffer.angleFactor = 128 / Math.PI;
        GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
        var pos = this.pos,
                pos2 = pos / 2,
                angleFactor = GlyphVertexBuffer.angleFactor;
                this.resize();
                this.shorts[pos2 + 0] = x;
                this.shorts[pos2 + 1] = y;
                this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
                this.shorts[pos2 + 3] = Math.round(oy * 64);
                this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
                this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
                this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
                this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
                this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
                this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;
                this.ubytes[pos + 14] = Math.floor(tx / 4);
                this.ubytes[pos + 15] = Math.floor(ty / 4);
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 6:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = GlyphVertexBuffer;
        function GlyphVertexBuffer(buffer) {
        Buffer.call(this, buffer);
        }

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);
        GlyphVertexBuffer.prototype.defaultLength = 2048 * 20;
        GlyphVertexBuffer.prototype.itemSize = 20;
// Converts the 0..2pi to an int16 range
        GlyphVertexBuffer.angleFactor = 128 / Math.PI;
        GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
        var pos = this.pos,
                pos2 = pos / 2,
                angleFactor = GlyphVertexBuffer.angleFactor;
                this.resize();
                this.shorts[pos2 + 0] = x;
                this.shorts[pos2 + 1] = y;
                this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
                this.shorts[pos2 + 3] = Math.round(oy * 64);
                this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
                this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
                this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
                this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
                this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
                this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;
                this.shorts[pos2 + 8] = tx;
                this.shorts[pos2 + 9] = ty;
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 7:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = LineElementBuffer;
        function LineElementBuffer(buffer) {
        Buffer.call(this, buffer);
        }

LineElementBuffer.prototype = Object.create(Buffer.prototype);
        LineElementBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
        LineElementBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';
        LineElementBuffer.prototype.add = function(a, b, c) {
        var pos2 = this.pos / 2;
                this.resize();
                this.ushorts[pos2 + 0] = a;
                this.ushorts[pos2 + 1] = b;
                this.ushorts[pos2 + 2] = c;
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 8:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = LineVertexBuffer;
        function LineVertexBuffer(buffer) {
        Buffer.call(this, buffer);
        }

// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
LineVertexBuffer.extrudeScale = 63;
        LineVertexBuffer.prototype = Object.create(Buffer.prototype);
        LineVertexBuffer.prototype.itemSize = 8; // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
        LineVertexBuffer.prototype.defaultLength = 32768;
// add a vertex to this buffer;
// x, y - vertex position
// ex, ey - extrude normal
// tx, ty - texture normal

        LineVertexBuffer.prototype.add = function(point, extrude, tx, ty, linesofar) {
        var pos = this.pos,
                pos2 = pos / 2,
                index = this.index,
                extrudeScale = LineVertexBuffer.extrudeScale;
                this.resize();
                this.shorts[pos2 + 0] = (Math.floor(point.x) * 2) | tx;
                this.shorts[pos2 + 1] = (Math.floor(point.y) * 2) | ty;
                this.shorts[pos2 + 2] = Math.round(linesofar || 0);
                this.bytes[pos + 6] = Math.round(extrudeScale * extrude.x);
                this.bytes[pos + 7] = Math.round(extrudeScale * extrude.y);
                this.pos += this.itemSize;
                return index;
        };
        }, {"./buffer.js":1}], 9:[function(require, module, exports){
'use strict';
        var Buffer = require('./buffer.js');
        module.exports = OutlineElementsBuffer;
        function OutlineElementsBuffer(buffer) {
        Buffer.call(this, buffer);
        }

OutlineElementsBuffer.prototype = Object.create(Buffer.prototype);
        OutlineElementsBuffer.prototype.itemSize = 4; // bytes per line (2 * unsigned short == 4 bytes)
        OutlineElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';
        OutlineElementsBuffer.prototype.add = function(a, b) {
        var pos2 = this.pos / 2;
                this.resize();
                this.ushorts[pos2 + 0] = a;
                this.ushorts[pos2 + 1] = b;
                this.pos += this.itemSize;
        };
        }, {"./buffer.js":1}], 10:[function(require, module, exports){
'use strict';
        module.exports = createBucket;
        var LineBucket = require('./linebucket.js');
        var FillBucket = require('./fillbucket.js');
        var SymbolBucket = require('./symbolbucket.js');
        var RasterBucket = require('./rasterbucket.js');
        var RenderProperties = require('../style/renderproperties.js');
        function createBucket(layer, buffers, collision, indices) {

        if (!RenderProperties[layer.type]) {
        //console.warn('unknown bucket type');
        return;
        }

        var info = new RenderProperties[layer.type](layer.render);
                var BucketClass =
                layer.type === 'line' ? LineBucket :
                layer.type === 'fill' ? FillBucket :
                layer.type === 'symbol' ? SymbolBucket :
                layer.type === 'raster' ? RasterBucket : null;
                var bucket = new BucketClass(info, buffers, collision, indices);
                bucket.type = layer.type;
                bucket.interactive = layer.interactive;
                bucket.minZoom = layer['min-zoom'];
                bucket.maxZoom = layer['max-zoom'];
                return bucket;
        }

}, {"../style/renderproperties.js":52, "./fillbucket.js":13, "./linebucket.js":14, "./rasterbucket.js":15, "./symbolbucket.js":16}], 11:[function(require, module, exports){
'use strict';
        module.exports = ElementGroups;
        function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

        this.vertexBuffer = vertexBuffer;
                this.elementBuffer = elementBuffer;
                this.secondElementBuffer = secondElementBuffer;
                this.groups = [];
        }

ElementGroups.prototype.makeRoomFor = function(numVertices) {
if (!this.current || this.current.vertexLength + numVertices > 65535) {
this.current = new ElementGroup(this.vertexBuffer.index,
        this.elementBuffer && this.elementBuffer.index,
        this.secondElementBuffer && this.secondElementBuffer.index);
        this.groups.push(this.current);
}
};
        function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex)  {
        // the offset into the vertex buffer of the first vertex in this group
        this.vertexStartIndex = vertexStartIndex;
                this.elementStartIndex = elementStartIndex;
                this.secondElementStartIndex = secondElementStartIndex;
                this.elementLength = 0;
                this.vertexLength = 0;
                this.secondElementLength = 0;
        }

}, {}], 12:[function(require, module, exports){
'use strict';
        var rbush = require('rbush'),
        Point = require('point-geometry');
        module.exports = FeatureTree;
        function FeatureTree(getGeometry, getType) {

        this.getGeometry = getGeometry;
                this.getType = getType;
                this.rtree = rbush(9);
                this.toBeInserted = [];
        }

FeatureTree.prototype.insert = function(bbox, bucket_name, feature) {
bbox.bucket = bucket_name;
        bbox.feature = feature;
        this.toBeInserted.push(bbox);
        };
// bulk insert into tree
        FeatureTree.prototype._load = function() {
        this.rtree.load(this.toBeInserted);
                this.toBeInserted = [];
        };
// Finds features in this tile at a particular position.
        FeatureTree.prototype.query = function(args, callback) {

        if (this.toBeInserted.length) this._load();
                var radius = args.params && args.params.radius || 0;
                radius *= 4096 / args.scale;
                var x = args.x,
                y = args.y;
                var matching = this.rtree.search([ x - radius, y - radius, x + radius, y + radius ]);
                if (args.params.buckets) {
        this.queryBuckets(matching, x, y, radius, args.params, callback);
        } else {
        this.queryFeatures(matching, x, y, radius, args.params, callback);
        }
        };
        FeatureTree.prototype.queryFeatures = function(matching, x, y, radius, params, callback) {
        var result = [];
                for (var i = 0; i < matching.length; i++) {
        var feature = matching[i].feature;
                var type = this.getType(feature);
                var geometry = this.getGeometry(feature);
                if (params.bucket && matching[i].bucket !== params.bucket) continue;
                if (params.type && type !== params.type) continue;
                if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
        var props = {
        _bucket: matching[i].bucket,
                _type: type
        };
                if (params.geometry) {
        props._geometry = geometry;
        }

        for (var key in feature) {
        if (feature.hasOwnProperty(key) && key[0] !== '_') {
        props[key] = feature[key];
        }
        }
        result.push(props);
        }
        }

        callback(null, result);
        };
// Lists all buckets that at the position.
        FeatureTree.prototype.queryBuckets = function(matching, x, y, radius, params, callback) {
        var buckets = [];
                for (var i = 0; i < matching.length; i++) {
        if (buckets.indexOf(matching[i].bucket) >= 0) continue;
                var feature = matching[i].feature;
                var type = this.getType(feature);
                var geometry = this.getGeometry(feature);
                if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
        buckets.push(matching[i].bucket);
        }
        }

        callback(null, buckets);
        };
        function geometryContainsPoint(rings, type, p, radius) {
        if (type === 'Point') {
        return pointContainsPoint(rings, p, radius);
        } else if (type === 'LineString') {
        return lineContainsPoint(rings, p, radius);
        } else if (type === 'Polygon') {
        return polyContainsPoint(rings, p) ? true : lineContainsPoint(rings, p, radius);
        } else {
        return false;
        }
        }

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
var l2 = v.distSqr(w);
        if (l2 === 0) return p.distSqr(v);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) return p.distSqr(v);
        if (t > 1) return p.distSqr(w);
        return p.distSqr(w.sub(v)._mult(t)._add(v));
        }

function lineContainsPoint(rings, p, radius) {
var r = radius * radius;
        for (var i = 0; i < rings.length; i++) {
var ring = rings[i];
        for (var j = 1; j < ring.length; j++) {
// Find line segments that have a distance <= radius^2 to p
// In that case, we treat the line as "containing point p".
var v = ring[j - 1], w = ring[j];
        if (distToSegmentSquared(p, v, w) < r) return true;
}
}
return false;
        }

// point in polygon ray casting algorithm
function polyContainsPoint(rings, p) {
var c = false,
        ring, p1, p2;
        for (var k = 0; k < rings.length; k++) {
ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
p1 = ring[i];
        p2 = ring[j];
        if (((p1.y > p.y) != (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
c = !c;
}
}
}
return c;
        }

function pointContainsPoint(rings, p, radius) {
var r = radius * radius;
        for (var i = 0; i < rings.length; i++) {
var ring = rings[i];
        for (var j = 0; j < ring.length; j++) {
if (ring[j].distSqr(p) <= r) return true;
}
}
return false;
        }



}, {"point-geometry":99, "rbush":101}], 13:[function(require, module, exports){
'use strict';
        var ElementGroups = require('./elementgroups.js');
        module.exports = FillBucket;
        function FillBucket(info, buffers, placement, elementGroups) {
        this.info = info;
                this.buffers = buffers;
                this.elementGroups = elementGroups || new ElementGroups(buffers.fillVertex, buffers.fillElement, buffers.outlineElement);
        }

FillBucket.prototype.addFeatures = function() {
var features = this.features;
        for (var i = 0; i < features.length; i++) {
var feature = features[i];
        this.addFeature(feature.loadGeometry());
}
};
        FillBucket.prototype.addFeature = function(lines) {
        for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
        }
        };
        FillBucket.prototype.addFill = function(vertices) {
        if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
        }

        // Calculate the total number of vertices we're going to produce so that we
        // can resize the buffer beforehand, or detect whether the current line
        // won't fit into the buffer anymore.
        // In order to be able to use the vertex buffer for drawing the antialiased
        // outlines, we separate all polygon vertices with a degenerate (out-of-
        // viewplane) vertex.

        var len = vertices.length;
                // Check whether this geometry buffer can hold all the required vertices.
                this.elementGroups.makeRoomFor(len + 1);
                var elementGroup = this.elementGroups.current;
                var fillVertex = this.buffers.fillVertex;
                var fillElement = this.buffers.fillElement;
                var outlineElement = this.buffers.outlineElement;
                // Start all lines with a degenerate vertex
                elementGroup.vertexLength++;
                // We're generating triangle fans, so we always start with the first coordinate in this polygon.
                var firstIndex = fillVertex.index - elementGroup.vertexStartIndex,
                prevIndex, currentIndex, currentVertex;
                for (var i = 0; i < vertices.length; i++) {
        currentIndex = fillVertex.index - elementGroup.vertexStartIndex;
                currentVertex = vertices[i];
                fillVertex.add(currentVertex.x, currentVertex.y);
                elementGroup.vertexLength++;
                // Only add triangles that have distinct vertices.
                if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
        fillElement.add(firstIndex, prevIndex, currentIndex);
                elementGroup.elementLength++;
        }

        if (i >= 1) {
        outlineElement.add(prevIndex, currentIndex);
                elementGroup.secondElementLength++;
        }

        prevIndex = currentIndex;
        }
        };
        FillBucket.prototype.hasData = function() {
        return !!this.elementGroups.current;
        };
        }, {"./elementgroups.js":11}], 14:[function(require, module, exports){
'use strict';
        var ElementGroups = require('./elementgroups.js');
        module.exports = LineBucket;
        function LineBucket(info, buffers, placement, elementGroups) {
        this.info = info;
                this.buffers = buffers;
                this.elementGroups = elementGroups || new ElementGroups(buffers.lineVertex, buffers.lineElement);
        }

LineBucket.prototype.addFeatures = function() {
var features = this.features;
        for (var i = 0; i < features.length; i++) {
var feature = features[i];
        this.addFeature(feature.loadGeometry());
}
};
        LineBucket.prototype.addFeature = function(lines) {
        var info = this.info;
                for (var i = 0; i < lines.length; i++) {
        this.addLine(lines[i], info['line-join'], info['line-cap'],
                info['line-miter-limit'], info['line-round-limit']);
        }
        };
        LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {
        if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
        }

        if (join === 'bevel') miterLimit = 1.05;
                var len = vertices.length,
                firstVertex = vertices[0],
                lastVertex = vertices[len - 1],
                closed = firstVertex.equals(lastVertex);
                var lineVertex = this.buffers.lineVertex;
                var lineElement = this.buffers.lineElement;
                // we could be more precies, but it would only save a negligible amount of space
                this.elementGroups.makeRoomFor(len * 4);
                var elementGroup = this.elementGroups.current;
                var vertexStartIndex = elementGroup.vertexStartIndex;
                if (len == 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
        }

        var beginCap = cap,
                endCap = closed ? 'butt' : cap,
                flip = 1,
                distance = 0,
                currentVertex, prevVertex, nextVertex, prevNormal, nextNormal;
                // the last three vertices added
                var e1, e2, e3;
                if (closed) {
        currentVertex = vertices[len - 2];
                nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
        }

        for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
                vertices[1] : // if the line is closed, we treat the last vertex like the first
                vertices[i + 1]; // just the next vertex

                // if two consecutive vertices exist, skip the current one
                if (nextVertex && vertices[i].equals(nextVertex)) continue;
                if (nextNormal) prevNormal = nextNormal;
                if (currentVertex) prevVertex = currentVertex;
                currentVertex = vertices[i];
                // Calculate how far along the line the currentVertex is
                if (prevVertex) distance += currentVertex.dist(prevVertex);
                // Calculate the normal towards the next vertex in this line. In case
                // there is no next vertex, pretend that the line is continuing straight,
                // meaning that we are just using the previous normal.
                nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;
                // If we still don't have a previous normal, this is the beginning of a
                // non-closed line, so we're doing a straight "join".
                prevNormal = prevNormal || nextNormal;
                // Determine the normal of the join extrusion. It is the angle bisector
                // of the segments between the previous line and the next line.
                var joinNormal = prevNormal.add(nextNormal)._unit();
                /*  joinNormal     prevNormal
                 *             ↖      ↑
                 *                .________. prevVertex
                 *                |
                 * nextNormal  ←  |  currentVertex
                 *                |
                 *     nextVertex !
                 *
                 */

                // Calculate the length of the miter (the ratio of the miter to the width).
                // Find the cosine of the angle between the next and join normals
                // using dot product. The inverse of that is the miter length.
                var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
                var miterLength = 1 / cosHalfAngle;
                // Whether any vertices have been
                var startOfLine = e1 === undefined || e2 === undefined;
                // The join if a middle vertex, otherwise the cap.
                var middleVertex = prevVertex && nextVertex;
                var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;
                if (middleVertex && currentJoin === 'round' && miterLength < roundLimit) {
        currentJoin = 'miter';
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
        currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
        // The maximum extrude length is 63 / 256 = 4 times the width of the line
        // so if miterLength >= 4 we need to draw a different type of bevel where.
        if (miterLength > 4) currentJoin = 'flipbevel';
                // If the miterLength is really small and the line bevel wouldn't be visible,
                // just draw a miter join to save a triangle.
                if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Mitered joins
        if (currentJoin === 'miter') {
        // scale the unit vector by the miter length
        joinNormal._mult(miterLength);
                addCurrentVertex(joinNormal, 0, 0, false);
        } else if (currentJoin === 'flipbevel') {
        // miter is too big, flip the direction to make a beveled join

        if (miterLength > 100) {
        // Almost parallel lines
        flip = - flip;
                joinNormal = nextNormal;
        } else {
        var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(flip * bevelLength);
                flip = - flip;
        }
        addCurrentVertex(joinNormal, 0, 0, false);
                // All other types of joins
        } else {

        var offsetA, offsetB;
                if (currentJoin === 'bevel') {
        var dir = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
                var offset = - Math.sqrt(miterLength * miterLength - 1);
                if (flip * dir > 0) {
        offsetB = 0;
                offsetA = offset;
        } else {
        offsetA = 0;
                offsetB = offset;
        }
        } else if (currentJoin === 'square') {
        offsetA = offsetB = 1;
        } else {
        offsetA = offsetB = 0;
        }

        // Close previous segment with a butt or a square cap or bevel
        if (!startOfLine) {
        addCurrentVertex(prevNormal, offsetA, offsetB, false);
        }

        // Add round cap or linejoin at end of segment
        if (!startOfLine && currentJoin === 'round') {
        addCurrentVertex(prevNormal, 1, 1, true);
        }

        // Segment include cap are done, unset vertices to disconnect segments.
        // Or leave them to create a bevel.
        if (startOfLine || currentJoin !== 'bevel') {
        e1 = e2 = - 1;
                flip = 1;
        }

        // Add round cap before first segment
        if (startOfLine && beginCap === 'round') {
        addCurrentVertex(nextNormal, - 1, - 1, true);
        }

        // Start next segment with a butt or square cap or bevel
        if (nextVertex) {
        addCurrentVertex(nextNormal, - offsetA, - offsetB, false);
        }
        }

        }


        /*
         * Adds two vertices to the buffer that are
         * normal and -normal from the currentVertex.
         *
         * endBox moves the extrude one unit in the direction of the line
         * to create square or round cap.
         *
         * endLeft and endRight shifts the extrude along the line
         * endLeft === 1 moves the extrude in the direction of the line
         * endLeft === -1 moves the extrude in the reverse direction
         */
        function addCurrentVertex(normal, endLeft, endRight, round) {

        var tx = round ? 1 : 0;
                var extrude;
                extrude = normal.mult(flip);
                if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
                e3 = lineVertex.add(currentVertex, extrude, tx, 0, distance) - vertexStartIndex;
                if (e1 >= 0 && e2 >= 0) {
        lineElement.add(e1, e2, e3);
                elementGroup.elementLength++;
        }
        e1 = e2;
                e2 = e3;
                extrude = normal.mult( - flip);
                if (endRight) extrude._sub(normal.perp()._mult(endRight));
                e3 = lineVertex.add(currentVertex, extrude, tx, 1, distance) - vertexStartIndex;
                if (e1 >= 0 && e2 >= 0) {
        lineElement.add(e1, e2, e3);
                elementGroup.elementLength++;
        }
        e1 = e2;
                e2 = e3;
                elementGroup.vertexLength += 2;
        }
        };
        LineBucket.prototype.hasData = function() {
        return !!this.elementGroups.current;
        };
        }, {"./elementgroups.js":11}], 15:[function(require, module, exports){
'use strict';
        module.exports = RasterBucket;
        function RasterBucket(info) {
        this.info = info;
        }

}, {}], 16:[function(require, module, exports){
'use strict';
        var ElementGroups = require('./elementgroups.js');
        var Anchor = require('../symbol/anchor.js');
        var interpolate = require('../symbol/interpolate.js');
        var Point = require('point-geometry');
        var resolveTokens = require('../util/token.js');
        var Placement = require('../symbol/placement.js');
        var Shaping = require('../symbol/shaping.js');
        var resolveText = require('../symbol/resolvetext.js');
        module.exports = SymbolBucket;
        var fullRange = [2 * Math.PI, 0];
        function SymbolBucket(info, buffers, collision, elementGroups) {
        this.info = info;
                this.buffers = buffers;
                this.collision = collision;
                if (info['symbol-placement'] === 'line') {
        if (!info.hasOwnProperty('text-rotation-alignment')) {
        info['text-rotation-alignment'] = 'map';
        }
        if (!info.hasOwnProperty('icon-rotation-alignment')) {
        info['icon-rotation-alignment'] = 'map';
        }

        info['symbol-avoid-edges'] = true;
        }

        if (elementGroups) {
        this.elementGroups = elementGroups;
        } else {
        this.elementGroups = {
        text: new ElementGroups(buffers.glyphVertex),
                icon: new ElementGroups(buffers.iconVertex)
        };
        }
        }

SymbolBucket.prototype.addFeatures = function() {
var info = this.info;
        var features = this.features;
        var textFeatures = this.textFeatures;
        var horizontalAlign = 0.5;
        if (info['text-horizontal-align'] === 'right') horizontalAlign = 1;
        else if (info['text-horizontal-align'] === 'left') horizontalAlign = 0;
        var verticalAlign = 0.5;
        if (info['text-vertical-align'] === 'bottom') verticalAlign = 1;
        else if (info['text-vertical-align'] === 'top') verticalAlign = 0;
        var justify = 0.5;
        if (info['text-justify'] === 'right') justify = 1;
        else if (info['text-justify'] === 'left') justify = 0;
        var oneEm = 24;
        var lineHeight = info['text-line-height'] * oneEm;
        var maxWidth = info['symbol-placement'] !== 'line' && info['text-max-width'] * oneEm;
        var spacing = info['text-letter-spacing'] * oneEm;
        var fontstack = info['text-font'];
        var textOffset = [info['text-offset'][0] * oneEm, info['text-offset'][1] * oneEm];
        for (var k = 0; k < features.length; k++) {

var feature = features[k];
        var text = textFeatures[k];
        var lines = feature.loadGeometry();
        var shaping = false;
        if (text) {
shaping = Shaping.shape(text, fontstack, this.stacks, maxWidth,
        lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
}

var image = false;
        if (this.sprite && this.info['icon-image']) {
image = this.sprite[resolveTokens(feature.properties, info['icon-image'])];
        if (image) {
// match glyph tex object. TODO change
image.w = image.width;
        image.h = image.height;
        if (image.sdf) this.elementGroups.sdfIcons = true;
}
}

if (!shaping && !image) continue;
        this.addFeature(lines, this.stacks, shaping, image);
}
};
        function byScale(a, b) {
        return a.scale - b.scale;
        }

SymbolBucket.prototype.addFeature = function(lines, faces, shaping, image) {
var info = this.info;
        var collision = this.collision;
        var minScale = 0.5;
        var glyphSize = 24;
        var horizontalText = info['text-rotation-alignment'] === 'viewport',
        horizontalIcon = info['icon-rotation-alignment'] === 'viewport',
        fontScale = info['text-max-size'] / glyphSize,
        textBoxScale = collision.tilePixelRatio * fontScale,
        iconBoxScale = collision.tilePixelRatio * info['icon-max-size'],
        iconWithoutText = info['text-optional'] || !shaping,
        textWithoutIcon = info['icon-optional'] || !image,
        avoidEdges = info['symbol-avoid-edges'];
        for (var i = 0; i < lines.length; i++) {

var line = lines[i];
        var anchors;
        if (info['symbol-placement'] === 'line') {
// Line labels
anchors = interpolate(line, info['symbol-min-distance'], minScale, collision.maxPlacementScale, collision.tilePixelRatio);
        // Sort anchors by segment so that we can start placement with the
        // anchors that can be shown at the lowest zoom levels.
        anchors.sort(byScale);
} else {
// Point labels
anchors = [new Anchor(line[0].x, line[0].y, 0, minScale)];
}


// TODO: figure out correct ascender height.
var origin = new Point(0, - 17);
        for (var j = 0, len = anchors.length; j < len; j++) {
var anchor = anchors[j];
        var inside = !(anchor.x < 0 || anchor.x > 4096 || anchor.y < 0 || anchor.y > 4096);
        if (avoidEdges && !inside) continue;
        // Calculate the scales at which the text and icons can be first shown without overlap
        var glyph;
        var icon;
        var glyphScale = null;
        var iconScale = null;
        if (shaping) {
glyph = Placement.getGlyphs(anchor, origin, shaping, faces, textBoxScale, horizontalText, line, info);
        glyphScale = info['text-allow-overlap'] ? glyph.minScale
        : collision.getPlacementScale(glyph.boxes, glyph.minScale, avoidEdges);
        if (!glyphScale && !iconWithoutText) continue;
}

if (image) {
icon = Placement.getIcon(anchor, image, iconBoxScale, line, info);
        iconScale = info['icon-allow-overlap'] ? icon.minScale
        : collision.getPlacementScale(icon.boxes, icon.minScale, avoidEdges);
        if (!iconScale && !textWithoutIcon) continue;
}

if (!iconWithoutText && !textWithoutIcon) {
iconScale = glyphScale = Math.max(iconScale, glyphScale);
} else if (!textWithoutIcon && glyphScale) {
glyphScale = Math.max(iconScale, glyphScale);
} else if (!iconWithoutText && iconScale) {
iconScale = Math.max(iconScale, glyphScale);
}

// Get the rotation ranges it is safe to show the glyphs
var glyphRange = (!glyphScale || info['text-allow-overlap']) ? fullRange
        : collision.getPlacementRange(glyph.boxes, glyphScale, horizontalText);
        var iconRange = (!iconScale || info['icon-allow-overlap']) ? fullRange
        : collision.getPlacementRange(icon.boxes, iconScale, horizontalIcon);
        var maxRange = [
                Math.min(iconRange[0], glyphRange[0]),
                Math.max(iconRange[1], glyphRange[1])];
        if (!iconWithoutText && !textWithoutIcon) {
iconRange = glyphRange = maxRange;
} else if (!textWithoutIcon) {
glyphRange = maxRange;
} else if (!iconWithoutText) {
iconRange = maxRange;
}

// Insert final placement into collision tree and add glyphs/icons to buffers
if (glyphScale) {
if (!info['text-ignore-placement']) {
collision.insert(glyph.boxes, anchor, glyphScale, glyphRange, horizontalText);
}
if (inside) this.addSymbols(this.buffers.glyphVertex, this.elementGroups.text, glyph.shapes, glyphScale, glyphRange);
}

if (iconScale) {
if (!info['icon-ignore-placement']) {
collision.insert(icon.boxes, anchor, iconScale, iconRange, horizontalIcon);
}
if (inside) this.addSymbols(this.buffers.iconVertex, this.elementGroups.icon, icon.shapes, iconScale, iconRange);
}

}
}
};
        SymbolBucket.prototype.addSymbols = function(buffer, elementGroups, symbols, scale, placementRange) {

        var zoom = this.collision.zoom;
                elementGroups.makeRoomFor(0);
                var elementGroup = elementGroups.current;
                var placementZoom = Math.log(scale) / Math.LN2 + zoom;
                for (var k = 0; k < symbols.length; k++) {

        var symbol = symbols[k],
                tl = symbol.tl,
                tr = symbol.tr,
                bl = symbol.bl,
                br = symbol.br,
                tex = symbol.tex,
                angle = symbol.angle,
                anchor = symbol.anchor,
                minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
                maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);
                if (maxZoom <= minZoom) continue;
                // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
                if (minZoom === placementZoom) minZoom = 0;
                // first triangle
                buffer.add(anchor.x, anchor.y, tl.x, tl.y, tex.x, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
                buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
                buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);
                // second triangle
                buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
                buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);
                buffer.add(anchor.x, anchor.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);
                elementGroup.vertexLength += 6;
        }

        };
        SymbolBucket.prototype.getDependencies = function(tile, actor, callback) {
        var firstdone = false;
                var firsterr;
                this.getTextDependencies(tile, actor, done);
                this.getIconDependencies(tile, actor, done);
                function done(err) {
                if (err || firstdone) callback(err);
                        firstdone = true;
                        firsterr = err;
                }
        };
        SymbolBucket.prototype.getIconDependencies = function(tile, actor, callback) {
        var bucket = this;
                if (this.info['icon-image']) {
        if (SymbolBucket.sprite) {
        this.sprite = SymbolBucket.sprite;
                callback();
        } else {
        actor.send('get sprite json', {}, function(err, data) {
        SymbolBucket.sprite = bucket.sprite = data.sprite;
                callback(err);
        });
        }
        } else {
        callback();
        }
        };
        SymbolBucket.prototype.getTextDependencies = function(tile, actor, callback) {
        var features = this.features;
                var info = this.info;
                if (tile.stacks === undefined) tile.stacks = {};
                var stacks = this.stacks = tile.stacks;
                var fontstack = info['text-font'];
                if (stacks[fontstack] === undefined) {
        stacks[fontstack] = { glyphs: {}, rects: {} };
        }
        var stack = stacks[fontstack];
                var data = resolveText(features, info, stack.glyphs);
                this.textFeatures = data.textFeatures;
                actor.send('get glyphs', {
                id: tile.id,
                        fontstack: fontstack,
                        codepoints: data.codepoints
                }, function(err, newstack) {
                if (err) return callback(err);
                        var newglyphs = newstack.glyphs;
                        var newrects = newstack.rects;
                        var glyphs = stack.glyphs;
                        var rects = stack.rects;
                        for (var codepoint in newglyphs) {
                glyphs[codepoint] = newglyphs[codepoint];
                        rects[codepoint] = newrects[codepoint];
                }

                callback();
                });
        };
        SymbolBucket.prototype.hasData = function() {
        return !!this.elementGroups.text.current || !!this.elementGroups.icon.current;
        };
        }, {"../symbol/anchor.js":57, "../symbol/interpolate.js":62, "../symbol/placement.js":63, "../symbol/resolvetext.js":64, "../symbol/shaping.js":66, "../util/token.js":86, "./elementgroups.js":11, "point-geometry":99}], 17:[function(require, module, exports){
'use strict';
        module.exports = LatLng;
        function LatLng(lat, lng) {
        if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
        }
        this.lat = + lat;
                this.lng = + lng;
        }


// constructs LatLng from an array if necessary

LatLng.convert = function (a) {
if (a instanceof LatLng) {
return a;
}
if (Array.isArray(a)) {
return new LatLng(a[0], a[1]);
}
return a;
        };
        }, {}], 18:[function(require, module, exports){
'use strict';
        module.exports = LatLngBounds;
        var LatLng = require('./latlng.js');
        function LatLngBounds(sw, ne) {
        if (!sw) return;
                var latlngs = ne ? [sw, ne] : sw;
                for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
        }
        }

LatLngBounds.prototype = {

// extend the bounds to contain the given point or bounds
extend: function (obj) {
var sw = this._sw,
        ne = this._ne,
        sw2, ne2;
        if (obj instanceof LatLng) {
sw2 = obj;
        ne2 = obj;
} else if (obj instanceof LatLngBounds) {
sw2 = obj._sw;
        ne2 = obj._ne;
        if (!sw2 || !ne2) return this;
} else {
return obj ? this.extend(LatLng.convert(obj) || LatLngBounds.convert(obj)) : this;
}

if (!sw && !ne) {
this._sw = new LatLng(sw2.lat, sw2.lng);
        this._ne = new LatLng(ne2.lat, ne2.lng);
} else {
sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
}

return this;
},
        getCenter: function () {
        return new LatLng((this._sw.lat + this._ne.lat) / 2, (this._sw.lng + this._ne.lng) / 2);
        },
        getSouthWest: function () { return this._sw; },
        getNorthEast: function () { return this._ne; },
        getNorthWest: function () { return new LatLng(this.getNorth(), this.getWest()); },
        getSouthEast: function () { return new LatLng(this.getSouth(), this.getEast()); },
        getWest:  function () { return this._sw.lng; },
        getSouth: function () { return this._sw.lat; },
        getEast:  function () { return this._ne.lng; },
        getNorth: function () { return this._ne.lat; }
};
// constructs LatLngBounds from an array if necessary
        LatLngBounds.convert = function (a) {
        if (!a || a instanceof LatLngBounds) return a;
                return new LatLngBounds(a);
        };
        }, {"./latlng.js":17}], 19:[function(require, module, exports){
'use strict';
        var LatLng = require('./latlng.js'),
        Point = require('point-geometry');
        module.exports = Transform;
// A single transform, generally used for a single tile to be scaled, rotated, and zoomed.

        function Transform(minZoom, maxZoom) {
        this.tileSize = 512; // constant

                this._minZoom = minZoom || 0;
                this._maxZoom = maxZoom || 22;
                this.latRange = [ - 85.05113, 85.05113];
                this.width = 0;
                this.height = 0;
                this.zoom = 0;
                this.center = new LatLng(0, 0);
                this.angle = 0;
        }

Transform.prototype = {
get minZoom() { return this._minZoom; },
        set minZoom(zoom) {
this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
},
        get maxZoom() { return this._maxZoom; },
        set maxZoom(zoom) {
this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
},
        get worldSize() {
return this.tileSize * this.scale;
},
        get centerPoint() {
return this.size._div(2);
},
        get size() {
return new Point(this.width, this.height);
},
        get bearing() {
return - this.angle / Math.PI * 180;
},
        set bearing(bearing) {
// confine the angle to within [-180,180]
bearing = ((((bearing + 180) % 360) + 360) % 360) - 180;
        this.angle = - bearing * Math.PI / 180;
},
        get zoom() { return this._zoom; },
        set zoom(zoom) {
zoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        this._zoom = zoom;
        this.scale = this.zoomScale(zoom);
        this.tileZoom = Math.floor(zoom);
        this.zoomFraction = zoom - this.tileZoom;
        this._constrain();
},
        zoomScale: function(zoom) { return Math.pow(2, zoom); },
        scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },
        project: function(latlng, worldSize) {
        return new Point(
                this.lngX(latlng.lng, worldSize),
                this.latY(latlng.lat, worldSize));
        },
        unproject: function(point, worldSize) {
        return new LatLng(
                this.yLat(point.y, worldSize),
                this.xLng(point.x, worldSize));
        },
        get x() { return this.lngX(this.center.lng); },
        get y() { return this.latY(this.center.lat); },
        get point() { return new Point(this.x, this.y); },
        // lat/lon <-> absolute pixel coords convertion
        lngX: function(lon, worldSize) {
        return (180 + lon) * (worldSize || this.worldSize) / 360;
        },
        // latitude to absolute y coord
        latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
                return (180 - y) * (worldSize || this.worldSize) / 360;
        },
        xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
        },
        yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
                return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
        },
        panBy: function(offset) {
        var point = this.centerPoint._add(offset);
                this.center = this.pointLocation(point);
                this._constrain();
        },
        setZoomAround: function(zoom, center) {
        var p = this.locationPoint(center),
                p1 = this.size._sub(p),
                latlng = this.pointLocation(p1);
                this.zoom = zoom;
                this.panBy(p1.sub(this.locationPoint(latlng)));
        },
        setBearingAround: function(bearing, center) {
        var offset = this.locationPoint(center).sub(this.centerPoint);
                this.panBy(offset);
                this.bearing = bearing;
                this.panBy(offset.mult( - 1));
        },
        locationPoint: function(latlng) {
        var p = this.project(latlng);
                return this.centerPoint._sub(this.point._sub(p)._rotate(this.angle));
        },
        pointLocation: function(p) {
        var p2 = this.centerPoint._sub(p)._rotate( - this.angle);
                return this.unproject(this.point.sub(p2));
        },
        locationCoordinate: function(latlng) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize;
                return {
                column: this.lngX(latlng.lng) * k,
                        row: this.latY(latlng.lat) * k,
                        zoom: this.tileZoom
                };
        },
        pointCoordinate: function(tileCenter, p) {
        var zoomFactor = this.zoomScale(this.zoomFraction),
                kt = this.zoomScale(this.tileZoom - tileCenter.zoom),
                p2 = this.centerPoint._sub(p)._rotate( - this.angle)._div(this.tileSize * zoomFactor);
                return {
                column: tileCenter.column * kt - p2.x,
                        row: tileCenter.row * kt - p2.y,
                        zoom: this.tileZoom
                };
        },
        _constrain: function() {
        if (!this.center) return;
                var minY, maxY, minX, maxX, sy, sx, x2, y2,
                size = this.size;
                if (this.latRange) {
        minY = this.latY(this.latRange[1]);
                maxY = this.latY(this.latRange[0]);
                sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
        minX = this.lngX(this.lngRange[0]);
                maxX = this.lngX(this.lngRange[1]);
                sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);
                if (s) {
        this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
                this.zoom += this.scaleZoom(s);
                return;
        }

        if (this.latRange) {
        var y = this.y,
                h2 = size.y / 2;
                if (y - h2 < minY) y2 = minY + h2;
                if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
        var x = this.x,
                w2 = size.x / 2;
                if (x - w2 < minX) x2 = minX + w2;
                if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
        this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }
        }
};
        }, {"./latlng.js":17, "point-geometry":99}], 20:[function(require, module, exports){
// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplex_font = {
" ": [16, []],
        "!": [10, [5, 21, 5, 7, - 1, - 1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        "\"": [16, [4, 21, 4, 14, - 1, - 1, 12, 21, 12, 14]],
        "#": [21, [11, 25, 4, - 7, - 1, - 1, 17, 25, 10, - 7, - 1, - 1, 4, 12, 18, 12, - 1, - 1, 3, 6, 17, 6]],
        "$": [20, [8, 25, 8, - 4, - 1, - 1, 12, 25, 12, - 4, - 1, - 1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        "%": [24, [21, 21, 3, 0, - 1, - 1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, - 1, - 1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
        "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
        "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
        "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, - 2, 9, - 5, 11, - 7]],
        ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, - 2, 5, - 5, 3, - 7]],
        "*": [16, [8, 21, 8, 9, - 1, - 1, 3, 18, 13, 12, - 1, - 1, 13, 18, 3, 12]],
        "+": [26, [13, 18, 13, 0, - 1, - 1, 4, 9, 22, 9]],
        ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, - 1, 5, - 3, 4, - 4]],
        "-": [26, [4, 9, 22, 9]],
        ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        "/": [22, [20, 25, 2, - 7]],
        "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
        "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
        "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
        "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        "4": [20, [13, 21, 3, 7, 18, 7, - 1, - 1, 13, 21, 13, 0]],
        "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
        "7": [20, [17, 21, 7, 0, - 1, - 1, 3, 21, 17, 21]],
        "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
        "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
        ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, - 1, - 1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, - 1, - 1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, - 1, 5, - 3, 4, - 4]],
        "<": [24, [20, 18, 4, 9, 20, 0]],
        "=": [26, [4, 12, 22, 12, - 1, - 1, 4, 6, 22, 6]],
        ">": [24, [4, 18, 20, 9, 4, 0]],
        "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, - 1, - 1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
        "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, - 1, - 1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, - 1, - 1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, - 1, - 1, 19, 16, 18, 8, 18, 6, 19, 5]],
        "A": [18, [9, 21, 1, 0, - 1, - 1, 9, 21, 17, 0, - 1, - 1, 4, 7, 14, 7]],
        "B": [21, [4, 21, 4, 0, - 1, - 1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, - 1, - 1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
        "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
        "D": [21, [4, 21, 4, 0, - 1, - 1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
        "E": [19, [4, 21, 4, 0, - 1, - 1, 4, 21, 17, 21, - 1, - 1, 4, 11, 12, 11, - 1, - 1, 4, 0, 17, 0]],
        "F": [18, [4, 21, 4, 0, - 1, - 1, 4, 21, 17, 21, - 1, - 1, 4, 11, 12, 11]],
        "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, - 1, - 1, 13, 8, 18, 8]],
        "H": [22, [4, 21, 4, 0, - 1, - 1, 18, 21, 18, 0, - 1, - 1, 4, 11, 18, 11]],
        "I": [8, [4, 21, 4, 0]],
        "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
        "K": [21, [4, 21, 4, 0, - 1, - 1, 18, 21, 4, 7, - 1, - 1, 9, 12, 18, 0]],
        "L": [17, [4, 21, 4, 0, - 1, - 1, 4, 0, 16, 0]],
        "M": [24, [4, 21, 4, 0, - 1, - 1, 4, 21, 12, 0, - 1, - 1, 20, 21, 12, 0, - 1, - 1, 20, 21, 20, 0]],
        "N": [22, [4, 21, 4, 0, - 1, - 1, 4, 21, 18, 0, - 1, - 1, 18, 21, 18, 0]],
        "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
        "P": [21, [4, 21, 4, 0, - 1, - 1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
        "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, - 1, - 1, 12, 4, 18, - 2]],
        "R": [21, [4, 21, 4, 0, - 1, - 1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, - 1, - 1, 11, 11, 18, 0]],
        "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        "T": [16, [8, 21, 8, 0, - 1, - 1, 1, 21, 15, 21]],
        "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
        "V": [18, [1, 21, 9, 0, - 1, - 1, 17, 21, 9, 0]],
        "W": [24, [2, 21, 7, 0, - 1, - 1, 12, 21, 7, 0, - 1, - 1, 12, 21, 17, 0, - 1, - 1, 22, 21, 17, 0]],
        "X": [20, [3, 21, 17, 0, - 1, - 1, 17, 21, 3, 0]],
        "Y": [18, [1, 21, 9, 11, 9, 0, - 1, - 1, 17, 21, 9, 11]],
        "Z": [20, [17, 21, 3, 0, - 1, - 1, 3, 21, 17, 21, - 1, - 1, 3, 0, 17, 0]],
        "[": [14, [4, 25, 4, - 7, - 1, - 1, 5, 25, 5, - 7, - 1, - 1, 4, 25, 11, 25, - 1, - 1, 4, - 7, 11, - 7]],
        "\\": [14, [0, 21, 14, - 3]],
        "]": [14, [9, 25, 9, - 7, - 1, - 1, 10, 25, 10, - 7, - 1, - 1, 3, 25, 10, 25, - 1, - 1, 3, - 7, 10, - 7]],
        "^": [16, [6, 15, 8, 18, 10, 15, - 1, - 1, 3, 12, 8, 17, 13, 12, - 1, - 1, 8, 17, 8, 0]],
        "_": [16, [0, - 2, 16, - 2]],
        "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
        "a": [19, [15, 14, 15, 0, - 1, - 1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "b": [19, [4, 21, 4, 0, - 1, - 1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "d": [19, [15, 21, 15, 0, - 1, - 1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, - 1, - 1, 2, 14, 9, 14]],
        "g": [19, [15, 14, 15, - 2, 14, - 5, 13, - 6, 11, - 7, 8, - 7, 6, - 6, - 1, - 1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "h": [19, [4, 21, 4, 0, - 1, - 1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, - 1, - 1, 4, 14, 4, 0]],
        "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, - 1, - 1, 6, 14, 6, - 3, 5, - 6, 3, - 7, 1, - 7]],
        "k": [17, [4, 21, 4, 0, - 1, - 1, 14, 14, 4, 4, - 1, - 1, 8, 8, 15, 0]],
        "l": [8, [4, 21, 4, 0]],
        "m": [30, [4, 14, 4, 0, - 1, - 1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, - 1, - 1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
        "n": [19, [4, 14, 4, 0, - 1, - 1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
        "p": [19, [4, 14, 4, - 7, - 1, - 1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        "q": [19, [15, 14, 15, - 7, - 1, - 1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "r": [13, [4, 14, 4, 0, - 1, - 1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
        "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
        "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, - 1, - 1, 2, 14, 9, 14]],
        "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, - 1, - 1, 15, 14, 15, 0]],
        "v": [16, [2, 14, 8, 0, - 1, - 1, 14, 14, 8, 0]],
        "w": [22, [3, 14, 7, 0, - 1, - 1, 11, 14, 7, 0, - 1, - 1, 11, 14, 15, 0, - 1, - 1, 19, 14, 15, 0]],
        "x": [17, [3, 14, 14, 0, - 1, - 1, 14, 14, 3, 0]],
        "y": [16, [2, 14, 8, 0, - 1, - 1, 14, 14, 8, 0, 6, - 4, 4, - 6, 2, - 7, 1, - 7]],
        "z": [17, [14, 14, 3, 0, - 1, - 1, 3, 14, 14, 14, - 1, - 1, 3, 0, 14, 0]],
        "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, - 1, - 1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, - 2, 6, - 4, 7, - 6, - 1, - 1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, - 1, 5, - 3, 6, - 5, 7, - 6, 9, - 7]],
        "|": [8, [4, 25, 4, - 7]],
        "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, - 1, - 1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, - 2, 8, - 4, 7, - 6, - 1, - 1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, - 1, 9, - 3, 8, - 5, 7, - 6, 5, - 7]],
        "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, - 1, - 1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]],
        };
        module.exports = function textVertices(text, left, baseline, scale) {
        scale = scale || 1;
                var strokes = [],
                i, len, j, len2, glyph, data, x, y, prev;
                for (i = 0, len = text.length; i < len; i++) {
        glyph = simplex_font[text[i]];
                if (!glyph) continue;
                prev = null;
                for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
        if (glyph[1][j] === - 1 && glyph[1][j + 1] === - 1) {
        prev = null;
        } else {
        x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
        strokes.push(prev.x, prev.y, x, y);
        }
        prev = {x: x, y: y};
        }
        }
        left += glyph[0] * scale;
        }

        return strokes;
        };
        }, {}], 21:[function(require, module, exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.0
 */
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict"; var t = {}; typeof exports == "undefined"?typeof define == "function" && typeof define.amd == "object" && define.amd?(t.exports = {}, define(function(){return t.exports})):t.exports = typeof window != "undefined"?window:e:t.exports = exports, function(e){if (!t)var t = 1e-6; if (!n)var n = typeof Float32Array != "undefined"?Float32Array:Array; if (!r)var r = Math.random; var i = {}; i.setMatrixArrayType = function(e){n = e}, typeof e != "undefined" && (e.glMatrix = i); var s = {}; s.create = function(){var e = new n(2); return e[0] = 0, e[1] = 0, e}, s.clone = function(e){var t = new n(2); return t[0] = e[0], t[1] = e[1], t}, s.fromValues = function(e, t){var r = new n(2); return r[0] = e, r[1] = t, r}, s.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e}, s.set = function(e, t, n){return e[0] = t, e[1] = n, e}, s.add = function(e, t, n){return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e}, s.subtract = function(e, t, n){return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e}, s.sub = s.subtract, s.multiply = function(e, t, n){return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e}, s.mul = s.multiply, s.divide = function(e, t, n){return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e}, s.div = s.divide, s.min = function(e, t, n){return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e}, s.max = function(e, t, n){return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e}, s.scale = function(e, t, n){return e[0] = t[0] * n, e[1] = t[1] * n, e}, s.scaleAndAdd = function(e, t, n, r){return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e}, s.distance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1]; return Math.sqrt(n * n + r * r)}, s.dist = s.distance, s.squaredDistance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1]; return n * n + r * r}, s.sqrDist = s.squaredDistance, s.length = function(e){var t = e[0], n = e[1]; return Math.sqrt(t * t + n * n)}, s.len = s.length, s.squaredLength = function(e){var t = e[0], n = e[1]; return t * t + n * n}, s.sqrLen = s.squaredLength, s.negate = function(e, t){return e[0] = - t[0], e[1] = - t[1], e}, s.normalize = function(e, t){var n = t[0], r = t[1], i = n * n + r * r; return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i), e}, s.dot = function(e, t){return e[0] * t[0] + e[1] * t[1]}, s.cross = function(e, t, n){var r = t[0] * n[1] - t[1] * n[0]; return e[0] = e[1] = 0, e[2] = r, e}, s.lerp = function(e, t, n, r){var i = t[0], s = t[1]; return e[0] = i + r * (n[0] - i), e[1] = s + r * (n[1] - s), e}, s.random = function(e, t){t = t || 1; var n = r() * 2 * Math.PI; return e[0] = Math.cos(n) * t, e[1] = Math.sin(n) * t, e}, s.transformMat2 = function(e, t, n){var r = t[0], i = t[1]; return e[0] = n[0] * r + n[2] * i, e[1] = n[1] * r + n[3] * i, e}, s.transformMat2d = function(e, t, n){var r = t[0], i = t[1]; return e[0] = n[0] * r + n[2] * i + n[4], e[1] = n[1] * r + n[3] * i + n[5], e}, s.transformMat3 = function(e, t, n){var r = t[0], i = t[1]; return e[0] = n[0] * r + n[3] * i + n[6], e[1] = n[1] * r + n[4] * i + n[7], e}, s.transformMat4 = function(e, t, n){var r = t[0], i = t[1]; return e[0] = n[0] * r + n[4] * i + n[12], e[1] = n[1] * r + n[5] * i + n[13], e}, s.forEach = function(){var e = s.create(); return function(t, n, r, i, s, o){var u, a; n || (n = 2), r || (r = 0), i?a = Math.min(i * n + r, t.length):a = t.length; for (u = r; u < a; u += n)e[0] = t[u], e[1] = t[u + 1], s(e, e, o), t[u] = e[0], t[u + 1] = e[1]; return t}}(), s.str = function(e){return"vec2(" + e[0] + ", " + e[1] + ")"}, typeof e != "undefined" && (e.vec2 = s); var o = {}; o.create = function(){var e = new n(3); return e[0] = 0, e[1] = 0, e[2] = 0, e}, o.clone = function(e){var t = new n(3); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t}, o.fromValues = function(e, t, r){var i = new n(3); return i[0] = e, i[1] = t, i[2] = r, i}, o.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e}, o.set = function(e, t, n, r){return e[0] = t, e[1] = n, e[2] = r, e}, o.add = function(e, t, n){return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e}, o.subtract = function(e, t, n){return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e}, o.sub = o.subtract, o.multiply = function(e, t, n){return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e}, o.mul = o.multiply, o.divide = function(e, t, n){return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e}, o.div = o.divide, o.min = function(e, t, n){return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e}, o.max = function(e, t, n){return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e}, o.scale = function(e, t, n){return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e}, o.scaleAndAdd = function(e, t, n, r){return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e}, o.distance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2]; return Math.sqrt(n * n + r * r + i * i)}, o.dist = o.distance, o.squaredDistance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2]; return n * n + r * r + i * i}, o.sqrDist = o.squaredDistance, o.length = function(e){var t = e[0], n = e[1], r = e[2]; return Math.sqrt(t * t + n * n + r * r)}, o.len = o.length, o.squaredLength = function(e){var t = e[0], n = e[1], r = e[2]; return t * t + n * n + r * r}, o.sqrLen = o.squaredLength, o.negate = function(e, t){return e[0] = - t[0], e[1] = - t[1], e[2] = - t[2], e}, o.normalize = function(e, t){var n = t[0], r = t[1], i = t[2], s = n * n + r * r + i * i; return s > 0 && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s), e}, o.dot = function(e, t){return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]}, o.cross = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = n[0], u = n[1], a = n[2]; return e[0] = i * a - s * u, e[1] = s * o - r * a, e[2] = r * u - i * o, e}, o.lerp = function(e, t, n, r){var i = t[0], s = t[1], o = t[2]; return e[0] = i + r * (n[0] - i), e[1] = s + r * (n[1] - s), e[2] = o + r * (n[2] - o), e}, o.random = function(e, t){t = t || 1; var n = r() * 2 * Math.PI, i = r() * 2 - 1, s = Math.sqrt(1 - i * i) * t; return e[0] = Math.cos(n) * s, e[1] = Math.sin(n) * s, e[2] = i * t, e}, o.transformMat4 = function(e, t, n){var r = t[0], i = t[1], s = t[2]; return e[0] = n[0] * r + n[4] * i + n[8] * s + n[12], e[1] = n[1] * r + n[5] * i + n[9] * s + n[13], e[2] = n[2] * r + n[6] * i + n[10] * s + n[14], e}, o.transformMat3 = function(e, t, n){var r = t[0], i = t[1], s = t[2]; return e[0] = r * n[0] + i * n[3] + s * n[6], e[1] = r * n[1] + i * n[4] + s * n[7], e[2] = r * n[2] + i * n[5] + s * n[8], e}, o.transformQuat = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = n[0], u = n[1], a = n[2], f = n[3], l = f * r + u * s - a * i, c = f * i + a * r - o * s, h = f * s + o * i - u * r, p = - o * r - u * i - a * s; return e[0] = l * f + p * - o + c * - a - h * - u, e[1] = c * f + p * - u + h * - o - l * - a, e[2] = h * f + p * - a + l * - u - c * - o, e}, o.forEach = function(){var e = o.create(); return function(t, n, r, i, s, o){var u, a; n || (n = 3), r || (r = 0), i?a = Math.min(i * n + r, t.length):a = t.length; for (u = r; u < a; u += n)e[0] = t[u], e[1] = t[u + 1], e[2] = t[u + 2], s(e, e, o), t[u] = e[0], t[u + 1] = e[1], t[u + 2] = e[2]; return t}}(), o.str = function(e){return"vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"}, typeof e != "undefined" && (e.vec3 = o); var u = {}; u.create = function(){var e = new n(4); return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e}, u.clone = function(e){var t = new n(4); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t}, u.fromValues = function(e, t, r, i){var s = new n(4); return s[0] = e, s[1] = t, s[2] = r, s[3] = i, s}, u.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e}, u.set = function(e, t, n, r, i){return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e}, u.add = function(e, t, n){return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e}, u.subtract = function(e, t, n){return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e}, u.sub = u.subtract, u.multiply = function(e, t, n){return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e}, u.mul = u.multiply, u.divide = function(e, t, n){return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e[3] = t[3] / n[3], e}, u.div = u.divide, u.min = function(e, t, n){return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e[3] = Math.min(t[3], n[3]), e}, u.max = function(e, t, n){return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e[3] = Math.max(t[3], n[3]), e}, u.scale = function(e, t, n){return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e}, u.scaleAndAdd = function(e, t, n, r){return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e}, u.distance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2], s = t[3] - e[3]; return Math.sqrt(n * n + r * r + i * i + s * s)}, u.dist = u.distance, u.squaredDistance = function(e, t){var n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2], s = t[3] - e[3]; return n * n + r * r + i * i + s * s}, u.sqrDist = u.squaredDistance, u.length = function(e){var t = e[0], n = e[1], r = e[2], i = e[3]; return Math.sqrt(t * t + n * n + r * r + i * i)}, u.len = u.length, u.squaredLength = function(e){var t = e[0], n = e[1], r = e[2], i = e[3]; return t * t + n * n + r * r + i * i}, u.sqrLen = u.squaredLength, u.negate = function(e, t){return e[0] = - t[0], e[1] = - t[1], e[2] = - t[2], e[3] = - t[3], e}, u.normalize = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = n * n + r * r + i * i + s * s; return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o, e[3] = t[3] * o), e}, u.dot = function(e, t){return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]}, u.lerp = function(e, t, n, r){var i = t[0], s = t[1], o = t[2], u = t[3]; return e[0] = i + r * (n[0] - i), e[1] = s + r * (n[1] - s), e[2] = o + r * (n[2] - o), e[3] = u + r * (n[3] - u), e}, u.random = function(e, t){return t = t || 1, e[0] = r(), e[1] = r(), e[2] = r(), e[3] = r(), u.normalize(e, e), u.scale(e, e, t), e}, u.transformMat4 = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3]; return e[0] = n[0] * r + n[4] * i + n[8] * s + n[12] * o, e[1] = n[1] * r + n[5] * i + n[9] * s + n[13] * o, e[2] = n[2] * r + n[6] * i + n[10] * s + n[14] * o, e[3] = n[3] * r + n[7] * i + n[11] * s + n[15] * o, e}, u.transformQuat = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = n[0], u = n[1], a = n[2], f = n[3], l = f * r + u * s - a * i, c = f * i + a * r - o * s, h = f * s + o * i - u * r, p = - o * r - u * i - a * s; return e[0] = l * f + p * - o + c * - a - h * - u, e[1] = c * f + p * - u + h * - o - l * - a, e[2] = h * f + p * - a + l * - u - c * - o, e}, u.forEach = function(){var e = u.create(); return function(t, n, r, i, s, o){var u, a; n || (n = 4), r || (r = 0), i?a = Math.min(i * n + r, t.length):a = t.length; for (u = r; u < a; u += n)e[0] = t[u], e[1] = t[u + 1], e[2] = t[u + 2], e[3] = t[u + 3], s(e, e, o), t[u] = e[0], t[u + 1] = e[1], t[u + 2] = e[2], t[u + 3] = e[3]; return t}}(), u.str = function(e){return"vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"}, typeof e != "undefined" && (e.vec4 = u); var a = {}; a.create = function(){var e = new n(4); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e}, a.clone = function(e){var t = new n(4); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t}, a.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e}, a.identity = function(e){return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e}, a.transpose = function(e, t){if (e === t){var n = t[1]; e[1] = t[2], e[2] = n} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3]; return e}, a.invert = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = n * s - i * r; return o?(o = 1 / o, e[0] = s * o, e[1] = - r * o, e[2] = - i * o, e[3] = n * o, e):null}, a.adjoint = function(e, t){var n = t[0]; return e[0] = t[3], e[1] = - t[1], e[2] = - t[2], e[3] = n, e}, a.determinant = function(e){return e[0] * e[3] - e[2] * e[1]}, a.multiply = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = n[0], a = n[1], f = n[2], l = n[3]; return e[0] = r * u + i * f, e[1] = r * a + i * l, e[2] = s * u + o * f, e[3] = s * a + o * l, e}, a.mul = a.multiply, a.rotate = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = Math.sin(n), a = Math.cos(n); return e[0] = r * a + i * u, e[1] = r * - u + i * a, e[2] = s * a + o * u, e[3] = s * - u + o * a, e}, a.scale = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = n[0], a = n[1]; return e[0] = r * u, e[1] = i * a, e[2] = s * u, e[3] = o * a, e}, a.str = function(e){return"mat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"}, typeof e != "undefined" && (e.mat2 = a); var f = {}; f.create = function(){var e = new n(6); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e}, f.clone = function(e){var t = new n(6); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t}, f.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e}, f.identity = function(e){return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e}, f.invert = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = n * s - r * i; return a?(a = 1 / a, e[0] = s * a, e[1] = - r * a, e[2] = - i * a, e[3] = n * a, e[4] = (i * u - s * o) * a, e[5] = (r * o - n * u) * a, e):null}, f.determinant = function(e){return e[0] * e[3] - e[1] * e[2]}, f.multiply = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = n[0], l = n[1], c = n[2], h = n[3], p = n[4], d = n[5]; return e[0] = r * f + i * c, e[1] = r * l + i * h, e[2] = s * f + o * c, e[3] = s * l + o * h, e[4] = f * u + c * a + p, e[5] = l * u + h * a + d, e}, f.mul = f.multiply, f.rotate = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = Math.sin(n), l = Math.cos(n); return e[0] = r * l + i * f, e[1] = - r * f + i * l, e[2] = s * l + o * f, e[3] = - s * f + l * o, e[4] = l * u + f * a, e[5] = l * a - f * u, e}, f.scale = function(e, t, n){var r = n[0], i = n[1]; return e[0] = t[0] * r, e[1] = t[1] * i, e[2] = t[2] * r, e[3] = t[3] * i, e[4] = t[4] * r, e[5] = t[5] * i, e}, f.translate = function(e, t, n){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + n[0], e[5] = t[5] + n[1], e}, f.str = function(e){return"mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")"}, typeof e != "undefined" && (e.mat2d = f); var l = {}; l.create = function(){var e = new n(9); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e}, l.fromMat4 = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e}, l.clone = function(e){var t = new n(9); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t}, l.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e}, l.identity = function(e){return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e}, l.transpose = function(e, t){if (e === t){var n = t[1], r = t[2], i = t[5]; e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = r, e[7] = i} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8]; return e}, l.invert = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = t[6], f = t[7], l = t[8], c = l * o - u * f, h = - l * s + u * a, p = f * s - o * a, d = n * c + r * h + i * p; return d?(d = 1 / d, e[0] = c * d, e[1] = ( - l * r + i * f) * d, e[2] = (u * r - i * o) * d, e[3] = h * d, e[4] = (l * n - i * a) * d, e[5] = ( - u * n + i * s) * d, e[6] = p * d, e[7] = ( - f * n + r * a) * d, e[8] = (o * n - r * s) * d, e):null}, l.adjoint = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = t[6], f = t[7], l = t[8]; return e[0] = o * l - u * f, e[1] = i * f - r * l, e[2] = r * u - i * o, e[3] = u * a - s * l, e[4] = n * l - i * a, e[5] = i * s - n * u, e[6] = s * f - o * a, e[7] = r * a - n * f, e[8] = n * o - r * s, e}, l.determinant = function(e){var t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], o = e[5], u = e[6], a = e[7], f = e[8]; return t * (f * s - o * a) + n * ( - f * i + o * u) + r * (a * i - s * u)}, l.multiply = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = t[6], l = t[7], c = t[8], h = n[0], p = n[1], d = n[2], v = n[3], m = n[4], g = n[5], y = n[6], b = n[7], w = n[8]; return e[0] = h * r + p * o + d * f, e[1] = h * i + p * u + d * l, e[2] = h * s + p * a + d * c, e[3] = v * r + m * o + g * f, e[4] = v * i + m * u + g * l, e[5] = v * s + m * a + g * c, e[6] = y * r + b * o + w * f, e[7] = y * i + b * u + w * l, e[8] = y * s + b * a + w * c, e}, l.mul = l.multiply, l.translate = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = t[6], l = t[7], c = t[8], h = n[0], p = n[1]; return e[0] = r, e[1] = i, e[2] = s, e[3] = o, e[4] = u, e[5] = a, e[6] = h * r + p * o + f, e[7] = h * i + p * u + l, e[8] = h * s + p * a + c, e}, l.rotate = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = t[6], l = t[7], c = t[8], h = Math.sin(n), p = Math.cos(n); return e[0] = p * r + h * o, e[1] = p * i + h * u, e[2] = p * s + h * a, e[3] = p * o - h * r, e[4] = p * u - h * i, e[5] = p * a - h * s, e[6] = f, e[7] = l, e[8] = c, e}, l.scale = function(e, t, n){var r = n[0], i = n[1]; return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e}, l.fromMat2d = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e}, l.fromQuat = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = n + n, u = r + r, a = i + i, f = n * o, l = n * u, c = n * a, h = r * u, p = r * a, d = i * a, v = s * o, m = s * u, g = s * a; return e[0] = 1 - (h + d), e[3] = l + g, e[6] = c - m, e[1] = l - g, e[4] = 1 - (f + d), e[7] = p + v, e[2] = c + m, e[5] = p - v, e[8] = 1 - (f + h), e}, l.normalFromMat4 = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = t[6], f = t[7], l = t[8], c = t[9], h = t[10], p = t[11], d = t[12], v = t[13], m = t[14], g = t[15], y = n * u - r * o, b = n * a - i * o, w = n * f - s * o, E = r * a - i * u, S = r * f - s * u, x = i * f - s * a, T = l * v - c * d, N = l * m - h * d, C = l * g - p * d, k = c * m - h * v, L = c * g - p * v, A = h * g - p * m, O = y * A - b * L + w * k + E * C - S * N + x * T; return O?(O = 1 / O, e[0] = (u * A - a * L + f * k) * O, e[1] = (a * C - o * A - f * N) * O, e[2] = (o * L - u * C + f * T) * O, e[3] = (i * L - r * A - s * k) * O, e[4] = (n * A - i * C + s * N) * O, e[5] = (r * C - n * L - s * T) * O, e[6] = (v * x - m * S + g * E) * O, e[7] = (m * w - d * x - g * b) * O, e[8] = (d * S - v * w + g * y) * O, e):null}, l.str = function(e){return"mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"}, typeof e != "undefined" && (e.mat3 = l); var c = {}; c.create = function(){var e = new n(16); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e}, c.clone = function(e){var t = new n(16); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t}, c.copy = function(e, t){return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e}, c.identity = function(e){return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e}, c.transpose = function(e, t){if (e === t){var n = t[1], r = t[2], i = t[3], s = t[6], o = t[7], u = t[11]; e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = r, e[9] = s, e[11] = t[14], e[12] = i, e[13] = o, e[14] = u} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15]; return e}, c.invert = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = t[6], f = t[7], l = t[8], c = t[9], h = t[10], p = t[11], d = t[12], v = t[13], m = t[14], g = t[15], y = n * u - r * o, b = n * a - i * o, w = n * f - s * o, E = r * a - i * u, S = r * f - s * u, x = i * f - s * a, T = l * v - c * d, N = l * m - h * d, C = l * g - p * d, k = c * m - h * v, L = c * g - p * v, A = h * g - p * m, O = y * A - b * L + w * k + E * C - S * N + x * T; return O?(O = 1 / O, e[0] = (u * A - a * L + f * k) * O, e[1] = (i * L - r * A - s * k) * O, e[2] = (v * x - m * S + g * E) * O, e[3] = (h * S - c * x - p * E) * O, e[4] = (a * C - o * A - f * N) * O, e[5] = (n * A - i * C + s * N) * O, e[6] = (m * w - d * x - g * b) * O, e[7] = (l * x - h * w + p * b) * O, e[8] = (o * L - u * C + f * T) * O, e[9] = (r * C - n * L - s * T) * O, e[10] = (d * S - v * w + g * y) * O, e[11] = (c * w - l * S - p * y) * O, e[12] = (u * N - o * k - a * T) * O, e[13] = (n * k - r * N + i * T) * O, e[14] = (v * b - d * E - m * y) * O, e[15] = (l * E - c * b + h * y) * O, e):null}, c.adjoint = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5], a = t[6], f = t[7], l = t[8], c = t[9], h = t[10], p = t[11], d = t[12], v = t[13], m = t[14], g = t[15]; return e[0] = u * (h * g - p * m) - c * (a * g - f * m) + v * (a * p - f * h), e[1] = - (r * (h * g - p * m) - c * (i * g - s * m) + v * (i * p - s * h)), e[2] = r * (a * g - f * m) - u * (i * g - s * m) + v * (i * f - s * a), e[3] = - (r * (a * p - f * h) - u * (i * p - s * h) + c * (i * f - s * a)), e[4] = - (o * (h * g - p * m) - l * (a * g - f * m) + d * (a * p - f * h)), e[5] = n * (h * g - p * m) - l * (i * g - s * m) + d * (i * p - s * h), e[6] = - (n * (a * g - f * m) - o * (i * g - s * m) + d * (i * f - s * a)), e[7] = n * (a * p - f * h) - o * (i * p - s * h) + l * (i * f - s * a), e[8] = o * (c * g - p * v) - l * (u * g - f * v) + d * (u * p - f * c), e[9] = - (n * (c * g - p * v) - l * (r * g - s * v) + d * (r * p - s * c)), e[10] = n * (u * g - f * v) - o * (r * g - s * v) + d * (r * f - s * u), e[11] = - (n * (u * p - f * c) - o * (r * p - s * c) + l * (r * f - s * u)), e[12] = - (o * (c * m - h * v) - l * (u * m - a * v) + d * (u * h - a * c)), e[13] = n * (c * m - h * v) - l * (r * m - i * v) + d * (r * h - i * c), e[14] = - (n * (u * m - a * v) - o * (r * m - i * v) + d * (r * a - i * u)), e[15] = n * (u * h - a * c) - o * (r * h - i * c) + l * (r * a - i * u), e}, c.determinant = function(e){var t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], o = e[5], u = e[6], a = e[7], f = e[8], l = e[9], c = e[10], h = e[11], p = e[12], d = e[13], v = e[14], m = e[15], g = t * o - n * s, y = t * u - r * s, b = t * a - i * s, w = n * u - r * o, E = n * a - i * o, S = r * a - i * u, x = f * d - l * p, T = f * v - c * p, N = f * m - h * p, C = l * v - c * d, k = l * m - h * d, L = c * m - h * v; return g * L - y * k + b * C + w * N - E * T + S * x}, c.multiply = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = t[4], a = t[5], f = t[6], l = t[7], c = t[8], h = t[9], p = t[10], d = t[11], v = t[12], m = t[13], g = t[14], y = t[15], b = n[0], w = n[1], E = n[2], S = n[3]; return e[0] = b * r + w * u + E * c + S * v, e[1] = b * i + w * a + E * h + S * m, e[2] = b * s + w * f + E * p + S * g, e[3] = b * o + w * l + E * d + S * y, b = n[4], w = n[5], E = n[6], S = n[7], e[4] = b * r + w * u + E * c + S * v, e[5] = b * i + w * a + E * h + S * m, e[6] = b * s + w * f + E * p + S * g, e[7] = b * o + w * l + E * d + S * y, b = n[8], w = n[9], E = n[10], S = n[11], e[8] = b * r + w * u + E * c + S * v, e[9] = b * i + w * a + E * h + S * m, e[10] = b * s + w * f + E * p + S * g, e[11] = b * o + w * l + E * d + S * y, b = n[12], w = n[13], E = n[14], S = n[15], e[12] = b * r + w * u + E * c + S * v, e[13] = b * i + w * a + E * h + S * m, e[14] = b * s + w * f + E * p + S * g, e[15] = b * o + w * l + E * d + S * y, e}, c.mul = c.multiply, c.translate = function(e, t, n){var r = n[0], i = n[1], s = n[2], o, u, a, f, l, c, h, p, d, v, m, g; return t === e?(e[12] = t[0] * r + t[4] * i + t[8] * s + t[12], e[13] = t[1] * r + t[5] * i + t[9] * s + t[13], e[14] = t[2] * r + t[6] * i + t[10] * s + t[14], e[15] = t[3] * r + t[7] * i + t[11] * s + t[15]):(o = t[0], u = t[1], a = t[2], f = t[3], l = t[4], c = t[5], h = t[6], p = t[7], d = t[8], v = t[9], m = t[10], g = t[11], e[0] = o, e[1] = u, e[2] = a, e[3] = f, e[4] = l, e[5] = c, e[6] = h, e[7] = p, e[8] = d, e[9] = v, e[10] = m, e[11] = g, e[12] = o * r + l * i + d * s + t[12], e[13] = u * r + c * i + v * s + t[13], e[14] = a * r + h * i + m * s + t[14], e[15] = f * r + p * i + g * s + t[15]), e}, c.scale = function(e, t, n){var r = n[0], i = n[1], s = n[2]; return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e}, c.rotate = function(e, n, r, i){var s = i[0], o = i[1], u = i[2], a = Math.sqrt(s * s + o * o + u * u), f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _; return Math.abs(a) < t?null:(a = 1 / a, s *= a, o *= a, u *= a, f = Math.sin(r), l = Math.cos(r), c = 1 - l, h = n[0], p = n[1], d = n[2], v = n[3], m = n[4], g = n[5], y = n[6], b = n[7], w = n[8], E = n[9], S = n[10], x = n[11], T = s * s * c + l, N = o * s * c + u * f, C = u * s * c - o * f, k = s * o * c - u * f, L = o * o * c + l, A = u * o * c + s * f, O = s * u * c + o * f, M = o * u * c - s * f, _ = u * u * c + l, e[0] = h * T + m * N + w * C, e[1] = p * T + g * N + E * C, e[2] = d * T + y * N + S * C, e[3] = v * T + b * N + x * C, e[4] = h * k + m * L + w * A, e[5] = p * k + g * L + E * A, e[6] = d * k + y * L + S * A, e[7] = v * k + b * L + x * A, e[8] = h * O + m * M + w * _, e[9] = p * O + g * M + E * _, e[10] = d * O + y * M + S * _, e[11] = v * O + b * M + x * _, n !== e && (e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e)}, c.rotateX = function(e, t, n){var r = Math.sin(n), i = Math.cos(n), s = t[4], o = t[5], u = t[6], a = t[7], f = t[8], l = t[9], c = t[10], h = t[11]; return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = s * i + f * r, e[5] = o * i + l * r, e[6] = u * i + c * r, e[7] = a * i + h * r, e[8] = f * i - s * r, e[9] = l * i - o * r, e[10] = c * i - u * r, e[11] = h * i - a * r, e}, c.rotateY = function(e, t, n){var r = Math.sin(n), i = Math.cos(n), s = t[0], o = t[1], u = t[2], a = t[3], f = t[8], l = t[9], c = t[10], h = t[11]; return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * i - f * r, e[1] = o * i - l * r, e[2] = u * i - c * r, e[3] = a * i - h * r, e[8] = s * r + f * i, e[9] = o * r + l * i, e[10] = u * r + c * i, e[11] = a * r + h * i, e}, c.rotateZ = function(e, t, n){var r = Math.sin(n), i = Math.cos(n), s = t[0], o = t[1], u = t[2], a = t[3], f = t[4], l = t[5], c = t[6], h = t[7]; return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * i + f * r, e[1] = o * i + l * r, e[2] = u * i + c * r, e[3] = a * i + h * r, e[4] = f * i - s * r, e[5] = l * i - o * r, e[6] = c * i - u * r, e[7] = h * i - a * r, e}, c.fromRotationTranslation = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = r + r, a = i + i, f = s + s, l = r * u, c = r * a, h = r * f, p = i * a, d = i * f, v = s * f, m = o * u, g = o * a, y = o * f; return e[0] = 1 - (p + v), e[1] = c + y, e[2] = h - g, e[3] = 0, e[4] = c - y, e[5] = 1 - (l + v), e[6] = d + m, e[7] = 0, e[8] = h + g, e[9] = d - m, e[10] = 1 - (l + p), e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e}, c.fromQuat = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = n + n, u = r + r, a = i + i, f = n * o, l = n * u, c = n * a, h = r * u, p = r * a, d = i * a, v = s * o, m = s * u, g = s * a; return e[0] = 1 - (h + d), e[1] = l + g, e[2] = c - m, e[3] = 0, e[4] = l - g, e[5] = 1 - (f + d), e[6] = p + v, e[7] = 0, e[8] = c + m, e[9] = p - v, e[10] = 1 - (f + h), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e}, c.frustum = function(e, t, n, r, i, s, o){var u = 1 / (n - t), a = 1 / (i - r), f = 1 / (s - o); return e[0] = s * 2 * u, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s * 2 * a, e[6] = 0, e[7] = 0, e[8] = (n + t) * u, e[9] = (i + r) * a, e[10] = (o + s) * f, e[11] = - 1, e[12] = 0, e[13] = 0, e[14] = o * s * 2 * f, e[15] = 0, e}, c.perspective = function(e, t, n, r, i){var s = 1 / Math.tan(t / 2), o = 1 / (r - i); return e[0] = s / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (i + r) * o, e[11] = - 1, e[12] = 0, e[13] = 0, e[14] = 2 * i * r * o, e[15] = 0, e}, c.ortho = function(e, t, n, r, i, s, o){var u = 1 / (t - n), a = 1 / (r - i), f = 1 / (s - o); return e[0] = - 2 * u, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = - 2 * a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * f, e[11] = 0, e[12] = (t + n) * u, e[13] = (i + r) * a, e[14] = (o + s) * f, e[15] = 1, e}, c.lookAt = function(e, n, r, i){var s, o, u, a, f, l, h, p, d, v, m = n[0], g = n[1], y = n[2], b = i[0], w = i[1], E = i[2], S = r[0], x = r[1], T = r[2]; return Math.abs(m - S) < t && Math.abs(g - x) < t && Math.abs(y - T) < t?c.identity(e):(h = m - S, p = g - x, d = y - T, v = 1 / Math.sqrt(h * h + p * p + d * d), h *= v, p *= v, d *= v, s = w * d - E * p, o = E * h - b * d, u = b * p - w * h, v = Math.sqrt(s * s + o * o + u * u), v?(v = 1 / v, s *= v, o *= v, u *= v):(s = 0, o = 0, u = 0), a = p * u - d * o, f = d * s - h * u, l = h * o - p * s, v = Math.sqrt(a * a + f * f + l * l), v?(v = 1 / v, a *= v, f *= v, l *= v):(a = 0, f = 0, l = 0), e[0] = s, e[1] = a, e[2] = h, e[3] = 0, e[4] = o, e[5] = f, e[6] = p, e[7] = 0, e[8] = u, e[9] = l, e[10] = d, e[11] = 0, e[12] = - (s * m + o * g + u * y), e[13] = - (a * m + f * g + l * y), e[14] = - (h * m + p * g + d * y), e[15] = 1, e)}, c.str = function(e){return"mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"}, typeof e != "undefined" && (e.mat4 = c); var h = {}; h.create = function(){var e = new n(4); return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e}, h.rotationTo = function(){var e = o.create(), t = o.fromValues(1, 0, 0), n = o.fromValues(0, 1, 0); return function(r, i, s){var u = o.dot(i, s); return u < - 0.999999?(o.cross(e, t, i), o.length(e) < 1e-6 && o.cross(e, n, i), o.normalize(e, e), h.setAxisAngle(r, e, Math.PI), r):u > .999999?(r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r):(o.cross(e, i, s), r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = 1 + u, h.normalize(r, r))}}(), h.setAxes = function(){var e = l.create(); return function(t, n, r, i){return e[0] = r[0], e[3] = r[1], e[6] = r[2], e[1] = i[0], e[4] = i[1], e[7] = i[2], e[2] = n[0], e[5] = n[1], e[8] = n[2], h.normalize(t, h.fromMat3(t, e))}}(), h.clone = u.clone, h.fromValues = u.fromValues, h.copy = u.copy, h.set = u.set, h.identity = function(e){return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e}, h.setAxisAngle = function(e, t, n){n *= .5; var r = Math.sin(n); return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = Math.cos(n), e}, h.add = u.add, h.multiply = function(e, t, n){var r = t[0], i = t[1], s = t[2], o = t[3], u = n[0], a = n[1], f = n[2], l = n[3]; return e[0] = r * l + o * u + i * f - s * a, e[1] = i * l + o * a + s * u - r * f, e[2] = s * l + o * f + r * a - i * u, e[3] = o * l - r * u - i * a - s * f, e}, h.mul = h.multiply, h.scale = u.scale, h.rotateX = function(e, t, n){n *= .5; var r = t[0], i = t[1], s = t[2], o = t[3], u = Math.sin(n), a = Math.cos(n); return e[0] = r * a + o * u, e[1] = i * a + s * u, e[2] = s * a - i * u, e[3] = o * a - r * u, e}, h.rotateY = function(e, t, n){n *= .5; var r = t[0], i = t[1], s = t[2], o = t[3], u = Math.sin(n), a = Math.cos(n); return e[0] = r * a - s * u, e[1] = i * a + o * u, e[2] = s * a + r * u, e[3] = o * a - i * u, e}, h.rotateZ = function(e, t, n){n *= .5; var r = t[0], i = t[1], s = t[2], o = t[3], u = Math.sin(n), a = Math.cos(n); return e[0] = r * a + i * u, e[1] = i * a - r * u, e[2] = s * a + o * u, e[3] = o * a - s * u, e}, h.calculateW = function(e, t){var n = t[0], r = t[1], i = t[2]; return e[0] = n, e[1] = r, e[2] = i, e[3] = - Math.sqrt(Math.abs(1 - n * n - r * r - i * i)), e}, h.dot = u.dot, h.lerp = u.lerp, h.slerp = function(e, t, n, r){var i = t[0], s = t[1], o = t[2], u = t[3], a = n[0], f = n[1], l = n[2], c = n[3], h, p, d, v, m; return p = i * a + s * f + o * l + u * c, p < 0 && (p = - p, a = - a, f = - f, l = - l, c = - c), 1 - p > 1e-6?(h = Math.acos(p), d = Math.sin(h), v = Math.sin((1 - r) * h) / d, m = Math.sin(r * h) / d):(v = 1 - r, m = r), e[0] = v * i + m * a, e[1] = v * s + m * f, e[2] = v * o + m * l, e[3] = v * u + m * c, e}, h.invert = function(e, t){var n = t[0], r = t[1], i = t[2], s = t[3], o = n * n + r * r + i * i + s * s, u = o?1 / o:0; return e[0] = - n * u, e[1] = - r * u, e[2] = - i * u, e[3] = s * u, e}, h.conjugate = function(e, t){return e[0] = - t[0], e[1] = - t[1], e[2] = - t[2], e[3] = t[3], e}, h.length = u.length, h.len = h.length, h.squaredLength = u.squaredLength, h.sqrLen = h.squaredLength, h.normalize = u.normalize, h.fromMat3 = function(){var e = typeof Int8Array != "undefined"?new Int8Array([1, 2, 0]):[1, 2, 0]; return function(t, n){var r = n[0] + n[4] + n[8], i; if (r > 0)i = Math.sqrt(r + 1), t[3] = .5 * i, i = .5 / i, t[0] = (n[7] - n[5]) * i, t[1] = (n[2] - n[6]) * i, t[2] = (n[3] - n[1]) * i; else{var s = 0; n[4] > n[0] && (s = 1), n[8] > n[s * 3 + s] && (s = 2); var o = e[s], u = e[o]; i = Math.sqrt(n[s * 3 + s] - n[o * 3 + o] - n[u * 3 + u] + 1), t[s] = .5 * i, i = .5 / i, t[3] = (n[u * 3 + o] - n[o * 3 + u]) * i, t[o] = (n[o * 3 + s] + n[s * 3 + o]) * i, t[u] = (n[u * 3 + s] + n[s * 3 + u]) * i}return t}}(), h.str = function(e){return"quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"}, typeof e != "undefined" && (e.quat = h)}(t.exports)})(this);
        }, {}], 22:[function(require, module, exports){
'use strict';
        if (typeof window === 'undefined') {
new (require('./source/worker.js'))(self);
        } else {
// jshint -W079
var mapboxgl = module.exports = window.mapboxgl = {};
        mapboxgl.Map = require('./ui/map.js');
        mapboxgl.Navigation = require('./ui/control/navigation.js');
        mapboxgl.Attribution = require('./ui/control/attribution.js');
        mapboxgl.Source = require('./source/source');
        mapboxgl.GeoJSONSource = require('./source/geojsonsource');
        mapboxgl.VideoSource = require('./source/videosource');
        mapboxgl.Style = require('./style/style.js');
        mapboxgl.LatLng = require('./geo/latlng.js');
        mapboxgl.LatLngBounds = require('./geo/latlngbounds.js');
        mapboxgl.Point = require('point-geometry');
        mapboxgl.Evented = require('./util/evented.js');
        mapboxgl.util = require('./util/util.js');
        var browser = require('./util/browser.js');
        mapboxgl.util.supported = browser.supported;
        var ajax = require('./util/ajax.js');
        mapboxgl.util.getJSON = ajax.getJSON;
        mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;
        var config = require('./util/config.js');
        mapboxgl.config = config;
        Object.defineProperty(mapboxgl, 'accessToken', {
        get: function() { return config.ACCESS_TOKEN; },
                set: function(token) { config.ACCESS_TOKEN = token; }
        });
        }

}, {"./geo/latlng.js":17, "./geo/latlngbounds.js":18, "./source/geojsonsource":35, "./source/source":39, "./source/videosource":44, "./source/worker.js":45, "./style/style.js":53, "./ui/control/attribution.js":67, "./ui/control/navigation.js":69, "./ui/map.js":74, "./util/ajax.js":76, "./util/browser.js":77, "./util/config.js":80, "./util/evented.js":82, "./util/util.js":87, "point-geometry":99}], 23:[function(require, module, exports){
'use strict';
        var mat3 = require('../lib/glmatrix.js').mat3;
        module.exports = drawBackground;
        function showColor(color) {
        console.log('%c  ', 'background: rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')');
        }

function drawBackground(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {

var color = layerStyle['background-color'];
        var image = layerStyle['background-image'];
        var opacity = layerStyle['background-opacity'];
        var shader;
        if (image) {
// Draw texture fill
var imagePos = imageSprite.getPosition(image, true);
        if (!imagePos) return;
        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
        gl.uniform1f(shader.u_opacity, opacity);
        var transform = painter.transform;
        var size = imagePos.size;
        var center = transform.locationCoordinate(transform.center);
        var scale = 1 / Math.pow(2, transform.zoomFraction);
        var matrix = mat3.create();
        mat3.scale(matrix, matrix, [1 / size[0], 1 / size[1], 1]);
        mat3.translate(matrix, matrix, [
                (center.column * transform.tileSize) % size[0],
                (center.row * transform.tileSize) % size[1],
                0
        ]);
        mat3.rotate(matrix, matrix, - transform.angle);
        mat3.scale(matrix, matrix, [
                scale * transform.width / 2,
                - scale * transform.height / 2,
                1
        ]);
        gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);
        imageSprite.bind(gl, true);
} else {
// Draw filling rectangle.
shader = painter.fillShader;
        gl.switchShader(shader, params.padded || posMatrix);
        gl.uniform4fv(shader.u_color, color);
}

gl.disable(gl.STENCIL_TEST);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.backgroundBuffer);
        gl.vertexAttribPointer(shader.a_pos, painter.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.backgroundBuffer.itemCount);
        gl.enable(gl.STENCIL_TEST);
        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        }

}, {"../lib/glmatrix.js":21}], 24:[function(require, module, exports){
'use strict';
        var textVertices = require('../lib/debugtext.js');
        var browser = require('../util/browser.js');
        module.exports = drawDebug;
        function drawDebug(gl, painter, tile, params) {
        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.switchShader(painter.debugShader, painter.tile.posMatrix, painter.tile.exMatrix);
                // draw bounding rectangle
                gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
                gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
                gl.uniform4f(painter.debugShader.u_color, 1, 0, 0, 1);
                gl.lineWidth(4);
                gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);
                // draw tile coordinate
                var coord = params.z + '/' + params.x + '/' + params.y;
                var vertices = textVertices(coord, 50, 200, 5);
                gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
                gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
                gl.lineWidth(8 * browser.devicePixelRatio);
                gl.uniform4f(painter.debugShader.u_color, 1, 1, 1, 1);
                gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
                gl.lineWidth(2 * browser.devicePixelRatio);
                gl.uniform4f(painter.debugShader.u_color, 0, 0, 0, 1);
                gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
                // Revert blending mode to blend to the back.
                gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
        }

}, {"../lib/debugtext.js":20, "../util/browser.js":77}], 25:[function(require, module, exports){
'use strict';
        var browser = require('../util/browser.js');
        var mat3 = require('../lib/glmatrix.js').mat3;
        module.exports = drawFill;
        function drawFill(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {

        var translatedPosMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['fill-translate'], layerStyle['fill-translate-anchor']);
                var color = layerStyle['fill-color'];
                var vertex, elements, group, count;
                // Draw the stencil mask.

                // We're only drawing to the first seven bits (== support a maximum of
                // 127 overlapping polygons in one place before we get rendering errors).
                gl.stencilMask(0x3F);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
                // increasing the lower 7 bits by one if the triangle is a front-facing
                // triangle. This means that all visible polygons should be in CCW
                // orientation, while all holes (see below) are in CW orientation.
                gl.stencilFunc(gl.NOTEQUAL, 0x80, 0x80);
                // When we do a nonzero fill, we count the number of times a pixel is
                // covered by a counterclockwise polygon, and subtract the number of
                // times it is "uncovered" by a clockwise polygon.
                gl.stencilOpSeparate(gl.FRONT, gl.INCR_WRAP, gl.KEEP, gl.KEEP);
                gl.stencilOpSeparate(gl.BACK, gl.DECR_WRAP, gl.KEEP, gl.KEEP);
                // When drawing a shape, we first draw all shapes to the stencil buffer
                // and incrementing all areas where polygons are
                gl.colorMask(false, false, false, false);
                // Draw the actual triangle fan into the stencil buffer.
                gl.switchShader(painter.fillShader, translatedPosMatrix, painter.tile.exMatrix);
                // Draw all buffers
                vertex = bucket.buffers.fillVertex;
                vertex.bind(gl);
                elements = bucket.buffers.fillElement;
                elements.bind(gl);
                var offset, elementOffset;
                for (var i = 0; i < bucket.elementGroups.groups.length; i++) {
        group = bucket.elementGroups.groups[i];
                offset = group.vertexStartIndex * vertex.itemSize;
                gl.vertexAttribPointer(painter.fillShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);
                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

        // Now that we have the stencil mask in the stencil buffer, we can start
        // writing to the color buffer.
        gl.colorMask(true, true, true, true);
                // From now on, we don't want to update the stencil buffer anymore.
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMask(0x0);
                var strokeColor = layerStyle['fill-outline-color'];
                // Because we're drawing top-to-bottom, and we update the stencil mask
                // below, we have to draw the outline first (!)
                if (layerStyle['fill-antialias'] === true && params.antialiasing && !(layerStyle['fill-image'] && !strokeColor)) {
        gl.switchShader(painter.outlineShader, translatedPosMatrix, painter.tile.exMatrix);
                gl.lineWidth(2 * browser.devicePixelRatio);
                if (strokeColor) {
        // If we defined a different color for the fill outline, we are
        // going to ignore the bits in 0x3F and just care about the global
        // clipping mask.
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        } else {
        // Otherwise, we only want to draw the antialiased parts that are
        // *outside* the current shape. This is important in case the fill
        // or stroke color is translucent. If we wouldn't clip to outside
        // the current shape, some pixels from the outline stroke overlapped
        // the (non-antialiased) fill.
        gl.stencilFunc(gl.EQUAL, 0x80, 0xBF);
        }

        gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);
                // Draw all buffers
                vertex = bucket.buffers.fillVertex;
                elements = bucket.buffers.outlineElement;
                elements.bind(gl);
                for (var k = 0; k < bucket.elementGroups.groups.length; k++) {
        group = bucket.elementGroups.groups[k];
                offset = group.vertexStartIndex * vertex.itemSize;
                gl.vertexAttribPointer(painter.outlineShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);
                count = group.secondElementLength * 2;
                elementOffset = group.secondElementStartIndex * elements.itemSize;
                gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
        }

        var image = layerStyle['fill-image'];
                var opacity = layerStyle['fill-opacity'] || 1;
                var shader;
                if (image) {
        // Draw texture fill
        var imagePos = imageSprite.getPosition(image, true);
                if (!imagePos) return;
                shader = painter.patternShader;
                gl.switchShader(shader, posMatrix);
                gl.uniform1i(shader.u_image, 0);
                gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
                gl.uniform2fv(shader.u_pattern_br, imagePos.br);
                gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
                gl.uniform1f(shader.u_opacity, opacity);
                var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);
                var matrix = mat3.create();
                mat3.scale(matrix, matrix, [
                        1 / (imagePos.size[0] * factor),
                        1 / (imagePos.size[1] * factor),
                        1, 1
                ]);
                gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);
                imageSprite.bind(gl, true);
        } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
                gl.switchShader(shader, params.padded || posMatrix);
                gl.uniform4fv(shader.u_color, color);
        }

        // Only draw regions that we marked
        gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x3F);
                gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
                gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);
                gl.stencilMask(0x00);
                gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        }

}, {"../lib/glmatrix.js":21, "../util/browser.js":77}], 26:[function(require, module, exports){
'use strict';
        var browser = require('../util/browser.js');
        module.exports = function drawLine(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
        // don't draw zero-width lines
        if (layerStyle['line-width'] <= 0) return;
                var antialiasing = 1 / browser.devicePixelRatio;
                var width = layerStyle['line-width'];
                var offset = layerStyle['line-offset'] / 2;
                var blur = layerStyle['line-blur'] + antialiasing;
                var inset = Math.max( - 1, offset - width / 2 - antialiasing / 2) + 1;
                var outset = offset + width / 2 + antialiasing / 2;
                var color = layerStyle['line-color'];
                var ratio = painter.transform.scale / (1 << params.z) / 8;
                var vtxMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['line-translate'], layerStyle['line-translate-anchor']);
                var shader;
                var imagePos = layerStyle['line-image'] && imageSprite.getPosition(layerStyle['line-image']);
                if (imagePos) {
        var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);
                imageSprite.bind(gl, true);
                shader = painter.linepatternShader;
                gl.switchShader(shader, vtxMatrix, painter.tile.exMatrix);
                gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
                gl.uniform1f(shader.u_ratio, ratio);
                gl.uniform1f(shader.u_blur, blur);
                gl.uniform2fv(shader.u_pattern_size, [imagePos.size[0] * factor, imagePos.size[1] ]);
                gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
                gl.uniform2fv(shader.u_pattern_br, imagePos.br);
                gl.uniform1f(shader.u_fade, painter.transform.zoomFraction);
        } else {
        shader = painter.lineShader;
                gl.switchShader(shader, vtxMatrix, painter.tile.exMatrix);
                gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
                gl.uniform1f(shader.u_ratio, ratio);
                gl.uniform1f(shader.u_blur, blur);
                gl.uniform4fv(shader.u_color, color);
                gl.uniform2fv(shader.u_dasharray, layerStyle['line-dasharray']);
        }

        var vertex = bucket.buffers.lineVertex;
                vertex.bind(gl);
                var element = bucket.buffers.lineElement;
                element.bind(gl);
                var groups = bucket.elementGroups.groups;
                for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
                var vtxOffset = group.vertexStartIndex * vertex.itemSize;
                gl.vertexAttribPointer(shader.a_pos, 4, gl.SHORT, false, 8, vtxOffset + 0);
                gl.vertexAttribPointer(shader.a_extrude, 2, gl.BYTE, false, 8, vtxOffset + 6);
                gl.vertexAttribPointer(shader.a_linesofar, 2, gl.SHORT, false, 8, vtxOffset + 4);
                var count = group.elementLength * 3;
                var elementOffset = group.elementStartIndex * element.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

        };
        }, {"../util/browser.js":77}], 27:[function(require, module, exports){
'use strict';
        var TileCoord = require('../source/tilecoord.js');
        var PrerenderedTexture = require('./prerendered.js');
        var mat4 = require('../lib/glmatrix.js').mat4;
        module.exports = drawRaster;
        function drawRaster(gl, painter, bucket, layerStyle, params, style, layer, tile) {

        if (layer && layer.layers) {

        if (!bucket.prerendered) {
        bucket.prerendered = new PrerenderedTexture(gl, bucket.info, painter);
                bucket.prerendered.bindFramebuffer();
                gl.clearStencil(0x80);
                gl.stencilMask(0xFF);
                gl.clear(gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                gl.stencilMask(0x00);
                gl.viewport(0, 0, bucket.prerendered.size, bucket.prerendered.size);
                var buffer = bucket.prerendered.buffer * 4096;
                var matrix = mat4.create();
                mat4.ortho(matrix, - buffer, 4096 + buffer, - 4096 - buffer, buffer, 0, 1);
                mat4.translate(matrix, matrix, [0, - 4096, 0]);
                params.padded = mat4.create();
                mat4.ortho(params.padded, 0, 4096, - 4096, 0, 0, 1);
                mat4.translate(params.padded, params.padded, [0, - 4096, 0]);
                painter.draw(tile, style, layer.layers, params, matrix);
                delete params.padded;
                if (bucket.info['raster-blur'] > 0) {
        bucket.prerendered.blur(painter, bucket.info['raster-blur']);
        }

        bucket.prerendered.unbindFramebuffer();
                gl.viewport(0, 0, painter.width, painter.height);
        }

        }

        var texture = bucket.tile ? bucket.tile : bucket.prerendered;
                gl.disable(gl.STENCIL_TEST);
                var shader = painter.rasterShader;
                gl.switchShader(shader, painter.tile.posMatrix, painter.tile.exMatrix);
                // color parameters
                gl.uniform1f(shader.u_brightness_low, layerStyle['raster-brightness'][0]);
                gl.uniform1f(shader.u_brightness_high, layerStyle['raster-brightness'][1]);
                gl.uniform1f(shader.u_saturation_factor, saturationFactor(layerStyle['raster-saturation']));
                gl.uniform1f(shader.u_contrast_factor, contrastFactor(layerStyle['raster-contrast']));
                gl.uniform3fv(shader.u_spin_weights, spinWeights(layerStyle['raster-hue-rotate']));
                var parentTile, opacities;
                if (layer && layer.layers) {
        parentTile = null;
                opacities = [layerStyle['raster-opacity'], 0];
        } else {
        parentTile = findParent(texture);
                opacities = getOpacities(texture, parentTile);
        }
        var parentScaleBy, parentTL;
                gl.activeTexture(gl.TEXTURE0);
                texture.bind(gl);
                if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
                parentTile.bind(gl);
                var tilePos = TileCoord.fromID(texture.id);
                var parentPos = parentTile && TileCoord.fromID(parentTile.id);
                parentScaleBy = Math.pow(2, parentPos.z - tilePos.z);
                parentTL = [tilePos.x * parentScaleBy % 1, tilePos.y * parentScaleBy % 1];
        } else {
        opacities[1] = 0;
        }

        var bufferScale = bucket.prerendered ? (4096 * (1 + 2 * bucket.prerendered.buffer)) / 4096 : 1;
                // cross-fade parameters
                gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
                gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
                gl.uniform1f(shader.u_buffer_scale, bufferScale);
                gl.uniform1f(shader.u_opacity0, opacities[0]);
                gl.uniform1f(shader.u_opacity1, opacities[1]);
                gl.uniform1i(shader.u_image0, 0);
                gl.uniform1i(shader.u_image1, 1);
                gl.bindBuffer(gl.ARRAY_BUFFER, texture.boundsBuffer || painter.tileExtentBuffer);
                gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, 8, 0);
                gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.enable(gl.STENCIL_TEST);
        }

function findParent(tile) {
var source = tile.source;
        if (!source) return;
        var parentTiles = {};
        source._findLoadedParent(tile.id, source.options.minZoom, parentTiles);
        return source.tiles[Object.keys(parentTiles)[0]];
        }

function clamp(n, min, max) {
return Math.max(min, Math.min(max, n));
        }

function spinWeights(angle) {
angle *= Math.PI / 180;
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        return [
                (2 * c + 1) / 3,
                ( - Math.sqrt(3) * s - c + 1) / 3,
                (Math.sqrt(3) * s - c + 1) / 3
        ];
        }

function contrastFactor(contrast) {
return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
        }

function saturationFactor(saturation) {
return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        - saturation;
        }

function getOpacities(tile, parentTile) {
if (!tile.source) return [1, 0];
        var now = new Date().getTime();
        var fadeDuration = tile.source.map.style.rasterFadeDuration;
        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : - 1;
        var tilePos = TileCoord.fromID(tile.id);
        var parentPos = parentTile && TileCoord.fromID(parentTile.id);
        var idealZ = tile.source._coveringZoomLevel(tile.source._getZoom());
        var parentFurther = parentTile ? Math.abs(parentPos.z - idealZ) > Math.abs(tilePos.z - idealZ) : false;
        var opacity = [];
        if (!parentTile || parentFurther) {
// if no parent or parent is older
opacity[0] = clamp(sinceTile, 0, 1);
        opacity[1] = 1 - opacity[0];
} else {
// parent is younger, zooming out
opacity[0] = clamp(1 - sinceParent, 0, 1);
        opacity[1] = 1 - opacity[0];
}

return opacity;
        }

}, {"../lib/glmatrix.js":21, "../source/tilecoord.js":41, "./prerendered.js":33}], 28:[function(require, module, exports){
'use strict';
        var browser = require('../util/browser.js');
        var mat4 = require('../lib/glmatrix.js').mat4;
        module.exports = drawSymbols;
        function drawSymbols(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
        gl.disable(gl.STENCIL_TEST);
                if (bucket.elementGroups.text.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'text');
        }
        if (bucket.elementGroups.icon.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'icon');
        }
        gl.enable(gl.STENCIL_TEST);
        }

var defaultSizes = {
icon: 1,
        text: 24
        };
        function drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, prefix) {

        posMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle[prefix + '-translate'], layerStyle[prefix + '-translate-anchor']);
                var info = bucket.info;
                var exMatrix = mat4.clone(painter.projectionMatrix);
                var alignedWithMap = info[prefix + '-rotation-alignment'] === 'map';
                var angleOffset = (alignedWithMap ? painter.transform.angle : 0);
                if (angleOffset) {
        mat4.rotateZ(exMatrix, exMatrix, angleOffset);
        }

        // If layerStyle.size > info[prefix + '-max-size'] then labels may collide
        var fontSize = layerStyle[prefix + '-size'] || info[prefix + '-max-size'];
                var fontScale = fontSize / defaultSizes[prefix];
                mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);
                var text = prefix === 'text';
                var sdf = text || bucket.elementGroups.sdfIcons;
                var shader, buffer, texsize;
                if (!text && !imageSprite.loaded())
                return;
                gl.activeTexture(gl.TEXTURE0);
                if (sdf) {
        shader = painter.sdfShader;
        } else {
        shader = painter.iconShader;
        }

        if (text) {
        painter.glyphAtlas.updateTexture(gl);
                buffer = bucket.buffers.glyphVertex;
                texsize = [painter.glyphAtlas.width / 4, painter.glyphAtlas.height / 4];
        } else {
        imageSprite.bind(gl, alignedWithMap || params.rotating || params.zooming || fontScale != 1 || sdf);
                buffer = bucket.buffers.iconVertex;
                texsize = [imageSprite.img.width, imageSprite.img.height];
        }

        gl.switchShader(shader, posMatrix, exMatrix);
                gl.uniform1i(shader.u_texture, 0);
                gl.uniform2fv(shader.u_texsize, texsize);
                buffer.bind(gl);
                var ubyte = gl.UNSIGNED_BYTE;
                var stride = text ? 16 : 20;
                gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, 0);
                gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, 4);
                gl.vertexAttribPointer(shader.a_labelminzoom, 1, ubyte, false, stride, 8);
                gl.vertexAttribPointer(shader.a_minzoom, 1, ubyte, false, stride, 9);
                gl.vertexAttribPointer(shader.a_maxzoom, 1, ubyte, false, stride, 10);
                gl.vertexAttribPointer(shader.a_angle, 1, ubyte, false, stride, 11);
                gl.vertexAttribPointer(shader.a_rangeend, 1, ubyte, false, stride, 12);
                gl.vertexAttribPointer(shader.a_rangestart, 1, ubyte, false, stride, 13);
                if (text) {
        gl.vertexAttribPointer(shader.a_tex, 2, ubyte, false, stride, 14);
        } else {
        gl.vertexAttribPointer(shader.a_tex, 2, gl.SHORT, false, stride, 16);
        }

        // Convert the -pi..pi to an int8 range.
        var angle = Math.round((painter.transform.angle) / Math.PI * 128);
                // adjust min/max zooms for variable font sies
                var zoomAdjust = Math.log(fontSize / info[prefix + '-max-size']) / Math.LN2 || 0;
                var flip = alignedWithMap && info[prefix + '-keep-upright'];
                gl.uniform1f(shader.u_flip, flip ? 1 : 0);
                gl.uniform1f(shader.u_angle, (angle + 256) % 256);
                gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

                var f = painter.frameHistory.getFadeProperties(300);
                gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
                gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
                gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
                gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);
                if (!sdf) gl.uniform1f(shader.u_opacity, layerStyle['icon-opacity']);
                var sdfFontSize = text ? 24 : 1;
                var sdfPx = 8;
                var blurOffset = 1.19;
                var haloOffset = 6;
                if (sdf) {

        gl.uniform1f(shader.u_gamma, 0.105 * sdfFontSize / fontSize / browser.devicePixelRatio);
                gl.uniform4fv(shader.u_color, layerStyle[prefix + '-color']);
                gl.uniform1f(shader.u_buffer, (256 - 64) / 256);
        }

        var begin = bucket.elementGroups[prefix].groups[0].vertexStartIndex,
                len = bucket.elementGroups[prefix].groups[0].vertexLength;
                gl.drawArrays(gl.TRIANGLES, begin, len);
                if (sdf && layerStyle[prefix + '-halo-color']) {
        // Draw halo underneath the text.
        gl.uniform1f(shader.u_gamma, (layerStyle[prefix + '-halo-blur'] * blurOffset / (fontSize / sdfFontSize) / sdfPx) + (0.105 * sdfFontSize / fontSize) / browser.devicePixelRatio);
                gl.uniform4fv(shader.u_color, layerStyle[prefix + '-halo-color']);
                gl.uniform1f(shader.u_buffer, (haloOffset - layerStyle[prefix + '-halo-width'] / (fontSize / sdfFontSize)) / sdfPx);
                gl.drawArrays(gl.TRIANGLES, begin, len);
        }
        }

}, {"../lib/glmatrix.js":21, "../util/browser.js":77}], 29:[function(require, module, exports){
'use strict';
        var browser = require('../util/browser.js');
        var mat4 = require('../lib/glmatrix.js').mat4;
        module.exports = drawVertices;
        function drawVertices(gl, painter, bucket) {
        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.switchShader(painter.dotShader, painter.tile.posMatrix, painter.tile.exMatrix);
                // // Draw debug points.
                gl.uniform1f(painter.dotShader.u_size, 4 * browser.devicePixelRatio);
                gl.uniform1f(painter.dotShader.u_blur, 0.25);
                gl.uniform4fv(painter.dotShader.u_color, [0.25, 0, 0, 0.25]);
                // Draw the actual triangle fan into the stencil buffer.

                var vertex, groups, group, begin, count;
                // Draw all buffers
                if (bucket.info.fill) {
        vertex = bucket.buffers.fillVertex;
                vertex.bind(gl);
                groups = bucket.elementGroups.groups;
                for (var i = 0; i < groups.length; i++) {
        group = groups[i];
                begin = group.vertexStartIndex;
                count = group.vertexLength;
                gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
                gl.drawArrays(gl.POINTS, begin, count);
        }
        }

        var newPosMatrix = mat4.clone(painter.tile.posMatrix);
                mat4.scale(newPosMatrix, newPosMatrix, [0.5, 0.5, 1]);
                gl.switchShader(painter.dotShader, newPosMatrix, painter.tile.exMatrix);
                // Draw all line buffers
                if (bucket.info.line) {
        vertex = bucket.buffers.lineVertex;
                vertex.bind(gl);
                groups = bucket.elementGroups.groups;
                for (var k = 0; k < groups.length; k++) {
        group = groups[k];
                begin = group.vertexStartIndex;
                count = group.vertexLength;
                gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
                gl.drawArrays(gl.POINTS, begin, count);
        }

        }

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
        }

}, {"../lib/glmatrix.js":21, "../util/browser.js":77}], 30:[function(require, module, exports){
'use strict';
        module.exports = FrameHistory;
        function FrameHistory() {
        this.frameHistory = [];
        }

FrameHistory.prototype.getFadeProperties = function(duration) {
if (duration === undefined) duration = 300;
        var currentTime = (new Date()).getTime();
        // Remove frames until only one is outside the duration, or until there are only three
        while (this.frameHistory.length > 3 && this.frameHistory[1].time + duration < currentTime) {
this.frameHistory.shift();
}

if (this.frameHistory[1].time + duration < currentTime) {
this.frameHistory[0].z = this.frameHistory[1].z;
}

var frameLen = this.frameHistory.length;
        if (frameLen < 3) console.warn('there should never be less than three frames in the history');
        // Find the range of zoom levels we want to fade between
        var startingZ = this.frameHistory[0].z,
        lastFrame = this.frameHistory[frameLen - 1],
        endingZ = lastFrame.z,
        lowZ = Math.min(startingZ, endingZ),
        highZ = Math.max(startingZ, endingZ);
        // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
        var zoomDiff = lastFrame.z - this.frameHistory[1].z,
        timeDiff = lastFrame.time - this.frameHistory[1].time;
        var fadedist = zoomDiff / (timeDiff / duration);
        if (isNaN(fadedist)) console.warn('fadedist should never be NaN');
        // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
        // bump is how much farther it would have been if it had continued zooming at the same rate
        var bump = (currentTime - lastFrame.time) / duration * fadedist;
        return {
        fadedist: fadedist,
                minfadezoom: lowZ,
                maxfadezoom: highZ,
                bump: bump
        };
        };
// Record frame history that will be used to calculate fading params
        FrameHistory.prototype.record = function(zoom) {
        var currentTime = (new Date()).getTime();
                // first frame ever
                if (!this.frameHistory.length) {
        this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
        }

        if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
        this.frameHistory.push({
        time: currentTime,
                z: zoom
        });
        }
        };
        }, {}], 31:[function(require, module, exports){
'use strict';
        var shaders = require('./shaders.js');
        exports.extend = function(context) {
        context.getShader = function(name, type) {
        var kind = type == this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
                if (!shaders[name] || !shaders[name][kind]) {
        throw new Error("Could not find shader " + name);
        }

        var shader = this.createShader(type);
                this.shaderSource(shader, shaders[name][kind]);
                this.compileShader(shader);
                if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
        throw new Error(this.getShaderInfoLog(shader));
        }
        return shader;
        };
                context.initializeShader = function(name, attributes, uniforms) {
                var shader = {
                program: this.createProgram(),
                        fragment: this.getShader(name, this.FRAGMENT_SHADER),
                        vertex: this.getShader(name, this.VERTEX_SHADER),
                        attributes: []
                };
                        this.attachShader(shader.program, shader.vertex);
                        this.attachShader(shader.program, shader.fragment);
                        this.linkProgram(shader.program);
                        if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
                console.error(this.getProgramInfoLog(shader.program));
                        alert("Could not initialize shader " + name);
                } else {
                for (var i = 0; i < attributes.length; i++) {
                shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                        shader.attributes.push(shader[attributes[i]]);
                }
                for (var k = 0; k < uniforms.length; k++) {
                shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
                }
                }

                return shader;
                };
                // Switches to a different shader program.
                context.switchShader = function(shader, posMatrix, exMatrix) {
                if (!posMatrix) {
                console.trace('posMatrix does not have required argument');
                }

                if (this.currentShader !== shader) {
                this.useProgram(shader.program);
                        // Disable all attributes from the existing shader that aren't used in
                        // the new shader. Note: attribute indices are *not* program specific!
                        var enabled = this.currentShader ? this.currentShader.attributes : [];
                        var required = shader.attributes;
                        for (var i = 0; i < enabled.length; i++) {
                if (required.indexOf(enabled[i]) < 0) {
                this.disableVertexAttribArray(enabled[i]);
                }
                }

                // Enable all attributes for the new shader.
                for (var j = 0; j < required.length; j++) {
                if (enabled.indexOf(required[j]) < 0) {
                this.enableVertexAttribArray(required[j]);
                }
                }

                this.currentShader = shader;
                }

                // Update the matrices if necessary. Note: This relies on object identity!
                // This means changing the matrix values without the actual matrix object
                // will FAIL to update the matrix properly.
                if (shader.posMatrix !== posMatrix) {
                this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
                        shader.posMatrix = posMatrix;
                }
                if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
                this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
                        shader.exMatrix = exMatrix;
                }
                };
                return context;
        };
        }, {"./shaders.js":34}], 32:[function(require, module, exports){
'use strict';
        var glutil = require('./glutil.js');
        var browser = require('../util/browser.js');
        var GlyphAtlas = require('../symbol/glyphatlas.js');
        var glmatrix = require('../lib/glmatrix.js');
        var FrameHistory = require('./framehistory.js');
        var mat4 = glmatrix.mat4;
        var drawSymbol = require('./drawsymbol.js');
        var drawLine = require('./drawline.js');
        var drawFill = require('./drawfill.js');
        var drawRaster = require('./drawraster.js');
        var drawDebug = require('./drawdebug.js');
        var drawBackground = require('./drawbackground.js');
        var drawVertices = require('./drawvertices.js');
        /*
         * Initialize a new painter object.
         *
         * @param {Canvas} gl an experimental-webgl drawing context
         */
        module.exports = GLPainter;
        function GLPainter(gl, transform) {
        this.gl = glutil.extend(gl);
                this.transform = transform;
                this.reusableTextures = {};
                this.preFbos = {};
                this.tileExtent = 4096;
                this.frameHistory = new FrameHistory();
                this.setup();
        }

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
GLPainter.prototype.resize = function(width, height) {
var gl = this.gl;
        // Initialize projection matrix
        this.projectionMatrix = mat4.create();
        mat4.ortho(this.projectionMatrix, 0, width, height, 0, 0, - 1);
        this.width = width * browser.devicePixelRatio;
        this.height = height * browser.devicePixelRatio;
        gl.viewport(0, 0, this.width, this.height);
        };
        GLPainter.prototype.setup = function() {
        var gl = this.gl;
                gl.verbose = true;
                // We are blending the new pixels *behind* the existing pixels. That way we can
                // draw front-to-back and use then stencil buffer to cull opaque pixels early.
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
                gl.enable(gl.STENCIL_TEST);
                this.glyphAtlas = new GlyphAtlas(1024, 1024);
                // this.glyphAtlas.debug = true;
                this.glyphAtlas.bind(gl);
                // Initialize shaders
                this.debugShader = gl.initializeShader('debug',
                        ['a_pos'],
                        ['u_matrix', 'u_pointsize', 'u_color']);
                this.gaussianShader = gl.initializeShader('gaussian',
                        ['a_pos'],
                        ['u_matrix', 'u_image', 'u_offset']);
                this.rasterShader = gl.initializeShader('raster',
                        ['a_pos', 'a_texture_pos'],
                        ['u_matrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);
                this.lineShader = gl.initializeShader('line',
                        ['a_pos', 'a_extrude', 'a_linesofar'],
                        ['u_matrix', 'u_exmatrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_dasharray', 'u_blur']);
                this.linepatternShader = gl.initializeShader('linepattern',
                        ['a_pos', 'a_extrude', 'a_linesofar'],
                        ['u_matrix', 'u_exmatrix', 'u_linewidth', 'u_ratio', 'u_pattern_size', 'u_pattern_tl', 'u_pattern_br', 'u_point', 'u_blur', 'u_fade']);
                this.dotShader = gl.initializeShader('dot',
                        ['a_pos'],
                        ['u_matrix', 'u_size', 'u_color', 'u_blur']);
                this.sdfShader = gl.initializeShader('sdf',
                        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
                        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_color', 'u_gamma', 'u_buffer', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom']);
                this.iconShader = gl.initializeShader('icon',
                        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
                        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_opacity']);
                this.outlineShader = gl.initializeShader('outline',
                        ['a_pos'],
                        ['u_matrix', 'u_color', 'u_world']
                        );
                this.patternShader = gl.initializeShader('pattern',
                        ['a_pos'],
                        ['u_matrix', 'u_pattern_tl', 'u_pattern_br', 'u_mix', 'u_patternmatrix', 'u_opacity', 'u_image']
                        );
                this.fillShader = gl.initializeShader('fill',
                        ['a_pos'],
                        ['u_matrix', 'u_color']
                        );
                this.identityMatrix = mat4.create();
                // The backgroundBuffer is used when drawing to the full *canvas*
                this.backgroundBuffer = gl.createBuffer();
                this.backgroundBuffer.itemSize = 2;
                this.backgroundBuffer.itemCount = 4;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([ - 1, - 1, 1, - 1, - 1, 1, 1, 1]), gl.STATIC_DRAW);
                // The tileExtentBuffer is used when drawing to a full *tile*
                this.tileExtentBuffer = gl.createBuffer();
                this.tileExtentBuffer.itemSize = 4;
                this.tileExtentBuffer.itemCount = 4;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([
                        // tile coord x, tile coord y, texture coord x, texture coord y
                        0, 0, 0, 0,
                        this.tileExtent, 0, 32767, 0,
                        0, this.tileExtent, 0, 32767,
                        this.tileExtent, this.tileExtent, 32767, 32767
                ]), gl.STATIC_DRAW);
                // The debugBuffer is used to draw tile outlines for debugging
                this.debugBuffer = gl.createBuffer();
                this.debugBuffer.itemSize = 2;
                this.debugBuffer.itemCount = 5;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([0, 0, 4095, 0, 4095, 4095, 0, 4095, 0, 0]), gl.STATIC_DRAW);
                // The debugTextBuffer is used to draw tile IDs for debugging
                this.debugTextBuffer = gl.createBuffer();
                this.debugTextBuffer.itemSize = 2;
        };
        /*
         * Reset the color buffers of the drawing canvas.
         */
        GLPainter.prototype.clearColor = function() {
        var gl = this.gl;
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
        };
        /*
         * Reset the drawing canvas by clearing the stencil buffer so that we can draw
         * new tiles at the same location, while retaining previously drawn pixels.
         */
        GLPainter.prototype.clearStencil = function() {
        var gl = this.gl;
                gl.clearStencil(0x0);
                gl.stencilMask(0xFF);
                gl.clear(gl.STENCIL_BUFFER_BIT);
        };
        GLPainter.prototype.drawClippingMask = function() {
        var gl = this.gl;
                gl.switchShader(this.fillShader, this.tile.posMatrix, this.tile.exMatrix);
                gl.colorMask(false, false, false, false);
                // Clear the entire stencil buffer, except for the 7th bit, which stores
                // the global clipping mask that allows us to avoid drawing in regions of
                // tiles we've already painted in.
                gl.clearStencil(0x0);
                gl.stencilMask(0xBF);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                // The stencil test will fail always, meaning we set all pixels covered
                // by this geometry to 0x80. We use the highest bit 0x80 to mark the regions
                // we want to draw in. All pixels that have this bit *not* set will never be
                // drawn in.
                gl.stencilFunc(gl.EQUAL, 0xC0, 0x40);
                gl.stencilMask(0xC0);
                gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);
                // Draw the clipping mask
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
                gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
                gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                gl.stencilMask(0x00);
                gl.colorMask(true, true, true, true);
        };
        GLPainter.prototype.prepareBuffers = function() {}; // Overridden by headless tests.

        /*
         * Draw a new tile to the context, assuming that the viewport is
         * already correctly set.
         */
        GLPainter.prototype.draw = function glPainterDraw(tile, style, layers, params, matrix) {
        this.tile = tile;
                // false when drawing a group of composited layers
                if (tile && !matrix) {
        // Draw the root clipping mask.
        this.drawClippingMask();
        }

        if (!Array.isArray(layers)) console.warn('Layers is not an array');
                this.frameHistory.record(this.transform.zoom);
                // Draw layers front-to-back.
                // Layers are already in reverse order from style.restructure()
                for (var i = 0, len = layers.length; i < len; i++) {
        this.applyStyle(layers[i], style, tile && tile.buckets, params, tile, matrix);
        }

        if (params.debug) {
        drawDebug(this.gl, this, tile, params);
        }
        };
        GLPainter.prototype.applyStyle = function(layer, style, buckets, params, tile, matrix) {
        var gl = this.gl;
                var layerStyle = style.computed[layer.id];
                if (!layerStyle || layerStyle.hidden) return;
                if (layer.layers && layer.type === 'raster') {
        drawRaster(gl, this, buckets[layer.bucket], layerStyle, params, style, layer, tile);
        } else if (params.background) {
        drawBackground(gl, this, undefined, layerStyle, this.identityMatrix, params, style.sprite);
        } else {

        var bucket = buckets[layer.bucket];
                // There are no vertices yet for this layer.
                if (!bucket || (bucket.hasData && !bucket.hasData())) return;
                var type = bucket.type;
                if (bucket.minZoom && this.transform.zoom < bucket.minZoom) return;
                if (bucket.maxZoom && this.transform.zoom >= bucket.maxZoom) return;
                var draw = type === 'symbol' ? drawSymbol :
                type === 'fill' ? drawFill :
                type === 'line' ? drawLine :
                type === 'raster' ? drawRaster : null;
                if (draw) {
        var useMatrix = matrix || this.tile.posMatrix;
                draw(gl, this, bucket, layerStyle, useMatrix, params, style.sprite);
        } else {
        console.warn('No bucket type specified');
        }

        if (params.vertices && !layer.layers) {
        drawVertices(gl, this, bucket);
        }
        }
        };
// Draws non-opaque areas. This is for debugging purposes.
        GLPainter.prototype.drawStencilBuffer = function() {
        var gl = this.gl;
                gl.switchShader(this.fillShader, this.identityMatrix);
                // Blend to the front, not the back.
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.stencilMask(0x00);
                gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
                // Drw the filling quad where the stencil buffer isn't set.
                gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
                gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
                gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.backgroundBuffer.itemCount);
                // Revert blending mode to blend to the back.
                gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
        };
        GLPainter.prototype.translateMatrix = function(matrix, z, translate, anchor) {
        if (!translate[0] && !translate[1]) return matrix;
                if (anchor === 'viewport') {
        var sin_a = Math.sin( - this.transform.angle);
                var cos_a = Math.cos( - this.transform.angle);
                translate = [
                        translate[0] * cos_a - translate[1] * sin_a,
                        translate[0] * sin_a + translate[1] * cos_a
                ];
        }

        var tilePixelRatio = this.transform.scale / (1 << z) / 8;
                var translation = [
                        translate[0] / tilePixelRatio,
                        translate[1] / tilePixelRatio,
                        0
                ];
                var translatedMatrix = new Float32Array(16);
                mat4.translate(translatedMatrix, matrix, translation);
                return translatedMatrix;
        };
        GLPainter.prototype.saveTexture = function(texture) {
        var textures = this.reusableTextures[texture.size];
                if (!textures) {
        this.reusableTextures[texture.size] = [texture];
        } else {
        textures.push(texture);
        }
        };
        GLPainter.prototype.getTexture = function(size) {
        var textures = this.reusableTextures[size];
                return textures && textures.length > 0 ? textures.pop() : null;
        };
        }, {"../lib/glmatrix.js":21, "../symbol/glyphatlas.js":60, "../util/browser.js":77, "./drawbackground.js":23, "./drawdebug.js":24, "./drawfill.js":25, "./drawline.js":26, "./drawraster.js":27, "./drawsymbol.js":28, "./drawvertices.js":29, "./framehistory.js":30, "./glutil.js":31}], 33:[function(require, module, exports){
'use strict';
        var glmatrix = require('../lib/glmatrix.js');
        var mat4 = glmatrix.mat4;
        module.exports = PrerenderedTexture;
        function PrerenderedTexture(gl, bucket, painter) {
        this.gl = gl;
                this.buffer = bucket['raster-buffer'] || (1 / 32);
                this.size = (bucket['raster-size'] || 512) * (1 + 2 * this.buffer);
                this.painter = painter;
                this.texture = null;
                this.fbo = null;
                this.fbos = this.painter.preFbos[this.size];
        }

PrerenderedTexture.prototype.bindFramebuffer = function() {
var gl = this.gl;
        // try to reuse available raster textures
        this.texture = this.painter.getTexture(this.size);
        if (!this.texture) {
this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.texture.size = this.size;
} else {
gl.bindTexture(gl.TEXTURE_2D, this.texture);
}

if (!this.fbos) {
this.fbo = gl.createFramebuffer();
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, this.size, this.size);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
} else {
this.fbo = this.fbos.pop();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
}
};
        PrerenderedTexture.prototype.unbindFramebuffer = function() {
        var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                if (this.fbos) this.fbos.push(this.fbo); else this.painter.preFbos[this.size] = [this.fbo];
        };
        PrerenderedTexture.prototype.bind = function() {
        if (!this.texture) throw('pre-rendered texture does not exist');
                var gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
        };
        PrerenderedTexture.prototype.blur = function(painter, passes) {
        var gl = this.gl;
                var originalTexture = this.texture;
                var secondaryTexture = this.painter.getTexture(this.size);
                if (!secondaryTexture) {
        secondaryTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                secondaryTexture.size = this.size;
        } else {
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
                var matrix = mat4.create();
                mat4.ortho(matrix, 0, 4096, - 4096, 0, 0, 1);
                mat4.translate(matrix, matrix, [0, - 4096, 0]);
                gl.switchShader(painter.gaussianShader, matrix);
                gl.activeTexture(gl.TEXTURE0);
                gl.uniform1i(painter.gaussianShader.u_image, 0);
                for (var i = 0; i < passes; i++) {

        // Render horizontal
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, secondaryTexture, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.uniform2fv(painter.gaussianShader.u_offset, [1 / this.size, 0]);
                gl.bindTexture(gl.TEXTURE_2D, originalTexture);
                gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
                gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                // Render vertical
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, originalTexture, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.uniform2fv(painter.gaussianShader.u_offset, [0, 1 / this.size]);
                gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
                gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
                gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        this.painter.saveTexture(secondaryTexture);
        };
        }, {"../lib/glmatrix.js":21}], 34:[function(require, module, exports){
'use strict';
        var glify = undefined;
        module.exports = {
        "debug": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform float u_pointsize;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = a_pos;\n  tmpvar_1.z = float((a_pos.x >= 32767.0));\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_pointsize;\n}\n\n", "fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
                "dot": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform float u_size;\nattribute vec2 a_pos;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_size;\n}\n\n", "fragment":"precision mediump float;\nuniform vec4 u_color;\nuniform float u_blur;\nvoid main ()\n{\n  mediump vec2 x_1;\n  x_1 = (gl_PointCoord - 0.5);\n  mediump float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 0.5) / (\n    (0.5 - u_blur)\n   - 0.5)), 0.0, 1.0);\n  gl_FragColor = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n}\n\n"},
                "fill": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = 2.0;\n}\n\n", "fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
                "gaussian": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_offset;\nvarying highp vec2 a[3];\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((tmpvar_2.xy / 2.0) + 0.5);\n  a[0] = tmpvar_3;\n  vec2 cse_4;\n  cse_4 = (u_offset * 1.18243);\n  a[1] = (tmpvar_3 + cse_4);\n  a[2] = (tmpvar_3 - cse_4);\n}\n\n", "fragment":"precision mediump float;\nuniform sampler2D u_image;\nvarying vec2 a[3];\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (((texture2D (u_image, a[0]) * 0.40262) + (texture2D (u_image, a[1]) * 0.29869)) + (texture2D (u_image, a[2]) * 0.29869));\n  gl_FragColor = tmpvar_1;\n}\n\n"},
                "line": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 0.0);\n  tmpvar_3.xy = ((u_linewidth.x * a_extrude) * 0.015873);\n  vec4 tmpvar_4;\n  tmpvar_4.zw = vec2(0.0, 1.0);\n  tmpvar_4.xy = floor((a_pos * 0.5));\n  gl_Position = ((u_matrix * tmpvar_4) + (u_exmatrix * tmpvar_3));\n  b = (a_linesofar * u_ratio);\n}\n\n", "fragment":"precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec2 u_dasharray;\nuniform vec4 u_color;\nuniform float u_blur;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  float tmpvar_2;\n  tmpvar_2 = (float(mod (b, (u_dasharray.x + u_dasharray.y))));\n  gl_FragColor = (u_color * (clamp (\n    (min ((tmpvar_1 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_1)) / u_blur)\n  , 0.0, 1.0) * max (\n    float((-(u_dasharray.y) >= 0.0))\n  , \n    clamp (min (tmpvar_2, (u_dasharray.x - tmpvar_2)), 0.0, 1.0)\n  )));\n}\n\n"},
                "linepattern": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_point;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 1.0);\n  tmpvar_3.xy = floor((a_pos / 2.0));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 0.0;\n  tmpvar_4.xy = ((u_linewidth.x * (a_extrude / 63.0)) * (1.0 - u_point));\n  tmpvar_4.z = (float((a_pos.x >= 32767.0)) + (u_point * float(\n    (c_1.y >= 1.0)\n  )));\n  gl_Position = ((u_matrix * tmpvar_3) + (u_exmatrix * tmpvar_4));\n  b = a_linesofar;\n  gl_PointSize = ((2.0 * u_linewidth.x) - 1.0);\n}\n\n", "fragment":"precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec2 u_pattern_size;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform float u_point;\nuniform float u_blur;\nuniform float u_fade;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 j_1;\n  mediump vec2 x_2;\n  x_2 = ((gl_PointCoord * 2.0) - 1.0);\n  mediump float tmpvar_3;\n  tmpvar_3 = (((\n    sqrt(dot (a, a))\n   * \n    (1.0 - u_point)\n  ) + (u_point * \n    sqrt(dot (x_2, x_2))\n  )) * u_linewidth.x);\n  float tmpvar_4;\n  tmpvar_4 = (float(mod ((b / u_pattern_size.x), 1.0)));\n  float tmpvar_5;\n  tmpvar_5 = (0.5 + ((a.y * u_linewidth.x) / u_pattern_size.y));\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_4;\n  tmpvar_6.y = tmpvar_5;\n  vec2 tmpvar_7;\n  tmpvar_7.x = (float(mod ((tmpvar_4 * 2.0), 1.0)));\n  tmpvar_7.y = tmpvar_5;\n  lowp vec4 tmpvar_8;\n  tmpvar_8 = ((texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_6)) * (1.0 - u_fade)) + (u_fade * texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_7))));\n  j_1.w = tmpvar_8.w;\n  j_1.xyz = (tmpvar_8.xyz * tmpvar_8.w);\n  gl_FragColor = (j_1 * clamp ((\n    min ((tmpvar_3 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_3))\n   / u_blur), 0.0, 1.0));\n}\n\n"},
                "outline": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_world;\nvarying highp vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  a = (((tmpvar_2.xy + 1.0) / 2.0) * u_world);\n}\n\n", "fragment":"precision mediump float;\nuniform vec4 u_color;\nvarying vec2 a;\nvoid main ()\n{\n  highp vec2 x_1;\n  x_1 = (a - gl_FragCoord.xy);\n  highp float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 1.0) / -1.0), 0.0, 1.0);\n  highp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n  gl_FragColor = tmpvar_3;\n}\n\n"},
                "pattern": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform mat3 u_patternmatrix;\nattribute vec2 a_pos;\nvarying vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec3 tmpvar_2;\n  tmpvar_2.z = 1.0;\n  tmpvar_2.xy = a_pos;\n  a = (u_patternmatrix * tmpvar_2).xy;\n}\n\n", "fragment":"precision mediump float;\nuniform float u_opacity;\nuniform float u_mix;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform sampler2D u_image;\nvarying vec2 a;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1 = (vec2(mod (a, 1.0)));\n  lowp vec4 tmpvar_2;\n  tmpvar_2 = (mix (texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_1)), texture2D (u_image, mix (u_pattern_tl, u_pattern_br, \n    (vec2(mod ((tmpvar_1 * 2.0), 1.0)))\n  )), u_mix) * u_opacity);\n  gl_FragColor = tmpvar_2;\n}\n\n"},
                "raster": {"vertex":"precision mediump float;\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec2 tmpvar_2;\n  tmpvar_2 = (((\n    (a_texture_pos / 32767.0)\n   - 0.5) / u_buffer_scale) + 0.5);\n  a = tmpvar_2;\n  b = ((tmpvar_2 * u_scale_parent) + u_tl_parent);\n}\n\n", "fragment":"precision mediump float;\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 a;\nvarying vec2 b;\nuniform vec3 u_spin_weights;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = ((texture2D (u_image0, a) * u_opacity0) + (texture2D (u_image1, b) * u_opacity1));\n  lowp vec3 tmpvar_2;\n  tmpvar_2.x = dot (tmpvar_1.xyz, u_spin_weights);\n  tmpvar_2.y = dot (tmpvar_1.xyz, u_spin_weights.zxy);\n  tmpvar_2.z = dot (tmpvar_1.xyz, u_spin_weights.yzx);\n  lowp vec4 tmpvar_3;\n  tmpvar_3.xyz = mix (vec3(u_brightness_low), vec3(u_brightness_high), ((\n    ((tmpvar_2 + ((\n      (((tmpvar_1.x + tmpvar_1.y) + tmpvar_1.z) / 3.0)\n     - tmpvar_2) * u_saturation_factor)) - 0.5)\n   * u_contrast_factor) + 0.5));\n  tmpvar_3.w = tmpvar_1.w;\n  gl_FragColor = tmpvar_3;\n}\n\n"},
                "icon": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_opacity;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float d_1;\n  d_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    d_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + d_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_matrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n  b = (b * u_opacity);\n}\n\n", "fragment":"precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (texture2D (u_texture, a) * b);\n  gl_FragColor = tmpvar_1;\n}\n\n"},
                "sdf": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float c_1;\n  c_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    c_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + c_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_matrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n}\n\n", "fragment":"precision mediump float;\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float edge0_1;\n  edge0_1 = (u_buffer - u_gamma);\n  lowp float tmpvar_2;\n  tmpvar_2 = clamp (((texture2D (u_texture, a).w - edge0_1) / (\n    (u_buffer + u_gamma)\n   - edge0_1)), 0.0, 1.0);\n  lowp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * ((tmpvar_2 * \n    (tmpvar_2 * (3.0 - (2.0 * tmpvar_2)))\n  ) * b));\n  gl_FragColor = tmpvar_3;\n}\n\n"}
        };
        }, {}], 35:[function(require, module, exports){
'use strict';
        var Source = require('./source.js');
        var GeoJSONTile = require('./geojsontile.js');
        var GeoJSONSource = module.exports = function(options) {
        this.tiles = {};
                this.alltiles = {};
                this.enabled = true;
                this.zooms = [1, 5, 9, 13];
                this.minTileZoom = this.zooms[0];
                this.maxTileZoom = this.zooms[this.zooms.length - 1];
                this.loadNewTiles = true;
                this.tileJSON = {
                minZoom: 1,
                        maxZoom: 13
                };
                this.data = options.data;
        };
        GeoJSONSource.prototype = Object.create(Source.prototype);
        GeoJSONSource.prototype.setData = function(data) {
        this.data = data;
                if (this.map) this._updateData();
                return this;
        };
        GeoJSONSource.prototype.onAdd = function(map) {
        this.map = map;
                this.painter = map.painter;
                if (this.map.style) this._updateData();
                map.on('style.change', this._updateData.bind(this));
        };
        GeoJSONSource.prototype._updateData = function() {
        var source = this;
                this.workerID = this.map.dispatcher.send('parse geojson', {
                data: this.data,
                        zooms: this.zooms,
                        tileSize: 512,
                        source: this.id
                }, function(err, tiles) {
                if (err) return;
                        for (var i = 0; i < tiles.length; i++) {
                source.alltiles[tiles[i].id] = new GeoJSONTile(tiles[i].id, source, tiles[i]);
                }
                if (source.map) source.map.update();
                });
                return this;
        };
        GeoJSONSource.prototype._addTile = function(id) {
        var tile = this.alltiles[id];
                if (tile) {
        tile._load();
                this.tiles[id] = tile;
                this.fire('tile.add', {tile: tile});
        }
        return tile || {};
        };
        GeoJSONSource.prototype._coveringZoomLevel = function(zoom) {
        for (var i = this.zooms.length - 1; i >= 0; i--) {
        if (this.zooms[i] <= zoom) {
        var z = this.zooms[i];
                return z;
        }
        }
        return 0;
        };
        }, {"./geojsontile.js":36, "./source.js":39}], 36:[function(require, module, exports){
'use strict';
        var Tile = require('./tile.js');
        var BufferSet = require('../data/buffer/bufferset.js');
        var createBucket = require('../data/createbucket.js');
        module.exports = GeoJSONTile;
        function GeoJSONTile(id, source, data) {
        this.id = id;
                this.source = source;
                this.data = data;
                this.workerID = source.workerID;
        }

GeoJSONTile.prototype = Object.create(Tile.prototype);
        GeoJSONTile.prototype._load = function() {
        if (this.loaded) return;
                this.loaded = true;
                var data = this.data;
                this.buffers = new BufferSet(data.buffers);
                this.buckets = {};
                for (var b in data.elementGroups) {
        this.buckets[b] = createBucket(this.source.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
        }


        };
// noops
        GeoJSONTile.prototype.abort = function() { };
        GeoJSONTile.prototype.remove = function() { };
        }, {"../data/buffer/bufferset.js":2, "../data/createbucket.js":10, "./tile.js":40}], 37:[function(require, module, exports){
'use strict';
        module.exports = Wrapper;
// conform to vectortile api
        function Wrapper(features) {
        this.features = features;
                this.length = features.length;
        }

Wrapper.prototype.feature = function(i) {
return new FeatureWrapper(this.features[i]);
        };
        var mapping = {
        'Point': 1,
                'LineString': 2,
                'Polygon': 3
        };
        function FeatureWrapper(feature) {
        this.feature = feature;
                this.type = mapping[feature.type];
                this.properties = feature.properties;
        }

FeatureWrapper.prototype.loadGeometry = function() {
return this.feature.coords;
        };
        FeatureWrapper.prototype.bbox = function() {

        if (this.type === mapping.Point) {
        return [
                this.feature.coords[0][0].x,
                this.feature.coords[0][0].y,
                this.feature.coords[0][0].x,
                this.feature.coords[0][0].y
        ];
        }

        var rings = this.feature.coords;
                var x1 = Infinity,
                x2 = - Infinity,
                y1 = Infinity,
                y2 = - Infinity;
                for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
                for (var j = 0; j < ring.length; j++) {
        var coord = ring[j];
                x1 = Math.min(x1, coord.x);
                x2 = Math.max(x2, coord.x);
                y1 = Math.min(y1, coord.y);
                y2 = Math.max(y2, coord.y);
        }
        }

        return [x1, y1, x2, y2];
        };
        }, {}], 38:[function(require, module, exports){
'use strict';
        var Tile = require('./tile.js');
        var ajax = require('../util/ajax.js');
        module.exports = RasterTile;
        function RasterTile(id, source, url, callback) {
        this.id = id;
                this.loaded = false;
                this.url = url;
                this.source = source;
                this.map = source.map;
                this._load();
                this.callback = callback;
                this.uses = 1;
                // Todo finish figuring out what raster buckets are
                this.buckets = {};
                this.info = { raster: true };
                var buckets = this.map.style.buckets;
                for (var b in buckets) {
        var bucket = buckets[b];
                var sourceid = bucket && bucket.source;
                if (source.id === sourceid) {
        this.buckets[b] = {
        info: bucket.render,
                type: 'raster',
                tile: this
        };
        }
        }
        }

RasterTile.prototype = Object.create(Tile.prototype);
        RasterTile.prototype._load = function() {
        var tile = this;
                ajax.getImage(this.url, function(err, img) {
                // @TODO handle errors.
                if (err) return;
                        tile.img = img;
                        if (tile.map) tile.onTileLoad();
                });
        };
        RasterTile.prototype.onTileLoad = function() {
        // start texture upload
        this.bind(this.map.painter.gl);
                this.loaded = true;
                this.callback();
        };
        RasterTile.prototype.abort = function() {
        this.aborted = true;
                if (this.img) this.img.src = '';
                delete this.img;
        };
        RasterTile.prototype.bind = function(gl) {
        if (!this.texture) {
        // try to find reusable texture
        this.texture = this.map.painter.getTexture(this.img.width);
                if (this.texture) {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
        } else {
        this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
                this.texture.size = this.img.width;
        }
        gl.generateMipmap(gl.TEXTURE_2D);
        } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
        };
        RasterTile.prototype.remove = function() {
        if (this.texture) this.map.painter.saveTexture(this.texture);
                delete this.map;
        };
        RasterTile.prototype.featuresAt = function(pos, params, callback) {
        // noop
        callback(null, []);
        };
        }, {"../util/ajax.js":76, "./tile.js":40}], 39:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js'),
        ajax = require('../util/ajax.js'),
        normalizeURL = require('../util/mapbox.js').normalizeSourceURL,
        Evented = require('../util/evented.js'),
        Cache = require('../util/mrucache.js'),
        TileCoord = require('./tilecoord'),
        VectorTile = require('./vectortile'),
        RasterTile = require('./rastertile.js'),
        Point = require('point-geometry');
        module.exports = Source;
        function Source(options) {
        this.tiles = {};
                this.enabled = false;
                this.type = options.type;
                if (this.type === 'vector' && options.tileSize && options.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
        }
        this.Tile = this.type === 'vector' ? VectorTile : RasterTile;
                this.options = util.inherit(this.options, options);
                this.cache = new Cache(this.options.cacheSize, function(tile) {
                tile.remove();
                });
                var loaded = function(err, tileJSON) {
                if (err) throw err;
                        if (!tileJSON.tiles)
                        throw new Error('missing tiles property');
                        this.tileJSON = util.extend({ minzoom: 0, maxzoom: 22 }, tileJSON);
                        this.loadNewTiles = true;
                        this.enabled = true;
                        this.update();
                        if (this.map) this.map.fire('source.add', {source: this});
                }.bind(this);
                if (options.url) {
        ajax.getJSON(normalizeURL(options.url), loaded);
        } else {
        loaded(null, options);
        }

        this._updateTiles = util.throttle(this._updateTiles, 50, this);
        }

Source.prototype = util.inherit(Evented, {
options: {
tileSize: 512,
        cacheSize: 20
},
        onAdd: function(map) {
        this.map = map;
                this.painter = map.painter;
        },
        load: function() {
        for (var t in this.tiles) {
        this.tiles[t]._load();
        }
        },
        loaded: function() {
        for (var t in this.tiles) {
        if (!this.tiles[t].loaded)
                return false;
        }
        return true;
        },
        update: function() {
        if (!this.enabled) return;
                this._updateTiles();
        },
        render: function(layers) {
        // Iteratively paint every tile.
        if (!this.enabled) return;
                var order = Object.keys(this.tiles);
                order.sort(this._z_order);
                for (var i = 0; i < order.length; i++) {
        var id = order[i];
                var tile = this.tiles[id];
                if (tile.loaded && !this.coveredTiles[id]) {
        this._renderTile(tile, id, layers);
        }
        }
        },
        featuresAt: function(point, params, callback) {
        point = Point.convert(point);
                if (params.layer) {
        var style = this.map.style,
                layer = style.getLayer(params.layer);
                params.bucket = style.buckets[layer.ref || layer.id];
        }

        var order = Object.keys(this.tiles);
                order.sort(this._z_order);
                for (var i = 0; i < order.length; i++) {
        var id = order[i];
                var tile = this.tiles[id];
                var pos = tile.positionAt(id, point);
                if (pos && pos.x >= 0 && pos.x < 4096 && pos.y >= 0 && pos.y < 4096) {
        // The click is within the viewport. There is only ever one tile in
        // a layer that has this property.
        return tile.featuresAt(pos, params, callback);
        }
        }

        callback(null, []);
        },
        // get the zoom level adjusted for the difference in map and source tilesizes
        _getZoom: function() {
        var zOffset = Math.log(this.map.transform.tileSize / this.options.tileSize) / Math.LN2;
                return this.map.transform.zoom + zOffset;
        },
        _coveringZoomLevel: function(zoom) {
        for (var z = this.tileJSON.maxzoom; z >= this.tileJSON.minzoom; z--) {
        if (z <= zoom) {
        if (this.type === 'raster') {
        // allow underscaling by rounding to the nearest zoom level
        if (z < this.tileJSON.maxzoom) {
        z += Math.round(zoom - z);
        }
        }
        return z;
        }
        }
        return 0;
        },
        _childZoomLevel: function(zoom) {
        zoom = Math.max(this.tileJSON.minzoom, zoom + 1);
                return zoom <= this.tileJSON.maxzoom ? zoom : null;
        },
        _getCoveringTiles: function(zoom) {
        if (zoom === undefined) zoom = this._getZoom();
                var z = this._coveringZoomLevel(zoom),
                tiles = 1 << z,
                tr = this.map.transform,
                tileCenter = TileCoord.zoomTo(tr.locationCoordinate(tr.center), z);
                var points = [
                        TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: 0}), z),
                        TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: 0}), z),
                        TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: tr.height}), z),
                        TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: tr.height}), z)
                ], t = {};
                // Divide the screen up in two triangles and scan each of them:
                // +---/
                // | / |
                // /---+
                this._scanTriangle(points[0], points[1], points[2], 0, tiles, scanLine);
                this._scanTriangle(points[2], points[3], points[0], 0, tiles, scanLine);
                return Object.keys(t).sort(fromCenter);
                function fromCenter(a, b) {
                var ad = Math.abs(a.x - tileCenter.column) +
                        Math.abs(a.y - tileCenter.row),
                        bd = Math.abs(b.x - tileCenter.column) +
                        Math.abs(b.y - tileCenter.row);
                        return ad - bd;
                }

        function scanLine(x0, x1, y) {
        var x, wx;
                if (y >= 0 && y <= tiles) {
        for (x = x0; x < x1; x++) {
        wx = (x + tiles) % tiles;
                t[TileCoord.toID(z, wx, y, Math.floor(x / tiles))] = {x: wx, y: y};
        }
        }
        }
        },
        // Given a tile of data, its id, and a style layers, render the tile to the canvas
        _renderTile: function(tile, id, layers) {
        var pos = TileCoord.fromID(id);
                var z = pos.z, x = pos.x, y = pos.y, w = pos.w;
                x += w * (1 << z);
                tile.calculateMatrices(z, x, y, this.map.transform, this.painter);
                this.painter.draw(tile, this.map.style, layers, {
                z: z, x: x, y: y,
                        debug: this.map.debug,
                        antialiasing: this.map.antialiasing,
                        vertices: this.map.vertices,
                        rotating: this.map.rotating,
                        zooming: this.map.zooming
                });
        },
        // Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
        // adds found tiles to retain object; returns true if children completely cover the tile

        _findLoadedChildren: function(id, maxCoveringZoom, retain) {
        var complete = true;
                var z = TileCoord.fromID(id).z;
                var ids = TileCoord.children(id);
                for (var i = 0; i < ids.length; i++) {
        if (this.tiles[ids[i]] && this.tiles[ids[i]].loaded) {
        retain[ids[i]] = true;
        } else {
        complete = false;
                if (z < maxCoveringZoom) {
        // Go further down the hierarchy to find more unloaded children.
        this._findLoadedChildren(ids[i], maxCoveringZoom, retain);
        }
        }
        }
        return complete;
        },
        // Find a loaded parent of the given tile (up to minCoveringZoom);
        // adds the found tile to retain object and returns true if a parent was found

        _findLoadedParent: function(id, minCoveringZoom, retain) {
        for (var z = TileCoord.fromID(id).z; z >= minCoveringZoom; z--) {
        id = TileCoord.parent(id);
                if (this.tiles[id] && this.tiles[id].loaded) {
        retain[id] = true;
                return true;
        }
        }
        return false;
        },
        // Removes tiles that are outside the viewport and adds new tiles that are inside the viewport.
        _updateTiles: function() {
        if (!this.map || !this.map.loadNewTiles || !this.loadNewTiles ||
                !this.map.style || !this.map.style.sources || !this.map.style.sources[this.id]) return;
                var zoom = Math.floor(this._getZoom());
                var required = this._getCoveringTiles().sort(this._centerOut.bind(this));
                var i;
                var id;
                var complete;
                var tile;
                // Determine the overzooming/underzooming amounts.
                var minCoveringZoom = Math.max(this.tileJSON.minzoom, zoom - 10);
                var maxCoveringZoom = this.tileJSON.minzoom;
                while (maxCoveringZoom < zoom + 1) {
        var level = this._childZoomLevel(maxCoveringZoom);
                if (level === null) break;
                else maxCoveringZoom = level;
        }

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
                // Covered is a list of retained tiles who's areas are full covered by other,
                // better, retained tiles. They are not drawn separately.
                this.coveredTiles = {};
                var fullyComplete = true;
                // Add existing child/parent tiles if the actual tile is not yet loaded
                for (i = 0; i < required.length; i++) {
        id = + required[i];
                retain[id] = true;
                tile = this._addTile(id);
                if (!tile.loaded) {
        // The tile we require is not yet loaded. Try to find a parent or
        // child tile that we already have.

        // First, try to find existing child tiles that completely cover the
        // missing tile.
        complete = this._findLoadedChildren(id, maxCoveringZoom, retain);
                // Then, if there are no complete child tiles, try to find existing
                // parent tiles that completely cover the missing tile.
                if (!complete) {
        complete = this._findLoadedParent(id, minCoveringZoom, retain);
        }

        // The unloaded tile's area is not completely covered loaded tiles
        if (!complete) {
        fullyComplete = false;
        }
        }
        }

        var now = new Date().getTime();
                var fadeDuration = this.type === 'raster' ? this.map.style.rasterFadeDuration : 0;
                for (id in retain) {
        tile = this.tiles[id];
                if (tile && tile.timeAdded > now - fadeDuration) {
        // This tile is still fading in. Find tiles to cross-fade with it.

        complete = this._findLoadedChildren(id, maxCoveringZoom, retain);
                if (complete) {
        this.coveredTiles[id] = true;
        } else {
        this._findLoadedParent(id, minCoveringZoom, retain);
        }
        }
        }

        for (id in this.coveredTiles) retain[id] = true;
                // Remove the tiles we don't need anymore.
                var remove = util.keysDifference(this.tiles, retain);
                for (i = 0; i < remove.length; i++) {
        id = + remove[i];
                this._removeTile(id);
        }
        },
        _loadTile: function(id) {
        var layer = this;
                var map = this.map,
                pos = TileCoord.fromID(id),
                tile;
                if (pos.w === 0) {
        // console.time('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
        var url = TileCoord.url(id, this.tileJSON.tiles);
                tile = this.tiles[id] = new this.Tile(id, this, url, tileComplete);
        } else {
        var wrapped = TileCoord.toID(pos.z, pos.x, pos.y, 0);
                tile = this.tiles[id] = this.tiles[wrapped] || this._addTile(wrapped);
                tile.uses++;
        }

        function tileComplete(err) {
        // console.timeEnd('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
        if (err) {
        console.warn('failed to load tile %d/%d/%d: %s', pos.z, pos.x, pos.y, err.stack || err);
        } else {
        layer.fire('tile.load', {tile: tile});
                map.update();
        }
        }

        return tile;
        },
        // Adds a vector tile to the map. It will trigger a rerender of the map and will
        // be part in all future renders of the map. The map object will handle copying
        // the tile data to the GPU if it is required to paint the current viewport.
        _addTile: function(id) {
        var tile = this.tiles[id];
                if (!tile) {
        tile = this.cache.get(id);
                if (tile) {
        tile.uses = 1;
                this.tiles[id] = tile;
        }
        }

        if (!tile) {
        tile = this._loadTile(id);
                this.fire('tile.add', {tile: tile});
        }

        if (tile && tile.loaded && !tile.timeAdded) {
        tile.timeAdded = new Date().getTime();
                if (this.type === 'raster') {
        this.map.animationLoop.set(this.map.style.rasterFadeDuration);
        }
        }

        return tile;
        },
        _removeTile: function(id) {
        var tile = this.tiles[id];
                if (tile) {
        tile.uses--;
                delete this.tiles[id];
                if (tile.uses <= 0) {
        delete tile.timeAdded;
                if (!tile.loaded) {
        tile.abort();
                tile.remove();
        } else {
        this.cache.add(id, tile);
        }

        this.fire('tile.remove', {tile: tile});
        }
        }
        },
        // Taken from polymaps src/Layer.js
        // https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

        // scan-line conversion
        _scanTriangle: function(a, b, c, ymin, ymax, scanLine) {
        var ab = this._edge(a, b),
                bc = this._edge(b, c),
                ca = this._edge(c, a);
                var t;
                // sort edges by y-length
                if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
        if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
        if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

        // scan span! scan span!
        if (ab.dy) this._scanSpans(ca, ab, ymin, ymax, scanLine);
                if (bc.dy) this._scanSpans(ca, bc, ymin, ymax, scanLine);
        },
        // scan-line conversion
        _edge: function(a, b) {
        if (a.row > b.row) { var t = a; a = b; b = t; }
        return {
        x0: a.column,
                y0: a.row,
                x1: b.column,
                y1: b.row,
                dx: b.column - a.column,
                dy: b.row - a.row
        };
        },
        // scan-line conversion
        _scanSpans: function(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0)),
                y1 = Math.min(ymax, Math.ceil(e1.y1));
                // sort edges by x-coordinate
                if ((e0.x0 == e1.x0 && e0.y0 == e1.y0) ?
                        (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
                        (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
        var t = e0; e0 = e1; e1 = t;
        }

        // scan lines!
        var m0 = e0.dx / e0.dy,
                m1 = e1.dx / e1.dy,
                d0 = e0.dx > 0, // use y + 1 to compute x0
                d1 = e1.dx < 0; // use y + 1 to compute x1
                for (var y = y0; y < y1; y++) {
        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0,
                x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
                scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
        },
        _z_order: function(a, b) {
        return (b % 32) - (a % 32);
        },
        _centerOut: function(a, b) {
        var tr = this.map.transform;
                var aPos = TileCoord.fromID(a);
                var bPos = TileCoord.fromID(b);
                var c = TileCoord.zoomTo(tr.locationCoordinate(tr.center), aPos.z);
                var center = new Point(c.column - 0.5, c.row - 0.5);
                return center.dist(aPos) - center.dist(bPos);
        },
        });
        var sources = {
        vector: Source,
                raster: Source,
                geojson: require('./geojsonsource'),
                video: require('./videosource')
        };
        Source.create = function(source) {
        return new sources[source.type](source);
        };
        }, {"../util/ajax.js":76, "../util/evented.js":82, "../util/mapbox.js":84, "../util/mrucache.js":85, "../util/util.js":87, "./geojsonsource":35, "./rastertile.js":38, "./tilecoord":41, "./vectortile":43, "./videosource":44, "point-geometry":99}], 40:[function(require, module, exports){
'use strict';
        var glmatrix = require('../lib/glmatrix.js'),
        mat2 = glmatrix.mat2,
        mat4 = glmatrix.mat4,
        vec2 = glmatrix.vec2;
        module.exports = Tile;
        function Tile() {}

Tile.prototype = {
// todo unhardcode
tileExtent: 4096,
        calculateMatrices: function(z, x, y, transform, painter) {

        // Initialize model-view matrix that converts from the tile coordinates
        // to screen coordinates.
        var tileScale = Math.pow(2, z);
                var scale = transform.worldSize / tileScale;
                // TODO: remove
                this.scale = scale;
                // The position matrix
                this.posMatrix = mat4.create();
                mat4.translate(this.posMatrix, this.posMatrix, [transform.centerPoint.x, transform.centerPoint.y, 0]);
                mat4.rotateZ(this.posMatrix, this.posMatrix, transform.angle);
                mat4.translate(this.posMatrix, this.posMatrix, [ - transform.centerPoint.x, - transform.centerPoint.y, 0]);
                var pixelX = transform.width / 2 - transform.x,
                pixelY = transform.height / 2 - transform.y;
                mat4.translate(this.posMatrix, this.posMatrix, [pixelX + x * scale, pixelY + y * scale, 1]);
                // Create inverted matrix for interaction
                this.invPosMatrix = mat4.create();
                mat4.invert(this.invPosMatrix, this.posMatrix);
                mat4.scale(this.posMatrix, this.posMatrix, [ scale / this.tileExtent, scale / this.tileExtent, 1 ]);
                mat4.multiply(this.posMatrix, painter.projectionMatrix, this.posMatrix);
                // The extrusion matrix.
                this.exMatrix = mat4.clone(painter.projectionMatrix);
                mat4.rotateZ(this.exMatrix, this.exMatrix, transform.angle);
                // 2x2 matrix for rotating points
                this.rotationMatrix = mat2.create();
                mat2.rotate(this.rotationMatrix, this.rotationMatrix, transform.angle);
        },
        positionAt: function(id, point) {
        // tile hasn't finished loading
        if (!this.invPosMatrix) return null;
                var pos = vec2.transformMat4([], [point.x, point.y], this.invPosMatrix);
                vec2.scale(pos, pos, 4096 / this.scale);
                return {
                x: pos[0],
                        y: pos[1],
                        scale: this.scale
                };
        },
        featuresAt: function(pos, params, callback) {
        this.source.map.dispatcher.send('query features', {
        id: this.id,
                x: pos.x,
                y: pos.y,
                scale: pos.scale,
                source: this.source.id,
                params: params
        }, callback, this.workerID);
        }
};
        }, {"../lib/glmatrix.js":21}], 41:[function(require, module, exports){
'use strict';
        /*
         * Tiles are generally represented as packed integer ids constructed by
         * `TileCoord.toID(x, y, z)`
         */

        var TileCoord = exports;
        TileCoord.toID = function(z, x, y, w) {
        w = w || 0;
                w *= 2;
                if (w < 0) w = w * - 1 - 1;
                var dim = 1 << z;
                return ((dim * dim * w + dim * y + x) * 32) + z;
        };
        TileCoord.asString = function(id) {
        var pos = TileCoord.fromID(id);
                return pos.z + "/" + pos.x + "/" + pos.y;
        };
        /*
         * Parse a packed integer id into an object with x, y, and z properties
         */
        TileCoord.fromID = function(id) {
        var z = id % 32, dim = 1 << z;
                var xy = ((id - z) / 32);
                var x = xy % dim, y = ((xy - x) / dim) % dim;
                var w = Math.floor(xy / (dim * dim));
                if (w % 2 !== 0) w = w * - 1 - 1;
                w /= 2;
                return { z: z, x: x, y: y, w: w };
        };
        /*
         * Given a packed integer id, return its zoom level
         */
        TileCoord.zoom = function(id) {
        return id % 32;
        };
// Given an id and a list of urls, choose a url template and return a tile URL
        TileCoord.url = function(id, urls) {
        var pos = TileCoord.fromID(id);
                return urls[(pos.x + pos.y) % urls.length]
                .replace('{h}', (pos.x % 16).toString(16) + (pos.y % 16).toString(16))
                .replace('{z}', pos.z)
                .replace('{x}', pos.x)
                .replace('{y}', pos.y);
        };
        /*
         * Given a packed integer id, return the id of its parent tile
         */
        TileCoord.parent = function(id) {
        var pos = TileCoord.fromID(id);
                if (pos.z === 0) return id;
                else return TileCoord.toID(pos.z - 1, Math.floor(pos.x / 2), Math.floor(pos.y / 2));
        };
        TileCoord.parentWithZoom = function(id, zoom) {
        var pos = TileCoord.fromID(id);
                while (pos.z > zoom) {
        pos.z--;
                pos.x = Math.floor(pos.x / 2);
                pos.y = Math.floor(pos.y / 2);
        }
        return TileCoord.toID(pos.z, pos.x, pos.y);
        };
        /*
         * Given a packed integer id, return an array of integer ids representing
         * its four children.
         */
        TileCoord.children = function(id) {
        var pos = TileCoord.fromID(id);
                pos.z += 1;
                pos.x *= 2;
                pos.y *= 2;
                return [
                        TileCoord.toID(pos.z, pos.x, pos.y, pos.w),
                        TileCoord.toID(pos.z, pos.x + 1, pos.y, pos.w),
                        TileCoord.toID(pos.z, pos.x, pos.y + 1, pos.w),
                        TileCoord.toID(pos.z, pos.x + 1, pos.y + 1, pos.w)
                ];
        };
        TileCoord.zoomTo = function(c, z) {
        c.column = c.column * Math.pow(2, z - c.zoom);
                c.row = c.row * Math.pow(2, z - c.zoom);
                c.zoom = z;
                return c;
        };
        }, {}], 42:[function(require, module, exports){
'use strict';
        var rewind = require('geojson-rewind');
        var TileCoord = require('./tilecoord.js');
        var Transform = require('../geo/transform.js');
        var Point = require('point-geometry');
        var LatLng = require('../geo/latlng.js');
        module.exports = tileGeoJSON;
        function tileGeoJSON(geojson, zoom) {
        var tiles = {};
                var tileExtent = 4096;
                var transform = new Transform();
                transform.zoom = zoom;
                geojson = rewind(geojson);
                if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
        tileFeature(geojson.features[i], transform, tiles, tileExtent);
        }

        } else if (geojson.type === 'Feature') {
        tileFeature(geojson, transform, tiles, tileExtent);
        } else {
        throw('Unrecognized geojson type');
        }

        return tiles;
        }

function tileFeature(feature, transform, tiles, tileExtent) {
var coords = feature.geometry.coordinates;
        var type = feature.geometry.type;
        var tiled;
        if (type === 'Point') {
tiled = tileLineString([coords], transform, tileExtent);
} else if (type === 'LineString' || type === 'MultiPoint') {
tiled = tileLineString(coords, transform, tileExtent);
} else if (type === 'Polygon' || type === 'MultiLineString') {
tiled = {};
        for (var i = 0; i < coords.length; i++) {
var tiled_ = tileLineString(coords[i], transform, tileExtent, type === 'Polygon');
        for (var tileID in tiled_) {
if (!tiled[tileID]) tiled[tileID] = [];
        tiled[tileID] = (tiled[tileID] || []).concat(tiled_[tileID]);
}
}

} else if (type === 'MultiPolygon') {
throw("todo");
} else {
throw("unrecognized geometry type");
}

for (var id in tiled) {
tiles[id] = tiles[id] || [];
        tiles[id].push({
properties: feature.properties,
        coords: tiled[id],
        type: feature.geometry.type
});
}
}

function tileLineString(coords, transform, tileExtent, rejoin) {

var padding = 0.01;
        var paddedExtent = tileExtent * (1 + 2 * padding);
        var coord = transform.locationCoordinate(new LatLng(coords[0][1], coords[0][0]));
        var prevCoord;
        var tiles = {};
        for (var i = 0; i < coords.length; i++) {
prevCoord = coord;
        coord = transform.locationCoordinate(new LatLng(coords[i][1], coords[i][0]));
        var dx = coord.column - prevCoord.column || Number.MIN_VALUE,
        dy = coord.row - prevCoord.row || Number.MIN_VALUE,
        dirX = dx / Math.abs(dx),
        dirY = dy / Math.abs(dy);
        // Find the rectangular bounding box, in tiles, of the polygon
        var startTileX = Math.floor(prevCoord.column - dirX * padding);
        var endTileX = Math.floor(coord.column + dirX * padding);
        var startTileY = Math.floor(prevCoord.row - dirY * padding);
        var endTileY = Math.floor(coord.row + dirY * padding);
        // Iterate over all tiles the segment might intersect
        // and split the segment across those tiles
        for (var x = startTileX; (x - endTileX) * dirX <= 0; x += dirX) {
var leftX = (x - padding - prevCoord.column) / dx;
        var rightX = (x + 1 + padding - prevCoord.column) / dx;
        for (var y = startTileY; (y - endTileY) * dirY <= 0; y += dirY) {
var topY = (y - padding - prevCoord.row) / dy;
        var bottomY = (y + 1 + padding - prevCoord.row) / dy;
        // fraction of the distance along the segment at which the segment
        // enters or exits the tile
        var enter = Math.max(Math.min(leftX, rightX), Math.min(topY, bottomY));
        var exit = Math.min(Math.max(leftX, rightX), Math.max(topY, bottomY));
        var tileID = TileCoord.toID(transform.tileZoom, x, y),
        tile = tiles[tileID],
        point;
        // segments starts outside the tile, add entry point
        if (0 <= enter && enter < 1) {
point = new Point(
        ((prevCoord.column + enter * dx) - x) * tileExtent,
        ((prevCoord.row + enter * dy) - y) * tileExtent);
        point.continues = true;
        if (!tile) tiles[tileID] = tile = [];
        tile.push([point]);
}

// segments ends outside the tile, add exit point
if (0 <= exit && exit < 1) {
point = new Point(
        ((prevCoord.column + exit * dx) - x) * tileExtent,
        ((prevCoord.row + exit * dy) - y) * tileExtent);
        point.continues = true;
        tile[tile.length - 1].push(point);
        // add the point itself
} else {
point = new Point(
        (coord.column - x) * tileExtent,
        (coord.row - y) * tileExtent);
        if (!tile) tiles[tileID] = tile = [[point]];
        else tile[tile.length - 1].push(point);
}
}
}
}

if (rejoin) {
// reassemble the disconnected segments into a linestring
// sections of the linestring outside the tile are replaced with segments
// that follow the tile's edge
for (var id in tiles) {

var segments = tiles[id];
        if (!segments[0][0].continues && segments.length > 1) {
// if the first segment is the beginning of the linestring
// then join it with the last so that all segments start and
// end at tile boundaries
var last = segments.pop();
        Array.prototype.unshift.apply(segments[0], last.slice(0, last.length - 1));
}

var start = edgeDist(segments[0][0], tileExtent, padding);
        for (var k = 0; k < segments.length; k++) {
// Add all tile corners along the path between the current segment's exit point
// and the next segment's entry point

var thisExit = edgeDist(segments[k][segments[k].length - 1], paddedExtent);
        var nextEntry = edgeDist(segments[(k + 1) % segments.length][0], paddedExtent);
        var startToExit = (thisExit - start + 4) % 4;
        var startToNextEntry = (nextEntry - start + 4) % 4;
        var direction = (thisExit === nextEntry || startToExit < startToNextEntry) ? 1 : - 1;
        var roundFn = direction > 0 ? Math.ceil : Math.floor;
        for (var c = roundFn(thisExit) % 4; c != roundFn(nextEntry) % 4; c = (c + direction + 4) % 4) {
var corner = corners[c];
        segments[k].push(new Point(
        (corner.x + (corner.x - 0.5 > 0 ? 1 : - 1) * padding) * tileExtent,
        (corner.y + (corner.y - 0.5 > 0 ? 1 : - 1) * padding) * tileExtent));
}
}

// Join all segments
tiles[id] = [Array.prototype.concat.apply([], segments)];
}
}

return tiles;
        }

var corners = [
        new Point(0, 0),
        new Point(1, 0),
        new Point(1, 1),
        new Point(0, 1)];
        /*
         * Converts to a point to the distance along the edge of the tile (out of 4).
         *
         *         0.5
         *     0 _______ 1
         *      |       |
         *  3.5 |       | 1.5
         *      |       |
         *      |_______|
         *     3   2.5   2
         */
                function edgeDist(point, extent) {
                var x = point.x / extent;
                        var y = point.y / extent;
                        var d;
                        if (Math.abs(y - 0.5) >= Math.abs(x - 0.5)) {
                d = Math.round(y) * 2 + (y < 0.5 ? x : 1 - x);
                } else {
                d = Math.round(1 - x) * 2 + (x > 0.5 ? y : 1 - y) + 1;
                }

                return d % 4;
                }

        }, {"../geo/latlng.js":17, "../geo/transform.js":19, "./tilecoord.js":41, "geojson-rewind":93, "point-geometry":99}], 43:[function(require, module, exports){
'use strict';
        var Tile = require('./tile.js'),
        TileCoord = require('./tilecoord.js'),
        BufferSet = require('../data/buffer/bufferset.js'),
        util = require('../util/util.js');
        var createBucket = require('../data/createbucket.js');
        module.exports = VectorTile;
        function VectorTile(id, source, url, callback) {
        this.id = id;
                this.loaded = false;
                this.url = url;
                this.zoom = TileCoord.fromID(id).z;
                this.map = source.map;
                this.options = source.options;
                this.id = util.uniqueId();
                this.callback = callback;
                this.source = source;
                if (this.zoom >= source.tileJSON.maxzoom) {
        this.depth = this.map.options.maxZoom - this.zoom;
        } else {
        this.depth = 1;
        }
        this.uses = 1;
                this._load();
        }

VectorTile.prototype = util.inherit(Tile, {

_load: function() {
var tile = this;
        this.workerID = this.map.dispatcher.send('load tile', {
        url: this.url,
                id: this.id,
                zoom: this.zoom,
                maxZoom: this.source.tileJSON.maxzoom,
                tileSize: this.options.tileSize,
                source: this.source.id,
                depth: this.depth
        }, function(err, data) {
        if (!err && data) {
        tile.onTileLoad(data);
        }
        tile.callback(err);
        });
},
        onTileLoad: function(data) {

        // Tile has been removed from the map
        if (!this.map) return;
                this.buffers = new BufferSet(data.buffers);
                this.buckets = {};
                for (var b in data.elementGroups) {
        this.buckets[b] = createBucket(this.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
        }

        this.loaded = true;
        },
        remove: function() {

        // reuse prerendered textures
        for (var bucket in this.buckets) {
        if (this.buckets[bucket].prerendered) this.map.painter.saveTexture(this.buckets[bucket].prerendered.texture);
        }

        this.map.dispatcher.send('remove tile', { id: this.id, source: this.source.id }, null, this.workerID);
                this.map.painter.glyphAtlas.removeGlyphs(this.id);
                var gl = this.map.painter.gl;
                var buffers = this.buffers;
                if (buffers) {
        for (var b in buffers) {
        buffers[b].destroy(gl);
        }
        }
        delete this.map;
        },
        abort: function() {
        this.map.dispatcher.send('abort tile', { id: this.id, source: this.source.id }, null, this.workerID);
        }
});
        }, {"../data/buffer/bufferset.js":2, "../data/createbucket.js":10, "../util/util.js":87, "./tile.js":40, "./tilecoord.js":41}], 44:[function(require, module, exports){
'use strict';
        var Tile = require('./tile.js');
        var TileCoord = require('./tilecoord.js');
        var LatLng = require('../geo/latlng.js');
        var Point = require('point-geometry');
        var Source = require('./source.js');
        module.exports = VideoSource;
        function VideoSource(options) {

        this.video = document.createElement('video');
                this.video.crossOrigin = 'Anonymous';
                this.video.loop = true;
                var urls = (typeof options.url === 'string') ? [options.url] : options.url;
                for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
                s.src = urls[i];
                this.video.appendChild(s);
        }

        this.coordinates = options.coordinates;
                this.enabled = true;
                var loopID;
                var source = this;
                // start repainting when video starts playing
                this.video.addEventListener('playing', function() {
                loopID = source.map.style.animationLoop.set(Infinity);
                        source.map._rerender();
                });
                // stop repainting when video stops
                this.video.addEventListener('pause', function() {
                source.map.style.animationLoop.cancel(loopID);
                });
        }

VideoSource.prototype = Object.create(Source.prototype);
        VideoSource.prototype.onAdd = function(map) {
        this.map = map;
                this.video.play();
                this.createTile();
        };
        VideoSource.prototype.createTile = function() {
        /*
         * Calculate which mercator tile is suitable for rendering the video in
         * and create a buffer with the corner coordinates. These coordinates
         * may be outside the tile, because raster tiles aren't clipped when rendering.
         */
        var map = this.map;
                var coords = this.coordinates.map(function(latlng) {
                var loc = LatLng.convert(latlng);
                        return TileCoord.zoomTo(map.transform.locationCoordinate(loc), 0);
                });
                var minX = Infinity;
                var minY = Infinity;
                var maxX = - Infinity;
                var maxY = - Infinity;
                for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
                minY = Math.min(minY, coords[i].row);
                maxX = Math.max(maxX, coords[i].column);
                maxY = Math.max(maxY, coords[i].row);
        }

        var dx = maxX - minX;
                var dy = maxY - minY;
                var dMax = Math.max(dx, dy);
                var center = TileCoord.zoomTo({
                column: (minX + maxX) / 2,
                        row: (minY + maxY) / 2,
                        zoom: 0
                }, Math.floor( - Math.log(dMax) / Math.LN2));
                var tileExtent = 4096;
                var tileCoords = coords.map(function(coord) {
                var zoomedCoord = TileCoord.zoomTo(coord, center.zoom);
                        return new Point(
                                Math.round((zoomedCoord.column - center.column) * tileExtent),
                                Math.round((zoomedCoord.row - center.row) * tileExtent));
                });
                var gl = map.painter.gl;
                var maxInt16 = 32767;
                var array = new Int16Array([
                        tileCoords[0].x, tileCoords[0].y, 0, 0,
                        tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
                        tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
                        tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
                ]);
                this.boundsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.boundsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.tile = new Tile();
                this.center = center;
        };
        VideoSource.prototype.load = function() {
        // noop
        };
        VideoSource.prototype.update = function() {
        // noop
        };
        VideoSource.prototype.render = function(layers) {
        if (!this.enabled) return;
                if (this.video.readyState < 2) return; // not enough data for current position

                var layer = layers[0];
                var bucket = {
                type: 'raster',
                        tile: this,
                        boundsBuffer: this.boundsBuffer,
                        bind: this.bind.bind(this)
                };
                var buckets = {};
                buckets[layer.bucket] = bucket;
                var c = this.center;
                this.tile.calculateMatrices(c.zoom, c.column, c.row, this.map.transform, this.map.painter);
                this.map.painter.tile = this.tile;
                this.map.painter.applyStyle(layer, this.map.style, buckets, {});
        };
        VideoSource.prototype.bind = function(gl) {

        if (!this.texture) {
        this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }

        };
        VideoSource.prototype.featuresAt = function(point, params, callback) {
        // TODO return pixel?
        return callback(null, []);
        };
        }, {"../geo/latlng.js":17, "./source.js":39, "./tile.js":40, "./tilecoord.js":41, "point-geometry":99}], 45:[function(require, module, exports){
'use strict';
        var Actor = require('../util/actor.js'),
        bucketFilter = require('../style/bucketfilter.js'),
        WorkerTile = require('./workertile.js'),
        tileGeoJSON = require('./tilegeojson.js'),
        Wrapper = require('./geojsonwrapper.js'),
        util = require('../util/util.js'),
        queue = require('queue-async'),
        ajax = require('../util/ajax.js');
        module.exports = Worker;
        function Worker(self) {
        this.self = self;
                this.actor = new Actor(self, this);
        }

util.extend(Worker.prototype, {
alert: function() {
this.self.postMessage({
type: 'alert message',
        data: [].slice.call(arguments)
});
},
        // Updates the style to use for this map.
        'set buckets': function(data) {
        var buckets = WorkerTile.buckets = data;
                for (var i = 0; i < buckets.length; i++) {
        var bucket = buckets[i];
                bucket.compare = bucketFilter(bucket.filter);
        }
        },
        'set glyphs': function(data) {
        WorkerTile.prototype.glyphs = data;
        },
        /*
         * Load and parse a tile at `url`, and call `callback` with
         * (err, response)
         *
         * @param {string} url
         * @param {function} callback
         */
        'load tile': function(params, callback) {
        new WorkerTile(params.url, undefined, params.id, params.zoom, params.maxZoom, params.tileSize, params.source, params.depth, this.actor, callback);
        },
        /*
         * Abort the request keyed under `url`
         *
         * @param {string} url
         */
        'abort tile': function(params) {
        WorkerTile.cancel(params.id, params.source);
        },
        'remove tile': function(params) {
        var id = params.id;
                var source = params.source;
                if (WorkerTile.loaded[source] && WorkerTile.loaded[source][id]) {
        delete WorkerTile.loaded[source][id];
        }
        },
        'parse geojson': function(params, callback) {
        var data = params.data,
                zooms = params.zooms,
                len = zooms.length,
                maxZoom = zooms[len - 1],
                actor = this.actor,
                q = queue();
                function worker(id, tile, zoom, callback) {
                new WorkerTile(undefined, new Wrapper(tile), id, zoom, maxZoom, params.tileSize, params.source, 4, actor, function(err, data) {
                if (err) return callback(err);
                        data.id = id;
                        callback(null, data);
                });
                }

        function tileData(err, data) {
        if (err) throw err;
                for (var i = 0; i < len; i++) {
        var zoom = zooms[i];
                var tiles = tileGeoJSON(data, zoom);
                for (var id in tiles) {
        q.defer(worker, id, tiles[id], zoom);
        }
        }
        q.awaitAll(callback);
        }

        if (typeof data === 'string') ajax.getJSON(data, tileData);
                else tileData(null, data);
        },
        'query features': function(params, callback) {
        var tile = WorkerTile.loaded[params.source] && WorkerTile.loaded[params.source][params.id];
                if (tile) {
        tile.featureTree.query(params, callback);
        } else {
        callback(null, []);
        }
        }
});
        }, {"../style/bucketfilter.js":48, "../util/actor.js":75, "../util/ajax.js":76, "../util/util.js":87, "./geojsonwrapper.js":37, "./tilegeojson.js":42, "./workertile.js":46, "queue-async":100}], 46:[function(require, module, exports){
'use strict';
        var FeatureTree = require('../data/featuretree.js');
        var Protobuf = require('pbf');
        var vt = require('vector-tile');
        var Collision = require('../symbol/collision.js');
        var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;
        var BufferSet = require('../data/buffer/bufferset.js');
        var createBucket = require('../data/createbucket.js');
        module.exports = WorkerTile;
        function WorkerTile(url, data, id, zoom, maxZoom, tileSize, source, depth, actor, callback) {
        var tile = this;
                this.id = id;
                this.zoom = zoom;
                this.maxZoom = maxZoom;
                this.tileSize = tileSize;
                this.source = source;
                this.depth = depth;
                this.buffers = new BufferSet();
                function loaded(data) {
                WorkerTile.loaded[source] = WorkerTile.loaded[source] || {};
                        WorkerTile.loaded[source][id] = tile;
                        tile.data = data;
                        tile.parse(data, actor, callback);
                }

        if (url) {
        if (WorkerTile.loading[source] === undefined) WorkerTile.loading[source] = {};
                WorkerTile.loading[source][id] = getArrayBuffer(url, function(err, data) {
        delete WorkerTile.loading[source][id];
                if (err) {
        callback(err);
        } else {
        loaded(new vt.VectorTile(new Protobuf(new Uint8Array(data))));
        }
        });
        } else {
        loaded(data);
        }
        }

WorkerTile.cancel = function(id, sourceID) {
var source = WorkerTile.loading[sourceID];
        if (source && source[id]) {
source[id].abort();
        delete source[id];
}
};
// Stores tiles that are currently loading.
        WorkerTile.loading = {};
// Stores tiles that are currently loaded.
        WorkerTile.loaded = {};
// Stores the style information.
        WorkerTile.buckets = [];
        /*
         * Given tile data, parse raw vertices and data, create a vector
         * tile and parse it into ready-to-render vertices.
         *
         * @param {object} data
         * @param {function} respond
         */
        WorkerTile.prototype.parse = function(data, actor, callback) {
        var tile = this;
                var bucketInfo = WorkerTile.buckets;
                this.callback = callback;
                var tileExtent = 4096;
                this.collision = new Collision(this.zoom, tileExtent, this.tileSize, this.depth);
                this.featureTree = new FeatureTree(getGeometry, getType);
                var buckets = this.buckets = sortTileIntoBuckets(this, data, bucketInfo);
                var key, bucket;
                var prevPlacementBucket;
                var remaining = WorkerTile.buckets.length;
                /*
                 *  The async parsing here is a bit tricky.
                 *  Some buckets depend on resources that may need to be loaded async (glyphs).
                 *  Some buckets need to be parsed in order (to get placement priorities right).
                 *
                 *  Dependencies calls are initiated first to get those rolling.
                 *  Buckets that don't need to be parsed in order, aren't to save time.
                 */

                var orderedBuckets = WorkerTile.buckets;
                for (var i = 0; i < orderedBuckets.length; i++) {
        bucket = buckets[orderedBuckets[i].id];
                if (!bucket) {
        remaining--;
                continue; // raster bucket, etc
        }

        var filter = bucket.info.filter;
                if (filter && filter.source !== this.source) continue;
                // Link buckets that need to be parsed in order
                if (bucket.collision) {
        if (prevPlacementBucket) {
        prevPlacementBucket.next = bucket;
        } else {
        bucket.previousPlaced = true;
        }
        prevPlacementBucket = bucket;
        }

        if (bucket.getDependencies) {
        bucket.getDependencies(this, actor, dependenciesDone(bucket));
        }

        }

        // parse buckets where order doesn't matter and no dependencies
        for (key in buckets) {
        bucket = buckets[key];
                if (!bucket.getDependencies && !bucket.collision) {
        parseBucket(tile, bucket);
        }
        }

        function dependenciesDone(bucket) {
        return function(err) {
        bucket.dependenciesLoaded = true;
                parseBucket(tile, bucket, err);
        };
        }

        function parseBucket(tile, bucket, skip) {
        if (bucket.getDependencies && !bucket.dependenciesLoaded) return;
                if (bucket.collision && !bucket.previousPlaced) return;
                if (!skip) {
        var now = Date.now();
                if (bucket.type !== 'raster') bucket.addFeatures();
                var time = Date.now() - now;
                if (bucket.interactive) {
        for (var i = 0; i < bucket.features.length; i++) {
        var feature = bucket.features[i];
                tile.featureTree.insert(feature.bbox(), bucket.name, feature);
        }
        }
        if (typeof self !== 'undefined') {
        self.bucketStats = self.bucketStats || {_total: 0};
                self.bucketStats._total += time;
                self.bucketStats[bucket.name] = (self.bucketStats[bucket.name] || 0) + time;
        }
        }

        remaining--;
                if (!remaining) return tile.done();
                // try parsing the next bucket, if it is ready
                if (bucket.next) {
        bucket.next.previousPlaced = true;
                parseBucket(tile, bucket.next);
        }
        }
        };
        WorkerTile.prototype.done = function() {
        // Collect all buffers to mark them as transferable object.
        var buffers = [];
                for (var type in this.buffers) {
        buffers.push(this.buffers[type].array);
        }

        // Convert buckets to a transferable format
        var buckets = this.buckets;
                var elementGroups = {};
                for (var b in buckets) elementGroups[b] = buckets[b].elementGroups;
                this.callback(null, {
                elementGroups: elementGroups,
                        buffers: this.buffers
                }, buffers);
                // we don't need anything except featureTree at this point, so we mark it for GC
                this.buffers = null;
                this.collision = null;
                this.buckets = null;
        };
        function sortTileIntoBuckets(tile, data, bucketInfo) {

        var sourceLayers = {},
                buckets = {},
                layerName;
                // For each source layer, find a list of buckets that use data from it
                for (var i = 0; i < bucketInfo.length; i++) {
        var info = bucketInfo[i];
                var bucketName = info.id;
                var minZoom = info['min-zoom'];
                var maxZoom = info['max-zoom'];
                if (info.source !== tile.source) continue;
                if (minZoom && tile.zoom < minZoom && minZoom < tile.maxZoom) continue;
                if (maxZoom && tile.zoom >= maxZoom) continue;
                var bucket = createBucket(info, tile.buffers, tile.collision);
                if (!bucket) continue;
                bucket.features = [];
                bucket.name = bucketName;
                buckets[bucketName] = bucket;
                if (data.layers) {
        // vectortile
        layerName = info['source-layer'];
                if (!sourceLayers[layerName]) sourceLayers[layerName] = {};
                sourceLayers[layerName][bucketName] = info;
        } else {
        // geojson tile
        sourceLayers[bucketName] = info;
        }
        }

        // read each layer, and sort its feature's into buckets
        if (data.layers) {
        // vectortile
        for (layerName in sourceLayers) {
        var layer = data.layers[layerName];
                if (!layer) continue;
                sortLayerIntoBuckets(layer, sourceLayers[layerName], buckets);
        }
        } else {
        // geojson
        sortLayerIntoBuckets(data, sourceLayers, buckets);
        }

        return buckets;
        }

/*
 * Sorts features in a layer into different buckets, according to the maping
 *
 * Layers in vector tiles contain many different features, and feature types,
 * e.g. the landuse layer has parks, industrial buildings, forests, playgrounds
 * etc. However, when styling, we need to separate these features so that we can
 * render them separately with different styles.
 *
 * @param {VectorTileLayer} layer
 * @param {Mapping} mapping
 */
function sortLayerIntoBuckets(layer, mapping, buckets) {
for (var i = 0; i < layer.length; i++) {
var feature = layer.feature(i);
        for (var key in mapping) {
if (mapping[key].compare(feature)) {
buckets[key].features.push(feature);
}
}
}
}

function getGeometry(feature) {
return feature.loadGeometry();
        }

function getType(feature) {
return vt.VectorTileFeature.types[feature.type];
        }

}, {"../data/buffer/bufferset.js":2, "../data/createbucket.js":10, "../data/featuretree.js":12, "../symbol/collision.js":59, "../util/ajax.js":76, "pbf":97, "vector-tile":103}], 47:[function(require, module, exports){
'use strict';
        module.exports = AnimationLoop;
        function AnimationLoop() {
        this.n = 0;
                this.times = [];
        }

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
this.times = this.times.filter(function(t) {
return t.time >= (new Date()).getTime();
});
        return !this.times.length;
        };
// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
        AnimationLoop.prototype.set = function(t) {
        this.times.push({ id: this.n, time: t + (new Date()).getTime() });
                return this.n++;
        };
// Cancel an animation
        AnimationLoop.prototype.cancel = function(n) {
        this.times = this.times.filter(function(t) {
        return t.id != n;
        });
        };
        }, {}], 48:[function(require, module, exports){
'use strict';
        var VectorTileFeature = require('vector-tile').VectorTileFeature;
        function infix(operator) {
        return function(left, right) { return left + ' ' + operator + ' ' + right; };
        }

var infixOperators = {
'==': infix('==='),
        '>': infix('>'), '$gt': infix('>'),
        '<': infix('<'), '$lt': infix('<'),
        '<=': infix('<='), '$lte': infix('<='),
        '>=': infix('>='), '$gte': infix('>='),
        '!=': infix('!=='), '$ne': infix('!=='),
        '$exists': function (value) { return value + ' !== undefined'; }
};
        function or(items)  { return '(' + items.join(' || ') + ')'; }
function and(items) { return '(' + items.join(' && ') + ')'; }
function not(item)  { return '!' + item; }
function nor(items) { return not(or(items)); }

var arrayOperators = {
'||': or, '$or': or,
        '&&': and, '$and': and,
        '!': nor, '$nor': nor
        };
        var objOperators = {
        '!': not, '$not': not
        };
        module.exports = function (filter) {
        // simple key & value comparison
        function valueFilter(key, value, operator) {
        return operator('p[' + JSON.stringify(key) + ']', JSON.stringify(value));
        }

        // compares key & value or key & or(values)
        function simpleFieldFilter(key, value, operator) {
        var operatorFn = infixOperators[operator || '=='];
                if (!operatorFn) throw new Error('Unknown operator: ' + operator);
                if (Array.isArray(value)) {
        return or(value.map(function (v) {
        return valueFilter(key, v, operatorFn);
        }));
        } else return valueFilter(key, value, operatorFn);
        }

        // handles any filter key/value pair
        function fieldFilter(key, value) {

        if (Array.isArray(value)) {
        if (key in arrayOperators) { // handle and/or operators
        return arrayOperators[key](value.map(fieldsFilter));
        }

        } else if (typeof value === 'object') {

        // handle not operator
        if (key in objOperators) return objOperators[key](fieldsFilter(value));
                // handle {key: {operator: value}} notation
                var filters = [];
                for (var op in value) {
        filters.push(simpleFieldFilter(key, value[op], op));
        }
        return and(filters);
        }
        // handle simple key/value or key/values comparison
        return simpleFieldFilter(key, value);
        }

        function typeFilter(type) {
        return 'f.type === ' + VectorTileFeature.types.indexOf(type);
        }

        function fieldsFilter(obj) {
        var filters = [];
                for (var key in obj) {
        if (key === '$type') {
        filters.push(typeFilter(obj[key]));
        } else {
        filters.push(fieldFilter(key, obj[key]));
        }
        }

        return filters.length ? and(filters) : 'true';
        }

        var filterStr = 'var p = f.properties || {}; return ' + fieldsFilter(filter || {}) + ';';
                // jshint evil: true
                return new Function('f', filterStr);
        };
        }, {"vector-tile":103}], 49:[function(require, module, exports){
'use strict';
        var reference = require('./reference');
        module.exports = {};
        reference['class'].forEach(function(className) {
var Calculated = function() {};
        var style = reference[className];
        for (var prop in style) {
if (style[prop]['default'] === undefined) continue;
        Calculated.prototype[prop] = style[prop]['default'];
}
module.exports[className.replace('class_', '')] = Calculated;
        });
        }, {"./reference":51}], 50:[function(require, module, exports){
'use strict';
        var Evented = require('../util/evented.js');
        var ajax = require('../util/ajax.js');
        var browser = require('../util/browser.js');
        module.exports = ImageSprite;
        function ImageSprite(base) {

        var sprite = this;
                this.base = base;
                this.retina = browser.devicePixelRatio > 1;
                base = sprite.base + (sprite.retina ? '@2x' : '');
                ajax.getJSON(base + '.json', function(err, data) {
                // @TODO handle errors via sprite event.
                if (err) return;
                        sprite.data = data;
                        if (sprite.img) sprite.fire('loaded');
                });
                ajax.getImage(base + '.png', function(err, img) {
                // @TODO handle errors via sprite event.
                if (err) return;
                        // premultiply the sprite
                        var data = img.getData();
                        var newdata = img.data = new Uint8Array(data.length);
                        for (var i = 0; i < data.length; i += 4) {
                var alpha = data[i + 3] / 255;
                        newdata[i + 0] = data[i + 0] * alpha;
                        newdata[i + 1] = data[i + 1] * alpha;
                        newdata[i + 2] = data[i + 2] * alpha;
                        newdata[i + 3] = data[i + 3];
                }

                sprite.img = img;
                        if (sprite.data) sprite.fire('loaded');
                });
        }

ImageSprite.prototype = Object.create(Evented);
        ImageSprite.prototype.toJSON = function() {
        return this.base;
        };
        ImageSprite.prototype.loaded = function() {
        return !!(this.data && this.img);
        };
        ImageSprite.prototype.resize = function(gl) {
        var sprite = this;
                if (browser.devicePixelRatio > 1 !== sprite.retina) {

        var newSprite = new ImageSprite(sprite.base);
                newSprite.on('loaded', function() {

                sprite.img = newSprite.img;
                        sprite.data = newSprite.data;
                        sprite.retina = newSprite.retina;
                        if (sprite.texture) {
                gl.deleteTexture(sprite.texture);
                        delete sprite.texture;
                }

                });
        }
        };
        ImageSprite.prototype.bind = function(gl, linear) {
        var sprite = this;
                if (!sprite.loaded())
                return;
                if (!sprite.texture) {
        sprite.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var img = sprite.img;
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img.data);
        } else {
        gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
        }

        var filter = linear ? gl.LINEAR : gl.NEAREST;
                if (filter !== sprite.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        }
        };
        ImageSprite.prototype.getPosition = function(name, repeating) {

        // `repeating` indicates that the image will be used in a repeating pattern
        // repeating pattern images are assumed to have a 1px padding that mirrors the opposite edge
        // positions for repeating images are adjusted to exclude the edge
        repeating = repeating === true ? 1 : 0;
                var pos = this.data && this.data[name];
                if (pos && this.img) {
        var width = this.img.width;
                var height = this.img.height;
                return {
                size: [pos.width / pos.pixelRatio, pos.height / pos.pixelRatio],
                        tl: [(pos.x + repeating) / width, (pos.y + repeating) / height],
                        br: [(pos.x + pos.width - 2 * repeating) / width, (pos.y + pos.height - 2 * repeating) / height]
                };
        }
        };
        }, {"../util/ajax.js":76, "../util/browser.js":77, "../util/evented.js":82}], 51:[function(require, module, exports){
module.exports = require('mapbox-gl-style-spec/reference/v5');
        }, {"mapbox-gl-style-spec/reference/v5":96}], 52:[function(require, module, exports){
'use strict';
        var reference = require('./reference');
        module.exports = {};
        reference.render.forEach(function(className) {
        var Properties = function(props) {
        for (var p in props) {
        this[p] = props[p];
        }
        };
                var properties = reference[className];
                for (var prop in properties) {
        if (properties[prop]['default'] === undefined) continue;
                Properties.prototype[prop] = properties[prop]['default'];
        }
        module.exports[className.replace('render_', '')] = Properties;
        });
        }, {"./reference":51}], 53:[function(require, module, exports){
'use strict';
        var Evented = require('../util/evented.js');
        var StyleTransition = require('./styletransition.js');
        var StyleDeclaration = require('./styledeclaration.js');
        var StyleConstant = require('./styleconstant.js');
        var CalculatedStyle = require('./calculatedstyle.js');
        var ImageSprite = require('./imagesprite.js');
        var util = require('../util/util.js');
        module.exports = Style;
        /*
         * The map style's current state
         *
         * The stylesheet object is not modified. To change the style, just change
         * the the stylesheet object and trigger a cascade.
         */
                function Style(stylesheet, animationLoop) {
                if (stylesheet.version !== 5) console.warn('Stylesheet version must be 5');
                        if (!Array.isArray(stylesheet.layers)) console.warn('Stylesheet must have layers');
                        this.classes = {};
                        this.stylesheet = stylesheet;
                        this.animationLoop = animationLoop;
                        this.buckets = {};
                        this.orderedBuckets = [];
                        this.transitions = {};
                        this.computed = {};
                        this.sources = {};
                        this.cascade({transition: false});
                        if (stylesheet.sprite) this.setSprite(stylesheet.sprite);
                }

        Style.prototype = Object.create(Evented);
                function premultiplyLayer(layer, type) {
                var colorProp = type + '-color',
                        haloProp = type + '-halo-color',
                        outlineProp = type + '-outline-color',
                        color = layer[colorProp],
                        haloColor = layer[haloProp],
                        outlineColor = layer[outlineProp],
                        opacity = layer[type + '-opacity'];
                        var colorOpacity = color && (opacity * color[3]);
                        var haloOpacity = haloColor && (opacity * haloColor[3]);
                        var outlineOpacity = outlineColor && (opacity * outlineColor[3]);
                        if (colorOpacity !== undefined && colorOpacity < 1) {
                layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
                }
                if (haloOpacity !== undefined && haloOpacity < 1) {
                layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
                }
                if (outlineOpacity !== undefined && outlineOpacity < 1) {
                layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
                }
                }

// Formerly known as zoomed styles
        Style.prototype.recalculate = function(z) {
        if (typeof z !== 'number') console.warn('recalculate expects zoom level');
                var transitions = this.transitions;
                var layerValues = {};
                this.sources = {};
                this.rasterFadeDuration = 300;
                for (var name in transitions) {
        var layer = transitions[name],
                bucket = this.buckets[layer.ref || name],
                layerType = this.layermap[name].type;
                if (!CalculatedStyle[layerType]) {
        console.warn('unknown layer type ' + layerType);
                continue;
        }
        var appliedLayer = layerValues[name] = new CalculatedStyle[layerType]();
                for (var rule in layer) {
        var transition = layer[rule];
                appliedLayer[rule] = transition.at(z);
        }

        if (layerType === 'symbol') {
        appliedLayer.hidden =
                (appliedLayer['text-opacity'] === 0 || !bucket.render['text-field']) &&
                (appliedLayer['icon-opacity'] === 0 || !bucket.render['icon-image']);
                if (!appliedLayer.hidden) {
        premultiplyLayer(appliedLayer, 'text');
                premultiplyLayer(appliedLayer, 'icon');
        }
        } else {
        appliedLayer.hidden = (appliedLayer[layerType + '-opacity'] === 0);
                if (!appliedLayer.hidden) {
        premultiplyLayer(appliedLayer, layerType);
        }
        }

        // Find all the sources that are currently being used
        // so that we can automatically enable/disable them as needed
        if (!appliedLayer.hidden) {
        var source = bucket && bucket.source;
                // mark source as used so that tiles are downloaded
                if (source) this.sources[source] = true;
        }

        if (appliedLayer['raster-fade-duration']) {
        this.rasterFadeDuration = Math.max(this.rasterFadeDuration, appliedLayer['raster-fade-duration']);
        }
        }

        this.computed = layerValues;
                this.z = z;
                this.fire('zoom');
        };
                Style.prototype._simpleLayer = function(layer) {
                var simple = {};
                        simple.id = layer.id;
                        var bucket = this.buckets[layer.ref || layer.id];
                        if (bucket) simple.bucket = bucket.id;
                        if (layer.type) simple.type = layer.type;
                        if (layer.layers) {
                simple.layers = [];
                        for (var i = 0; i < layer.layers.length; i++) {
                simple.layers.push(this._simpleLayer(layer.layers[i]));
                }
                }
                return simple;
                };
// Split the layers into groups of consecutive layers with the same datasource
                Style.prototype._groupLayers = function(layers) {
                var g = 0;
                        var groups = [];
                        var group;
                        // loop over layers top down
                        for (var i = layers.length - 1; i >= 0; i--) {
                var layer = layers[i];
                        var bucket = this.buckets[layer.ref || layer.id];
                        var source = bucket && bucket.source;
                        // if the current layer is in a different source
                        if (group && source !== group.source) g++;
                        if (!groups[g]) {
                group = [];
                        group.source = source;
                        groups[g] = group;
                }

                group.push(this._simpleLayer(layer));
                }

                return groups;
                };
                /*
                 * Take all the rules and declarations from the stylesheet,
                 * and figure out which apply currently
                 */
                Style.prototype.cascade = function(options) {
                options = options || {
                transition: true
                };
                        var a, b;
                        var id;
                        var prop;
                        var layer;
                        var className;
                        var styleName;
                        var style;
                        var styleTrans;
                        var constants = this.stylesheet.constants;
                        // derive buckets from layers
                        this.orderedBuckets = [];
                        this.buckets = getbuckets({}, this.orderedBuckets, this.stylesheet.layers);
                        function getbuckets(buckets, ordered, layers) {
                        for (var a = 0; a < layers.length; a++) {
                        var layer = layers[a];
                                if (layer.layers) {
                        buckets = getbuckets(buckets, ordered, layer.layers);
                        }
                        if (!layer.source || !layer.type) {
                        continue;
                        }
                        var bucket = { id: layer.id };
                                for (var prop in layer) {
                        if ((/^style/).test(prop)) continue;
                                bucket[prop] = layer[prop];
                        }
                        bucket.render = StyleConstant.resolve(bucket.render, constants);
                                buckets[layer.id] = bucket;
                                ordered.push(bucket);
                        }
                        return buckets;
                        }

                // style class keys
                var styleNames = ['style'];
                        for (className in this.classes) styleNames.push('style.' + className);
                        // apply layer group inheritance resulting in a flattened array
                        var flattened = flattenLayers(this.stylesheet.layers);
                        // map layer ids to layer definitions for resolving refs
                        var layermap = this.layermap = {};
                        for (a = 0; a < flattened.length; a++) {
                layer = flattened[a];
                        var newLayer = {};
                        for (var k in layer) {
                if (k === 'layers') continue;
                        newLayer[k] = layer[k];
                }

                layermap[layer.id] = newLayer;
                        flattened[a] = newLayer;
                }

                for (a = 0; a < flattened.length; a++) {
                flattened[a] = resolveLayer(layermap, flattened[a]);
                }

                // Resolve layer references.
                function resolveLayer(layermap, layer) {
                if (!layer.ref || !layermap[layer.ref]) return layer;
                        var parent = resolveLayer(layermap, layermap[layer.ref]);
                        layer.render = parent.render;
                        layer.type = parent.type;
                        layer.filter = parent.filter;
                        layer.source = parent.source;
                        layer['source-layer'] = parent['source-layer'];
                        layer['min-zoom'] = parent['min-zoom'];
                        layer['max-zoom'] = parent['max-zoom'];
                        return layer;
                }

                // Flatten composite layer structures.
                function flattenLayers(layers) {
                var flat = [];
                        for (var i = 0; i < layers.length; i++) {
                flat.push(layers[i]);
                        if (layers[i].layers) {
                flat.push.apply(flat, flattenLayers(layers[i].layers));
                }
                }
                return flat;
                }

                var transitions = {};
                        var globalTrans = this.stylesheet.transition;
                        for (a in flattened) {
                layer = flattened[a];
                        id = layer.id;
                        style = {};
                        styleTrans = {};
                        // basic cascading of styles
                        for (b = 0; b < styleNames.length; b++) {
                styleName = styleNames[b];
                        if (!layer[styleName]) continue;
                        // set style properties
                        for (prop in layer[styleName]) {
                if (prop.indexOf('transition-') === - 1) {
                style[prop] = layer[styleName][prop];
                } else {
                styleTrans[prop.replace('transition-', '')] = layer[styleName][prop];
                }
                }
                }

                style = StyleConstant.resolve(style, constants);
                        var renderType = layer.type;
                        transitions[id] = {};
                        for (prop in style) {
                var newDeclaration = new StyleDeclaration(renderType, prop, style[prop]);
                        var oldTransition = this.transitions[id] && this.transitions[id][prop];
                        var newStyleTrans = {};
                        newStyleTrans.duration = styleTrans[prop] && styleTrans[prop].duration ? styleTrans[prop].duration : globalTrans && globalTrans.duration ? globalTrans.duration : 300;
                        newStyleTrans.delay = styleTrans[prop] && styleTrans[prop].delay ? styleTrans[prop].delay : globalTrans && globalTrans.delay ? globalTrans.delay : 0;
                        if (!options.transition) {
                newStyleTrans.duration = 0;
                        newStyleTrans.delay = 0;
                }

                // Only create a new transition if the declaration changed
                if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                var newTransition = new StyleTransition(newDeclaration, oldTransition, newStyleTrans);
                        transitions[id][prop] = newTransition;
                        // Run the animation loop until the end of the transition
                        if (!newTransition.instant()) {
                newTransition.loopID = this.animationLoop.set(newTransition.endTime - (new Date()).getTime());
                }

                if (oldTransition) {
                this.animationLoop.cancel(oldTransition.loopID);
                }
                } else {
                transitions[id][prop] = oldTransition;
                }
                }
                }

                this.transitions = transitions;
                        this.layerGroups = this._groupLayers(this.stylesheet.layers);
                        this.fire('change');
                };
                /* This should be moved elsewhere. Localizing resources doesn't belong here */
                Style.prototype.setSprite = function(sprite) {
                this.sprite = new ImageSprite(sprite);
                        this.sprite.on('loaded', this.fire.bind(this, 'change'));
                };
// Modify classes
                Style.prototype.addClass = function(n, options) {
                if (this.classes[n]) return; // prevent unnecessary recalculation
                        this.classes[n] = true;
                        this.cascade(options);
                };
                Style.prototype.removeClass = function(n, options) {
                if (!this.classes[n]) return; // prevent unnecessary recalculation
                        delete this.classes[n];
                        this.cascade(options);
                };
                Style.prototype.hasClass = function(n) {
                return !!this.classes[n];
                };
                Style.prototype.setClassList = function(l, options) {
                this.classes = {};
                        for (var i = 0; i < l.length; i++) {
                this.classes[l[i]] = true;
                }
                this.cascade(options);
                };
                Style.prototype.getClassList = function() {
                return Object.keys(this.classes);
                };
                Style.prototype.getLayer = function(id) {
                return this.layermap[id];
                };
        }, {"../util/evented.js":82, "../util/util.js":87, "./calculatedstyle.js":49, "./imagesprite.js":50, "./styleconstant.js":54, "./styledeclaration.js":55, "./styletransition.js":56}], 54:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js');
        module.exports.resolve = function (properties, constants) {
        if (!constants)
                return properties;
                var result = {}, i;
                function resolve(value) {
                return typeof value === 'string' && value[0] === '@' ? constants[value] : value;
                }

        for (var key in properties) {
        var value = resolve(properties[key]);
                if (Array.isArray(value)) {
        value = value.slice();
                for (i = 0; i < value.length; i++) {
        if (value[i] in constants) {
        value[i] = resolve(value[i]);
        }
        }
        }

        if (value.stops) {
        value = util.extend({}, value);
                value.stops = value.stops.slice();
                for (i = 0; i < value.stops.length; i++) {
        if (value.stops[i][1] in constants) {
        value.stops[i] = [
                value.stops[i][0],
                resolve(value.stops[i][1])
        ];
        }
        }
        }

        result[key] = value;
        }

        return result;
        };
        }, {"../util/util.js":87}], 55:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js'),
        reference = require('./reference'),
        parseCSSColor = require('csscolorparser').parseCSSColor;
        module.exports = StyleDeclaration;
        /*
         * A parsed representation of a property:value pair
         */
                function StyleDeclaration(renderType, prop, value) {
                var className = 'class_' + renderType;
                        var propReference = reference[className] && reference[className][prop];
                        if (!propReference) return;
                        this.value = this.parseValue(value, propReference.type, propReference.values);
                        this.prop = prop;
                        this.type = propReference.type;
                        // immuatable representation of value. used for comparison
                        this.json = JSON.stringify(value);
                }

        StyleDeclaration.prototype.calculate = function(z) {
        return typeof this.value === 'function' ? this.value(z) : this.value;
        };
                StyleDeclaration.prototype.parseValue = function(value, type, values) {
                if (type === 'color') {
                return parseColor(value);
                } else if (type === 'number') {
                return parseNumber(value);
                } else if (type === 'boolean') {
                return Boolean(value);
                } else if (type === 'image') {
                return String(value);
                } else if (type === 'string') {
                return String(value);
                } else if (type === 'array') {
                return parseNumberArray(value);
                } else if (type === 'enum' && Array.isArray(values)) {
                return values.indexOf(value) >= 0 ? value : undefined;
                } else {
                console.warn(type + ' is not a supported property type');
                }
                };
                function parseNumber(num) {
                if (num.stops) num = stopsFn(num);
                        var value = + num;
                        return !isNaN(value) ? value : num;
                }

        function parseNumberArray(array) {
        var widths = array.map(parseNumber);
                return function(z) {
                var result = [];
                        for (var i = 0; i < widths.length; i++) {
                result.push(typeof widths[i] === 'function' ? widths[i](z) : widths[i]);
                }
                return result;
                };
        }

        var colorCache = {};
                function parseColor(value) {
                if (value.stops) return stopsFn(value, true);
                        if (colorCache[value]) return colorCache[value];
                        var color = colorCache[value] = prepareColor(parseCSSColor(value));
                        return color;
                }

        function stopsFn(params, color) {
        var stops = params.stops;
                var base = params.base || reference.function.base.default;
                return function(z) {

                // find the two stops which the current z is between
                var low, high;
                        for (var i = 0; i < stops.length; i++) {
                var stop = stops[i];
                        if (stop[0] <= z) low = stop;
                        if (stop[0] > z) {
                high = stop;
                        break;
                }
                }

                if (low && high) {
                var zoomDiff = high[0] - low[0],
                        zoomProgress = z - low[0],
                        t = base === 1 ?
                        zoomProgress / zoomDiff :
                        (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);
                        if (color) return interpColor(parseColor(low[1]), parseColor(high[1]), t);
                        else return util.interp(low[1], high[1], t);
                } else if (low) {
                if (color) return parseColor(low[1]);
                        else return low[1];
                } else if (high) {
                if (color) return parseColor(high[1]);
                        else return high[1];
                } else {
                if (color) return [0, 0, 0, 1];
                        else return 1;
                }
                };
        }

        function prepareColor(c) {
        return [c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 1];
        }

        function interpColor(from, to, t) {
        return [
                util.interp(from[0], to[0], t),
                util.interp(from[1], to[1], t),
                util.interp(from[2], to[2], t),
                util.interp(from[3], to[3], t)
        ];
        }

        }, {"../util/util.js":87, "./reference":51, "csscolorparser":92}], 56:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js');
        module.exports = StyleTransition;
        /*
         * Represents a transition between two declarations
         */
                function StyleTransition(declaration, oldTransition, value) {

                this.declaration = declaration;
                        this.startTime = this.endTime = (new Date()).getTime();
                        var type = declaration.type;
                        if (type === 'number') {
                this.interp = util.interp;
                } else if (type === 'color') {
                this.interp = interpColor;
                } else if (type === 'array') {
                this.interp = interpNumberArray;
                }

                this.oldTransition = oldTransition;
                        this.duration = value.duration || 0;
                        this.delay = value.delay || 0;
                        if (!this.instant()) {
                this.endTime = this.startTime + this.duration + this.delay;
                        this.ease = util.easeCubicInOut;
                }

                if (oldTransition && oldTransition.endTime <= this.startTime) {
                // Old transition is done running, so we can
                // delete its reference to its old transition.

                delete oldTransition.oldTransition;
                }
                }

        StyleTransition.prototype.instant = function() {
        return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
        };
                /*
                 * Return the value of the transitioning property at zoom level `z` and optional time `t`
                 */
                StyleTransition.prototype.at = function(z, t) {

                var value = this.declaration.calculate(z);
                        if (this.instant()) return value;
                        t = t || Date.now();
                        if (t < this.endTime) {
                var oldValue = this.oldTransition.at(z, this.startTime);
                        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
                        value = this.interp(oldValue, value, eased);
                }

                return value;
                };
                function interpNumberArray(from, to, t) {
                return from.map(function(d, i) {
                return util.interp(d, to[i], t);
                });
                }

        function interpColor(from, to, t) {
        return [
                util.interp(from[0], to[0], t),
                util.interp(from[1], to[1], t),
                util.interp(from[2], to[2], t),
                util.interp(from[3], to[3], t)
        ];
        }

        }, {"../util/util.js":87}], 57:[function(require, module, exports){
'use strict';
        var Point = require('point-geometry');
        module.exports = Anchor;
        function Anchor(x, y, angle, scale, segment) {
        this.x = x;
                this.y = y;
                this.angle = angle;
                this.scale = scale;
                if (segment !== undefined) {
        this.segment = segment;
        }
        }

Anchor.prototype = Object.create(Point.prototype);
        Anchor.prototype.clone = function() {
        return new Anchor(this.x, this.y, this.angle, this.scale, this.segment);
        };
        }, {"point-geometry":99}], 58:[function(require, module, exports){
'use strict';
        module.exports = BinPack;
        function BinPack(width, height) {
        this.width = width;
                this.height = height;
                this.free = [{ x: 0, y: 0, w: width, h: height }];
        }

BinPack.prototype.release = function(rect) {
// Simple algorithm to recursively merge the newly released cell with its
// neighbor. This doesn't merge more than two cells at a time, and fails
// for complicated merges.
for (var i = 0; i < this.free.length; i++) {
var free = this.free[i];
        if (free.y == rect.y && free.h == rect.h && free.x + free.w == rect.x) {
free.w += rect.w;
}
else if (free.x == rect.x && free.w == rect.w && free.y + free.h == rect.y) {
free.h += rect.h;
}
else if (rect.y == free.y && rect.h == free.h && rect.x + rect.w == free.x) {
free.x = rect.x;
        free.w += rect.w;
}
else if (rect.x == free.x && rect.w == free.w && rect.y + rect.h == free.y) {
free.y = rect.y;
        free.h += rect.h;
} else {
continue;
}

this.free.splice(i, 1);
        this.release(free);
        return;
}
this.free.push(rect);
        };
        BinPack.prototype.allocate = function(width, height) {
        // Find the smallest free rect angle
        var rect = { x: Infinity, y: Infinity, w: Infinity, h: Infinity };
                var smallest = - 1;
                for (var i = 0; i < this.free.length; i++) {
        var ref = this.free[i];
                if (width <= ref.w && height <= ref.h && ref.y <= rect.y && ref.x <= rect.x) {
        rect = ref;
                smallest = i;
        }
        }

        if (smallest < 0) {
        // There's no space left for this char.
        return { x: - 1, y: - 1 };
        } else {
        this.free.splice(smallest, 1);
                // Shorter/Longer Axis Split Rule (SAS)
                // http://clb.demon.fi/files/RectangleBinPack.pdf p. 15
                // Ignore the dimension of R and just split long the shorter dimension
                // See Also: http://www.cs.princeton.edu/~chazelle/pubs/blbinpacking.pdf
                if (rect.w < rect.h) {
        // split horizontally
        // +--+---+
        // |__|___|  <-- b1
        // +------+  <-- b2
        if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: height });
                if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: rect.w, h: rect.h - height });
        } else {
        // split vertically
        // +--+---+
        // |__|   | <-- b1
        // +--|---+ <-- b2
        if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: rect.h });
                if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: width, h: rect.h - height });
        }

        return { x: rect.x, y: rect.y, w: width, h: height };
        }
        };
        }, {}], 59:[function(require, module, exports){
'use strict';
        var rbush = require('rbush'),
        rotationRange = require('./rotationrange.js'),
        Point = require('point-geometry');
        module.exports = Collision;
        function Collision(zoom, tileExtent, tileSize, placementDepth) {
        this.hTree = rbush(); // tree for horizontal labels
                this.cTree = rbush(); // tree for glyphs from curved labels

                // tile pixels per screen pixels at the tile's zoom level
                this.tilePixelRatio = tileExtent / tileSize;
                this.zoom = zoom;
                // Calculate the maximum scale we can go down in our fake-3d rtree so that
                // placement still makes sense. This is calculated so that the minimum
                // placement zoom can be at most 25.5 (we use an unsigned integer x10 to
                // store the minimum zoom).
                //
                // We don't want to place labels all the way to 25.5. This lets too many
                // glyphs be placed, slowing down collision checking. Only place labels if
                // they will show up within the intended zoom range of the tile.
                placementDepth = Math.min(3, placementDepth || 1, 25.5 - this.zoom);
                this.maxPlacementScale = Math.exp(Math.LN2 * placementDepth);
                var m = 4096;
                var edge = m * this.tilePixelRatio * 2;
                var fullRange = [Math.PI * 2, 0];
                this.left = {
                anchor: new Point(0, 0),
                        box: { x1: - edge, y1: - edge, x2: 0, y2: edge },
                        placementRange: fullRange,
                        placementScale: 0.5,
                        maxScale: Infinity,
                        padding: 0
                };
                this.top = {
                anchor: new Point(0, 0),
                        box: { x1: - edge, y1: - edge, x2: edge, y2: 0 },
                        placementRange: fullRange,
                        placementScale: 0.5,
                        maxScale: Infinity,
                        padding: 0
                };
                this.bottom = {
                anchor: new Point(m, m),
                        box: { x1: - edge, y1: 0, x2: edge, y2: edge },
                        placementRange: fullRange,
                        placementScale: 0.5,
                        maxScale: Infinity,
                        padding: 0
                };
                this.right = {
                anchor: new Point(m, m),
                        box: { x1: 0, y1: - edge, x2: edge, y2: edge },
                        placementRange: fullRange,
                        placementScale: 0.5,
                        maxScale: Infinity,
                        padding: 0
                };
        }

Collision.prototype.getPlacementScale = function(glyphs, minPlacementScale, avoidEdges) {

var left = this.left;
        var right = this.right;
        var top = this.top;
        var bottom = this.bottom;
        for (var k = 0; k < glyphs.length; k++) {

var glyph = glyphs[k];
        var box = glyph.box;
        var bbox = glyph.hBox || box;
        var anchor = glyph.anchor;
        var pad = glyph.padding;
        var minScale = Math.max(minPlacementScale, glyph.minScale);
        var maxScale = glyph.maxScale || Infinity;
        if (minScale >= maxScale) continue;
        // Compute the scaled bounding box of the unrotated glyph
        var searchBox = this.getBox(anchor, bbox, minScale, maxScale);
        var blocking = this.hTree.search(searchBox).concat(this.cTree.search(searchBox));
        if (avoidEdges) {
if (searchBox[0] < 0) blocking.push(left);
        if (searchBox[1] < 0) blocking.push(top);
        if (searchBox[2] >= 4096) blocking.push(right);
        if (searchBox[3] >= 4096) blocking.push(bottom);
}

if (blocking.length) {

var na = anchor; // new anchor
        var nb = box; // new box

        for (var l = 0; l < blocking.length; l++) {
var oa = blocking[l].anchor; // old anchor
        var ob = blocking[l].box; // old box

        // If anchors are identical, we're going to skip the label.
        // NOTE: this isn't right because there can be glyphs with
        // the same anchor but differing box offsets.
        if (na.equals(oa)) {
return null;
}

// todo: unhardcode the 8 = tileExtent/tileSize
var padding = Math.max(pad, blocking[l].padding) * 8;
        // Original algorithm:
        var s1 = (ob.x1 - nb.x2 - padding) / (na.x - oa.x); // scale at which new box is to the left of old box
        var s2 = (ob.x2 - nb.x1 + padding) / (na.x - oa.x); // scale at which new box is to the right of old box
        var s3 = (ob.y1 - nb.y2 - padding) / (na.y - oa.y); // scale at which new box is to the top of old box
        var s4 = (ob.y2 - nb.y1 + padding) / (na.y - oa.y); // scale at which new box is to the bottom of old box

        if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
        if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;
        var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));
        // Only update label's min scale if the glyph was restricted by a collision
        if (collisionFreeScale > minPlacementScale &&
                collisionFreeScale > minScale &&
                collisionFreeScale < maxScale &&
                collisionFreeScale < blocking[l].maxScale) {
minPlacementScale = collisionFreeScale;
}

if (minPlacementScale > this.maxPlacementScale) {
return null;
}
}

}
}

return minPlacementScale;
        };
        Collision.prototype.getPlacementRange = function(glyphs, placementScale, horizontal) {

        var placementRange = [2 * Math.PI, 0];
                for (var k = 0; k < glyphs.length; k++) {
        var glyph = glyphs[k];
                var bbox = glyph.hBox || glyph.box;
                var anchor = glyph.anchor;
                var minPlacedX = anchor.x + bbox.x1 / placementScale;
                var minPlacedY = anchor.y + bbox.y1 / placementScale;
                var maxPlacedX = anchor.x + bbox.x2 / placementScale;
                var maxPlacedY = anchor.y + bbox.y2 / placementScale;
                var searchBox = [minPlacedX, minPlacedY, maxPlacedX, maxPlacedY];
                var blocking = this.hTree.search(searchBox);
                if (horizontal) {
        blocking = blocking.concat(this.cTree.search(searchBox));
        }

        for (var l = 0; l < blocking.length; l++) {
        var b = blocking[l];
                var bbox2 = b.hBox || b.box;
                var x1, x2, y1, y2, intersectX, intersectY;
                // Adjust and compare bboxes to see if the glyphs might intersect
                if (placementScale > b.placementScale) {
        x1 = b.anchor.x + bbox2.x1 / placementScale;
                y1 = b.anchor.y + bbox2.y1 / placementScale;
                x2 = b.anchor.x + bbox2.x2 / placementScale;
                y2 = b.anchor.y + bbox2.y2 / placementScale;
                intersectX = x1 < maxPlacedX && x2 > minPlacedX;
                intersectY = y1 < maxPlacedY && y2 > minPlacedY;
        } else {
        x1 = anchor.x + bbox.x1 / b.placementScale;
                y1 = anchor.y + bbox.y1 / b.placementScale;
                x2 = anchor.x + bbox.x2 / b.placementScale;
                y2 = anchor.y + bbox.y2 / b.placementScale;
                intersectX = x1 < b[2] && x2 > b[0];
                intersectY = y1 < b[3] && y2 > b[1];
        }

        // If they can't intersect, skip more expensive rotation calculation
        if (!(intersectX && intersectY)) continue;
                var scale = Math.max(placementScale, b.placementScale);
                var range = rotationRange.rotationRange(glyph, b, scale);
                placementRange[0] = Math.min(placementRange[0], range[0]);
                placementRange[1] = Math.max(placementRange[1], range[1]);
        }
        }

        return placementRange;
        };
// Insert glyph placements into rtree.
        Collision.prototype.insert = function(glyphs, anchor, placementScale, placementRange, horizontal) {

        var allBounds = [];
                for (var k = 0; k < glyphs.length; k++) {

        var glyph = glyphs[k];
                var bbox = glyph.hBox || glyph.box;
                var minScale = Math.max(placementScale, glyph.minScale);
                var maxScale = glyph.maxScale || Infinity;
                var bounds = this.getBox(anchor, bbox, minScale, maxScale);
                bounds.anchor = anchor;
                bounds.box = glyph.box;
                if (glyph.hBox) bounds.hBox = bbox;
                bounds.placementRange = placementRange;
                bounds.placementScale = minScale;
                bounds.maxScale = maxScale;
                bounds.padding = glyph.padding;
                allBounds.push(bounds);
        }

        (horizontal ? this.hTree : this.cTree).load(allBounds);
        };
        Collision.prototype.getBox = function(anchor, bbox, minScale, maxScale) {
        return [
                anchor.x + Math.min(bbox.x1 / minScale, bbox.x1 / maxScale),
                anchor.y + Math.min(bbox.y1 / minScale, bbox.y1 / maxScale),
                anchor.x + Math.max(bbox.x2 / minScale, bbox.x2 / maxScale),
                anchor.y + Math.max(bbox.y2 / minScale, bbox.y2 / maxScale)];
        };
        }, {"./rotationrange.js":65, "point-geometry":99, "rbush":101}], 60:[function(require, module, exports){
'use strict';
        var BinPack = require('./binpack.js');
        module.exports = GlyphAtlas;
        function GlyphAtlas(width, height) {
        this.width = width;
                this.height = height;
                this.bin = new BinPack(width, height);
                this.index = {};
                this.ids = {};
                this.data = new Uint8Array(width * height);
        }

GlyphAtlas.prototype = {
get debug() {
return 'canvas' in this;
},
        set debug(value) {
if (value && !this.canvas) {
this.canvas = document.createElement('canvas');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
} else if (!value && this.canvas) {
this.canvas.parentNode.removeChild(this.canvas);
        delete this.ctx;
        delete this.canvas;
}
}
};
        GlyphAtlas.prototype.getGlyphs = function() {
        var glyphs = {},
                split,
                name,
                id;
                for (var key in this.ids) {
        split = key.split('#');
                name = split[0];
                id = split[1];
                if (!glyphs[name]) glyphs[name] = [];
                glyphs[name].push(id);
        }

        return glyphs;
        };
        GlyphAtlas.prototype.getRects = function() {
        var rects = {},
                split,
                name,
                id;
                for (var key in this.ids) {
        split = key.split('#');
                name = split[0];
                id = split[1];
                if (!rects[name]) rects[name] = {};
                rects[name][id] = this.index[key];
        }

        return rects;
        };
        GlyphAtlas.prototype.removeGlyphs = function(id) {
        for (var key in this.ids) {

        var ids = this.ids[key];
                var pos = ids.indexOf(id);
                if (pos >= 0) ids.splice(pos, 1);
                this.ids[key] = ids;
                if (!ids.length) {
        var rect = this.index[key];
                var target = this.data;
                for (var y = 0; y < rect.h; y++) {
        var y1 = this.width * (rect.y + y) + rect.x;
                for (var x = 0; x < rect.w; x++) {
        target[y1 + x] = 0;
        }
        }

        this.dirty = true;
                this.bin.release(rect);
                delete this.index[key];
                delete this.ids[key];
        }
        }


        this.updateTexture(this.gl);
        };
        GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
        if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
        }
        var key = name + "#" + glyph.id;
                // The glyph is already in this texture.
                if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
        this.ids[key].push(id);
        }
        return this.index[key];
        }

        // The glyph bitmap has zero width.
        if (!glyph.bitmap) {
        return null;
        }

        var buffered_width = glyph.width + buffer * 2;
                var buffered_height = glyph.height + buffer * 2;
                // Add a 1px border around every image.
                var pack_width = buffered_width;
                var pack_height = buffered_height;
                // Increase to next number divisible by 4, but at least 1.
                // This is so we can scale down the texture coordinates and pack them
                // into 2 bytes rather than 4 bytes.
                pack_width += (4 - pack_width % 4);
                pack_height += (4 - pack_height % 4);
                var rect = this.bin.allocate(pack_width, pack_height);
                if (rect.x < 0) {
        console.warn('glyph bitmap overflow');
                return { glyph: glyph, rect: null };
        }

        // Add left and top glyph offsets to rect.
        rect.l = glyph.left;
                rect.t = glyph.top;
                this.index[key] = rect;
                this.ids[key] = [id];
                var target = this.data;
                var source = glyph.bitmap;
                for (var y = 0; y < buffered_height; y++) {
        var y1 = this.width * (rect.y + y) + rect.x;
                var y2 = buffered_width * y;
                for (var x = 0; x < buffered_width; x++) {
        target[y1 + x] = source[y2 + x];
        }
        }

        this.dirty = true;
                return rect;
        };
        GlyphAtlas.prototype.bind = function(gl) {
        this.gl = gl;
                if (!this.texture) {
        this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);
        } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
        };
        GlyphAtlas.prototype.updateTexture = function(gl) {
        this.bind(gl);
                if (this.dirty) {

        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
                // DEBUG
                if (this.ctx) {
        var data = this.ctx.getImageData(0, 0, this.width, this.height);
                for (var i = 0, j = 0; i < this.data.length; i++, j += 4) {
        data.data[j] = this.data[i];
                data.data[j + 1] = this.data[i];
                data.data[j + 2] = this.data[i];
                data.data[j + 3] = 255;
        }
        this.ctx.putImageData(data, 0, 0);
                this.ctx.strokeStyle = 'red';
                for (var k = 0; k < this.bin.free.length; k++) {
        var free = this.bin.free[k];
                this.ctx.strokeRect(free.x, free.y, free.w, free.h);
        }
        }
        // END DEBUG

        this.dirty = false;
        }
        };
        }, {"./binpack.js":58}], 61:[function(require, module, exports){
'use strict';
        var normalizeURL = require('../util/mapbox.js').normalizeGlyphsURL;
        var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;
        var Glyphs = require('../util/glyphs.js');
        var Protobuf = require('pbf');
        module.exports = GlyphSource;
        function GlyphSource(url, glyphAtlas) {
        this.url = url && normalizeURL(url);
                this.glyphAtlas = glyphAtlas;
                this.stacks = {};
                this.loading = {};
        }

GlyphSource.prototype.getRects = function(fontstack, glyphIDs, tileID, callback) {

if (this.stacks[fontstack] === undefined) this.stacks[fontstack] = {};
        var rects = {};
        var glyphs = {};
        var result = { rects: rects, glyphs: glyphs };
        var stack = this.stacks[fontstack];
        var glyphAtlas = this.glyphAtlas;
        var missing = {};
        var remaining = 0;
        for (var i = 0; i < glyphIDs.length; i++) {
var glyphID = glyphIDs[i];
        var range = Math.floor(glyphID / 256);
        if (stack[range]) {
var glyph = stack[range].glyphs[glyphID];
        var buffer = 3;
        rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
        if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
} else {
if (missing[range] === undefined) {
missing[range] = [];
        remaining++;
}
missing[range].push(glyphID);
}
}

if (!remaining) callback(undefined, result);
        var glyphSource = this;
        for (var r in missing) {
this.loadRange(fontstack, r, onRangeLoaded);
}

function onRangeLoaded(err, range, data) {
// TODO not be silent about errors
if (!err) {
var stack = glyphSource.stacks[fontstack][range] = data.stacks[fontstack];
        for (var i = 0; i < missing[range].length; i++) {
var glyphID = missing[range][i];
        var glyph = stack.glyphs[glyphID];
        var buffer = 3;
        rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
        if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
}
}
remaining--;
        if (!remaining) callback(undefined, result);
}
};
        function simpleGlyph(glyph) {
        return {
        advance: glyph.advance,
                left: glyph.left,
                top: glyph.top
        };
        }

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {

if (range * 256 >= 65280) return callback('gyphs > 65280 not supported');
        if (this.loading[fontstack] === undefined) this.loading[fontstack] = {};
        var loading = this.loading[fontstack];
        if (loading[range]) {
loading[range].push(callback);
} else {
loading[range] = [callback];
        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);
        getArrayBuffer(url, function(err, data) {
        var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
                for (var i = 0; i < loading[range].length; i++) {
        loading[range][i](err, range, glyphs);
        }
        delete loading[range];
        });
}
};
        function glyphUrl(fontstack, range, url, subdomains) {
        subdomains = subdomains || 'abc';
                return url
                .replace('{s}', subdomains[fontstack.length % subdomains.length])
                .replace('{fontstack}', fontstack)
                .replace('{range}', range);
        }

}, {"../util/ajax.js":76, "../util/glyphs.js":83, "../util/mapbox.js":84, "pbf":97}], 62:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js'),
        Anchor = require('../symbol/anchor.js');
        module.exports = interpolate;
        var minScale = 0.5;
        var minScaleArrays = {
        1: [minScale],
                2: [minScale, 2],
                4: [minScale, 4, 2, 4],
                8: [minScale, 8, 4, 8, 2, 8, 4, 8]
        };
        function interpolate(vertices, spacing, minScale, maxScale, tilePixelRatio, start) {

        if (minScale === undefined) minScale = 0;
                maxScale = Math.round(Math.max(Math.min(8, maxScale / 2), 1));
                spacing *= tilePixelRatio / maxScale;
                var minScales = minScaleArrays[maxScale];
                var len = minScales.length;
                var distance = 0,
                markedDistance = 0,
                added = start || 0;
                var points = [];
                for (var i = 0; i < vertices.length - 1; i++) {

        var a = vertices[i],
                b = vertices[i + 1];
                var segmentDist = a.dist(b),
                angle = b.angleTo(a);
                while (markedDistance + spacing < distance + segmentDist) {
        markedDistance += spacing;
                var t = (markedDistance - distance) / segmentDist,
                x = util.interp(a.x, b.x, t),
                y = util.interp(a.y, b.y, t),
                s = minScales[added % len];
                if (x >= 0 && x < 4096 && y >= 0 && y < 4096) {
        points.push(new Anchor(x, y, angle, s, i));
        }

        added++;
        }

        distance += segmentDist;
        }

        return points;
        }

}, {"../symbol/anchor.js":57, "../util/util.js":87}], 63:[function(require, module, exports){
'use strict';
        var Point = require('point-geometry');
        module.exports = {
        getIcon: getIcon,
                getGlyphs: getGlyphs
        };
        var minScale = 0.5; // underscale by 1 zoom level

        function getIcon(anchor, image, boxScale, line, props) {

        var x = image.width / 2 / image.pixelRatio;
                var y = image.height / 2 / image.pixelRatio;
                var dx = props['icon-offset'][0];
                var dy = props['icon-offset'][1];
                var x1 = (dx - x);
                var x2 = (dx + x);
                var y1 = (dy - y);
                var y2 = (dy + y);
                var tl = new Point(x1, y1);
                var tr = new Point(x2, y1);
                var br = new Point(x2, y2);
                var bl = new Point(x1, y2);
                var angle = props['icon-rotate'] * Math.PI / 180;
                if (anchor.segment !== undefined && props['icon-rotation-alignment'] !== 'viewport') {
        var next = line[anchor.segment];
                angle += - Math.atan2(next.x - anchor.x, next.y - anchor.y) + Math.PI / 2;
        }

        if (angle) {
        var sin = Math.sin(angle),
                cos = Math.cos(angle),
                matrix = [cos, - sin, sin, cos];
                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
                x1 = Math.min(tl.x, tr.x, bl.x, br.x);
                x2 = Math.max(tl.x, tr.x, bl.x, br.x);
                y1 = Math.min(tl.y, tr.y, bl.y, br.y);
                y2 = Math.max(tl.y, tr.y, bl.y, br.y);
        }
        var box = {
        x1: x1 * boxScale,
                x2: x2 * boxScale,
                y1: y1 * boxScale,
                y2: y2 * boxScale
        };
                var iconBox = {
                box: box,
                        anchor: anchor,
                        minScale: minScale,
                        maxScale: Infinity,
                        padding: props['icon-padding']
                };
                var icon = {
                tl: tl,
                        tr: tr,
                        br: br,
                        bl: bl,
                        tex: image,
                        angle: 0,
                        anchor: anchor,
                        minScale: minScale,
                        maxScale: Infinity
                };
                return {
                shapes: [icon],
                        boxes: [iconBox],
                        minScale: anchor.scale
                };
        }

function getGlyphs(anchor, origin, shaping, faces, boxScale, horizontal, line, props) {

var maxAngleDelta = props['text-max-angle'] * Math.PI / 180;
        var rotate = props['text-rotate'] * Math.PI / 180;
        var padding = props['text-padding'];
        var alongLine = props['text-rotation-alignment'] !== 'viewport';
        var keepUpright = props['text-keep-upright'];
        var glyphs = [],
        boxes = [];
        var buffer = 3;
        for (var k = 0; k < shaping.length; k++) {
var shape = shaping[k];
        var fontstack = faces[shape.fontstack];
        var glyph = fontstack.glyphs[shape.glyph];
        var rect = fontstack.rects[shape.glyph];
        if (!glyph) continue;
        if (!(rect && rect.w > 0 && rect.h > 0)) continue;
        var x = (origin.x + shape.x + glyph.left - buffer + rect.w / 2) * boxScale;
        var glyphInstances;
        if (anchor.segment !== undefined && alongLine) {
glyphInstances = [];
        getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, 1, maxAngleDelta);
        if (keepUpright) getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, - 1, maxAngleDelta);
} else {
glyphInstances = [{
anchor: anchor,
        offset: 0,
        angle: 0,
        maxScale: Infinity,
        minScale: minScale
}];
}

var x1 = origin.x + shape.x + glyph.left - buffer,
        y1 = origin.y + shape.y - glyph.top - buffer,
        x2 = x1 + rect.w,
        y2 = y1 + rect.h,
        otl = new Point(x1, y1),
        otr = new Point(x2, y1),
        obl = new Point(x1, y2),
        obr = new Point(x2, y2);
        var obox = {
        x1: boxScale * x1,
                y1: boxScale * y1,
                x2: boxScale * x2,
                y2: boxScale * y2
        };
        for (var i = 0; i < glyphInstances.length; i++) {

var instance = glyphInstances[i],
        tl = otl,
        tr = otr,
        bl = obl,
        br = obr,
        box = obox,
        // Clamp to -90/+90 degrees
        angle = instance.angle + rotate;
        if (angle) {
// Compute the transformation matrix.
var sin = Math.sin(angle),
        cos = Math.cos(angle),
        matrix = [cos, - sin, sin, cos];
        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);
}

// Prevent label from extending past the end of the line
var glyphMinScale = Math.max(instance.minScale, anchor.scale);
        // Remember the glyph for later insertion.
        glyphs.push({
        tl: tl,
                tr: tr,
                bl: bl,
                br: br,
                tex: rect,
                angle: (anchor.angle + rotate + instance.offset + 2 * Math.PI) % (2 * Math.PI),
                anchor: instance.anchor,
                minScale: glyphMinScale,
                maxScale: instance.maxScale
        });
        if (!instance.offset) { // not a flipped glyph
if (angle) {
// Calculate the rotated glyph's bounding box offsets from the anchor point.
box = {
x1: boxScale * Math.min(tl.x, tr.x, bl.x, br.x),
        y1: boxScale * Math.min(tl.y, tr.y, bl.y, br.y),
        x2: boxScale * Math.max(tl.x, tr.x, bl.x, br.x),
        y2: boxScale * Math.max(tl.y, tr.y, bl.y, br.y)
};
}
boxes.push({
box: box,
        anchor: instance.anchor,
        minScale: glyphMinScale,
        maxScale: instance.maxScale,
        padding: padding
});
}
}
}

// TODO avoid creating the boxes in the first place?
if (horizontal) boxes = [getMergedBoxes(boxes, anchor)];
        var minPlacementScale = anchor.scale;
        var minGlyphScale = Infinity;
        for (var m = 0; m < boxes.length; m++) {
minGlyphScale = Math.min(minGlyphScale, boxes[m].minScale);
}
minGlyphScale = Math.max(minPlacementScale, minScale);
        return {
        boxes: boxes,
                shapes: glyphs,
                minScale: minGlyphScale
        };
        }

function getSegmentGlyphs(glyphs, anchor, offset, line, segment, direction, maxAngleDelta) {
var upsideDown = direction < 0;
        if (offset < 0)  direction *= - 1;
        if (direction > 0) segment++;
        var newAnchor = anchor;
        var end = line[segment];
        var prevscale = Infinity;
        var prevAngle;
        offset = Math.abs(offset);
        var placementScale = anchor.scale;
        segment_loop:
        while (true) {
var dist = newAnchor.dist(end);
        var scale = offset / dist;
        var angle = - Math.atan2(end.x - newAnchor.x, end.y - newAnchor.y) + direction * Math.PI / 2;
        if (upsideDown) angle += Math.PI;
        // Don't place around sharp corners
        var angleDiff = (angle - prevAngle) % (2 * Math.PI);
        if (prevAngle && Math.abs(angleDiff) > maxAngleDelta) {
anchor.scale = prevscale;
        break;
}

glyphs.push({
anchor: newAnchor,
        offset: upsideDown ? Math.PI : 0,
        minScale: scale,
        maxScale: prevscale,
        angle: (angle + 2 * Math.PI) % (2 * Math.PI)
});
        if (scale <= placementScale) break;
        newAnchor = end;
        // skip duplicate nodes
        while (newAnchor.equals(end)) {
segment += direction;
        end = line[segment];
        if (!end) {
anchor.scale = scale;
        break segment_loop;
}
}

var unit = end.sub(newAnchor)._unit();
        newAnchor = newAnchor.sub(unit._mult(dist));
        prevscale = scale;
        prevAngle = angle;
}
}

function getMergedBoxes(glyphs, anchor) {
// Collision checks between rotating and fixed labels are relatively expensive,
// so we use one box per label, not per glyph for horizontal labels.

var mergedglyphs = {
box: { x1: Infinity, y1: Infinity, x2: - Infinity, y2: - Infinity },
        anchor: anchor,
        minScale: 0,
        padding: - Infinity
};
        var box = mergedglyphs.box;
        for (var m = 0; m < glyphs.length; m++) {
var gbox = glyphs[m].box;
        box.x1 = Math.min(box.x1, gbox.x1);
        box.y1 = Math.min(box.y1, gbox.y1);
        box.x2 = Math.max(box.x2, gbox.x2);
        box.y2 = Math.max(box.y2, gbox.y2);
        mergedglyphs.minScale = Math.max(mergedglyphs.minScale, glyphs[m].minScale);
        mergedglyphs.padding = Math.max(mergedglyphs.padding, glyphs[m].padding);
}
// for all horizontal labels, calculate bbox covering all rotated positions
var x12 = box.x1 * box.x1,
        y12 = box.y1 * box.y1,
        x22 = box.x2 * box.x2,
        y22 = box.y2 * box.y2,
        diag = Math.sqrt(Math.max(x12 + y12, x12 + y22, x22 + y12, x22 + y22));
        mergedglyphs.hBox = {
        x1: - diag,
                y1: - diag,
                x2: diag,
                y2: diag
        };
        return mergedglyphs;
        }

}, {"point-geometry":99}], 64:[function(require, module, exports){
'use strict';
        var resolveTokens = require('../util/token.js');
        module.exports = resolveText;
// For an array of features determine what glyph ranges need to be loaded
// and apply any text preprocessing. The remaining users of text should
// use the `textFeatures` key returned by this function rather than accessing
// feature text directly.
        function resolveText(features, info, glyphs) {
        var textFeatures = [];
                var codepoints = [];
                for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, info['text-field']);
                var hastext = false;
                if (!text) continue;
                text = text.toString();
                var transform = info['text-transform'];
                if (transform === 'uppercase') {
        text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
        text = text.toLocaleLowerCase();
        }

        for (var j = 0, jl = text.length; j < jl; j++) {
        if (text.charCodeAt(j) <= 65533) {
        codepoints.push(text.charCodeAt(j));
                hastext = true;
        }
        }
        // Track indexes of features with text.
        if (hastext) {
        textFeatures[i] = text;
        }
        }

        // get a list of unique codepoints we are missing
        codepoints = uniq(codepoints, glyphs);
                return {
                textFeatures: textFeatures,
                        codepoints: codepoints
                };
        }

function uniq(ids, alreadyHave) {
var u = [];
        var last;
        ids.sort(sortNumbers);
        for (var i = 0; i < ids.length; i++) {
if (ids[i] !== last) {
last = ids[i];
        if (!alreadyHave[last]) u.push(ids[i]);
}
}
return u;
        }

function sortNumbers(a, b) {
return a - b;
        }


}, {"../util/token.js":86}], 65:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js'),
        Point = require('point-geometry');
        module.exports = {
        rotationRange: rotationRange,
                mergeCollisions: mergeCollisions,
                rotatingFixedCollisions: rotatingFixedCollisions,
                rotatingRotatingCollisions: rotatingRotatingCollisions,
                cornerBoxCollisions: cornerBoxCollisions,
                circleEdgeCollisions: circleEdgeCollisions,
                getCorners: getCorners,
        };
        /*
         * Calculate the range a box conflicts with a second box
         */
                function rotationRange(inserting, blocker, scale) {

                var collisions, box;
                        var a = inserting;
                        var b = blocker;
                        // Instead of scaling the boxes, we move the anchors
                        var relativeAnchor = new Point(
                                (b.anchor.x - a.anchor.x) * scale,
                                (b.anchor.y - a.anchor.y) * scale);
                        // Generate a list of collision interval
                        if (a.hBox && b.hBox) {
                collisions = rotatingRotatingCollisions(a.box, b.box, relativeAnchor);
                } else if (a.hBox) {
                box = {
                x1: b.box.x1 + relativeAnchor.x,
                        y1: b.box.y1 + relativeAnchor.y,
                        x2: b.box.x2 + relativeAnchor.x,
                        y2: b.box.y2 + relativeAnchor.y
                };
                        collisions = rotatingFixedCollisions(a.box, box);
                } else if (b.hBox) {
                box = {
                x1: a.box.x1 - relativeAnchor.x,
                        y1: a.box.y1 - relativeAnchor.y,
                        x2: a.box.x2 - relativeAnchor.x,
                        y2: a.box.y2 - relativeAnchor.y
                };
                        collisions = rotatingFixedCollisions(b.box, box);
                } else {
                collisions = [];
                }

                // Find and return the continous are around 0 where there are no collisions
                return mergeCollisions(collisions, blocker.placementRange);
                }

        /*
         * Combine an array of collision ranges to form a continuous
         * range that includes 0. Collisions within the ignoreRange are ignored
         */
        function mergeCollisions(collisions, ignoreRange) {

        // find continuous interval including 0 that doesn't have any collisions
        var min = 2 * Math.PI;
                var max = 0;
                for (var i = 0; i < collisions.length; i++) {
        var collision = collisions[i];
                var entryOutside = ignoreRange[0] <= collision[0] && collision[0] <= ignoreRange[1];
                var exitOutside = ignoreRange[0] <= collision[1] && collision[1] <= ignoreRange[1];
                if (entryOutside && exitOutside) {
        // no collision, since blocker is out of range
        } else if (entryOutside) {
        min = Math.min(min, ignoreRange[1]);
                max = Math.max(max, collision[1]);
        } else if (exitOutside) {
        min = Math.min(min, collision[0]);
                max = Math.max(max, ignoreRange[0]);
        } else {
        min = Math.min(min, collision[0]);
                max = Math.max(max, collision[1]);
        }
        }

        return [min, max];
        }

        /*
         *  Calculate collision ranges for two rotating boxes.
         */

        var horizontal = new Point(1, 0);
                function rotatingRotatingCollisions(a, b, anchorToAnchor) {
                var d = anchorToAnchor.mag();
                        var angleBetweenAnchors = anchorToAnchor.angleWith(horizontal);
                        var c = [],
                        collisions = [],
                        k;
                        // Calculate angles at which collisions may occur
                        // top/bottom
                        c[0] = Math.asin((a.y2 - b.y1) / d);
                        c[1] = Math.asin((a.y2 - b.y1) / d) + Math.PI;
                        c[2] = 2 * Math.PI - Math.asin(( - a.y1 + b.y2) / d);
                        c[3] = Math.PI - Math.asin(( - a.y1 + b.y2) / d);
                        // left/right
                        c[4] = 2 * Math.PI - Math.acos((a.x2 - b.x1) / d);
                        c[5] = Math.acos((a.x2 - b.x1) / d);
                        c[6] = Math.PI - Math.acos(( - a.x1 + b.x2) / d);
                        c[7] = Math.PI + Math.acos(( - a.x1 + b.x2) / d);
                        var rl = a.x2 - b.x1;
                        var lr = - a.x1 + b.x2;
                        var tb = a.y2 - b.y1;
                        var bt = - a.y1 + b.y2;
                        // Calculate the distance squared of the diagonal which will be used
                        // to check if the boxes are close enough for collisions to occur at each angle
                        // todo, triple check these
                        var e = [];
                        // top/bottom
                        e[0] = rl * rl + tb * tb;
                        e[1] = lr * lr + tb * tb;
                        e[2] = rl * rl + bt * bt;
                        e[3] = lr * lr + bt * bt;
                        // left/right
                        e[4] = rl * rl + tb * tb;
                        e[5] = rl * rl + bt * bt;
                        e[6] = lr * lr + bt * bt;
                        e[7] = lr * lr + tb * tb;
                        c = c.filter(function(x, i) {
                        // Check if they are close enough to collide
                        return !isNaN(x) && d * d <= e[i];
                        }).map(function(x) {
                // So far, angles have been calulated as relative to the vector between anchors.
                // Convert the angles to angles from north.
                return (x + angleBetweenAnchors + 2 * Math.PI) % (2 * Math.PI);
                });
                        // Group the collision angles by two
                        // each group represents a range where the two boxes collide
                        c.sort();
                        for (k = 0; k < c.length; k += 2) {
                collisions.push([c[k], c[k + 1]]);
                }

                return collisions;
                }

        /*
         *  Calculate collision ranges for a rotating box and a fixed box;
         */
        function rotatingFixedCollisions(rotating, fixed) {

        var cornersR = getCorners(rotating);
                var cornersF = getCorners(fixed);
                // A collision occurs when, and only at least one corner from one of the boxes
                // is within the other box. Calculate these ranges for each corner.

                var collisions = [];
                for (var i = 0; i < 4; i++) {
        cornerBoxCollisions(collisions, cornersR[i], cornersF);
                cornerBoxCollisions(collisions, cornersF[i], cornersR, true);
        }

        return collisions;
        }


        /*
         *  Calculate the ranges for which the corner,
         *  rotatated around the anchor, is within the box;
         */
        function cornerBoxCollisions(collisions, corner, boxCorners, flip) {
        var radius = corner.mag(),
                angles = [];
                // Calculate the points at which the corners intersect with the edges
                for (var i = 0, j = 3; i < 4; j = i++) {
        circleEdgeCollisions(angles, corner, radius, boxCorners[j], boxCorners[i]);
        }

        if (angles.length % 2 !== 0) {
        // TODO fix
        // This could get hit when a point intersects very close to a corner
        // and floating point issues cause only one of the entry or exit to be counted
        throw('expecting an even number of intersections');
        }

        angles.sort();
                // Group by pairs, where each represents a range where a collision occurs
                for (var k = 0; k < angles.length; k += 2) {
        collisions[k / 2] = flip ?
                [2 * Math.PI - angles[k + 1], 2 * Math.PI - angles[k]] : // reflect an angle around 0 degrees
                [angles[k], angles[k + 1]];
        }

        return collisions;
        }

        /*
         * Return the intersection points of a circle and a line segment;
         */
        function circleEdgeCollisions(angles, corner, radius, p1, p2) {

        var edgeX = p2.x - p1.x;
                var edgeY = p2.y - p1.y;
                var a = edgeX * edgeX + edgeY * edgeY;
                var b = (edgeX * p1.x + edgeY * p1.y) * 2;
                var c = p1.x * p1.x + p1.y * p1.y - radius * radius;
                var discriminant = b * b - 4 * a * c;
                // a collision exists only if line intersects circle at two points
                if (discriminant > 0) {
        var x1 = ( - b - Math.sqrt(discriminant)) / (2 * a);
                var x2 = ( - b + Math.sqrt(discriminant)) / (2 * a);
                // only add points if within line segment
                // hack to handle floating point representations of 0 and 1
                if (0 < x1 && x1 < 1) {
        angles.push(getAngle(p1, p2, x1, corner));
        }

        if (0 < x2 && x2 < 1) {
        angles.push(getAngle(p1, p2, x2, corner));
        }
        }

        return angles;
        }

        function getAngle(p1, p2, d, corner) {
        return ( - corner.angleWithSep(
                util.interp(p1.x, p2.x, d),
                util.interp(p1.y, p2.y, d)) + 2 * Math.PI) % (2 * Math.PI);
        }

        function getCorners(a) {
        return [
                new Point(a.x1, a.y1),
                new Point(a.x1, a.y2),
                new Point(a.x2, a.y2),
                new Point(a.x2, a.y1)
        ];
        }

        }, {"../util/util.js":87, "point-geometry":99}], 66:[function(require, module, exports){
'use strict';
        module.exports = {
        shape: shape
        };
        function shape(text, name, stacks, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {
        var glyphs = stacks[name].glyphs;
                var glyph;
                var shaping = [];
                var x = translate[0];
                var y = translate[1];
                var id;
                for (var i = 0; i < text.length; i++) {
        id = text.charCodeAt(i);
                glyph = glyphs[id];
                if (id === 0 || !glyph) continue;
                shaping.push({
                fontstack: name,
                        glyph: id,
                        x: x,
                        y: y
                });
                x += glyph.advance + spacing;
        }

        if (!shaping.length) return false;
                shaping = linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify);
                return shaping;
        }

var breakable = { 32: true }; // Currently only breaks at regular spaces

        function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify) {
        var lastSafeBreak = null;
                var lengthBeforeCurrentLine = 0;
                var lineStartIndex = 0;
                var line = 0;
                var maxLineLength = 0;
                if (maxWidth) {
        for (var i = 0; i < shaping.length; i++) {
        var shape = shaping[i];
                shape.x -= lengthBeforeCurrentLine;
                shape.y += lineHeight * line;
                if (shape.x > maxWidth && lastSafeBreak !== null) {

        var lineLength = shaping[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);
                for (var k = lastSafeBreak + 1; k <= i; k++) {
        shaping[k].y += lineHeight;
                shaping[k].x -= lineLength;
        }

        if (justify) {
        justifyLine(shaping, glyphs, lineStartIndex, lastSafeBreak - 1, justify);
        }

        lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
        }

        if (breakable[shape.glyph]) {
        lastSafeBreak = i;
        }
        }
        }

        maxLineLength = maxLineLength || shaping[shaping.length - 1].x;
                justifyLine(shaping, glyphs, lineStartIndex, shaping.length - 1, justify);
                align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line);
                return shaping;
        }

function justifyLine(shaping, glyphs, start, end, justify) {
var lastAdvance = glyphs[shaping[end].glyph].advance;
        var lineIndent = (shaping[end].x + lastAdvance) * justify;
        for (var j = start; j <= end; j++) {
shaping[j].x -= lineIndent;
}

}

function align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line) {
var shiftX = (justify - horizontalAlign) * maxLineLength;
        var shiftY = ( - verticalAlign * (line + 1) + 0.5) * lineHeight;
        for (var j = 0; j < shaping.length; j++) {
shaping[j].x += shiftX;
        shaping[j].y += shiftY;
}
}

}, {}], 67:[function(require, module, exports){
'use strict';
        var Control = require('./control.js'),
        DOM = require('../../util/dom.js'),
        util = require('../../util/util.js');
        module.exports = Attribution;
        function Attribution() {}

Attribution.prototype = util.inherit(Control, {
onAdd: function(map) {
var className = 'mapboxgl-ctrl-attrib',
        container = this._container = DOM.create('div', className, map.container);
        this._update();
        map.on('source.add', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));
        return container;
},
        _update: function() {
        var attrObj = {};
                for (var id in this._map.sources) {
        var source = this._map.sources[id];
                if (source.tileJSON && source.tileJSON.attribution) {
        attrObj[source.tileJSON.attribution] = true;
        }
        }
        var attributions = [];
                for (var i in attrObj) {
        attributions.push(i);
        }
        this._container.innerHTML = attributions.join(' | ');
                this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
                this._updateEditLink();
        },
        _updateEditLink: function() {
        if (this._editLink) {
        var center = this._map.getCenter();
                this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
        }
});
        }, {"../../util/dom.js":81, "../../util/util.js":87, "./control.js":68}], 68:[function(require, module, exports){
'use strict';
        module.exports = Control;
        function Control() {}

Control.prototype = {
addTo: function(map) {
this._map = map;
        this._container = this.onAdd(map);
        return this;
},
        remove: function () {
        this._container.parentNode.removeChild(this._container);
                if (this.onRemove) this.onRemove(this._map);
                this._map = null;
                return this;
        }
};
        }, {}], 69:[function(require, module, exports){
'use strict';
        var Control = require('./control.js'),
        DOM = require('../../util/dom.js'),
        util = require('../../util/util.js');
        module.exports = Navigation;
        function Navigation() {}

Navigation.prototype = util.inherit(Control, {
onAdd: function(map) {
var className = 'mapboxgl-ctrl-nav';
        var container = this._container = DOM.create('div', className, map.container);
        this._zoomInButton = this._createButton(className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-compass', map.resetNorth.bind(map));
        var compassCanvas = this._compassCanvas = DOM.create('canvas', className + '-compass-canvas', this._compass);
        compassCanvas.style.cssText = 'width:26px; height:26px;';
        compassCanvas.width = 26 * 2;
        compassCanvas.height = 26 * 2;
        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);
        this._compassCtx = compassCanvas.getContext('2d');
        map.on('rotate', this._drawNorth.bind(this));
        this._drawNorth();
        return container;
},
        _onCompassDown: function(e) {
        DOM.disableDrag();
                document.addEventListener('mousemove', this._onCompassMove);
                document.addEventListener('mouseup', this._onCompassUp);
                this._prevX = e.screenX;
                e.stopPropagation();
        },
        _onCompassMove: function(e) {
        var x = e.screenX,
                d = x < 2 ? - 5 : // left edge of the screen, continue rotating
                x > window.screen.width - 2 ? 5 : // right edge
                (x - this._prevX) / 4;
                this._map.setBearing(this._map.getBearing() - d);
                this._prevX = e.screenX;
                e.preventDefault();
        },
        _onCompassUp: function() {
        document.removeEventListener('mousemove', this._onCompassMove);
                document.removeEventListener('mouseup', this._onCompassUp);
                DOM.enableDrag();
        },
        _createButton: function(className, fn) {
        var a = DOM.create('a', className, this._container);
                a.href = '#';
                a.addEventListener('click', function(e) {
                fn();
                        e.preventDefault();
                        e.stopPropagation();
                });
                a.addEventListener('dblclick', function(e) {
                e.preventDefault();
                        e.stopPropagation();
                });
                return a;
        },
        _drawNorth: function() {
        var rad = 20,
                width = 8,
                center = 26,
                angle = this._map.transform.angle + (Math.PI / 2),
                ctx = this._compassCtx;
                this._compassCanvas.width = this._compassCanvas.width;
                ctx.translate(center, center);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.fillStyle = '#000';
                ctx.lineTo(0, - width);
                ctx.lineTo( - rad, 0);
                ctx.lineTo(0, width);
                ctx.fill();
                ctx.beginPath();
                ctx.fillStyle = '#bbb';
                ctx.moveTo(0, 0);
                ctx.lineTo(0, width);
                ctx.lineTo(rad, 0);
                ctx.lineTo(0, - width);
                ctx.fill();
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.moveTo(0, - width);
                ctx.lineTo(0, width);
                ctx.stroke();
        }
});
        }, {"../../util/dom.js":81, "../../util/util.js":87, "./control.js":68}], 70:[function(require, module, exports){
'use strict';
        var util = require('../util/util.js'),
        browser = require('../util/browser.js'),
        LatLng = require('../geo/latlng.js'),
        LatLngBounds = require('../geo/latlngbounds.js'),
        Point = require('point-geometry');
        util.extend(exports, {
        isEasing: function () {
        return !!this._abortFn;
        },
                stop: function () {
                if (this._abortFn) {
                this._abortFn.call(this);
                        delete this._abortFn;
                        this._finishFn.call(this);
                        delete this._finishFn;
                }
                return this;
                },
                _ease: function(frame, finish, options) {
                this._finishFn = finish;
                        this._abortFn = browser.timed(function (t) {
                        frame.call(this, options.easing(t));
                                if (t === 1) {
                        delete this._abortFn;
                                this._finishFn.call(this);
                                delete this._finishFn;
                        }
                        }, options.animate === false ? 0 : options.duration, this);
                },
                panBy: function(offset, options) {
                this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult( - 1)}, options));
                        return this;
                },
                panTo: function(latlng, options) {
                this.stop();
                        latlng = LatLng.convert(latlng);
                        options = util.extend({
                        duration: 500,
                                easing: util.ease,
                                offset: [0, 0]
                        }, options);
                        var tr = this.transform,
                        offset = Point.convert(options.offset).rotate( - tr.angle),
                        from = tr.point,
                        to = tr.project(latlng).sub(offset);
                        if (!options.noMoveStart) {
                this.fire('movestart');
                }

                this._ease(function(k) {
                tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                        this._move();
                }, function() {
                this.fire('moveend');
                }, options);
                        return this;
                },
                // Zooms to a certain zoom level with easing.
                zoomTo: function(zoom, options) {
                this.stop();
                        options = util.extend({
                        duration: 500
                        }, options);
                        options.easing = this._updateEasing(options.duration, zoom, options.easing);
                        var tr = this.transform,
                        around = tr.center,
                        startZoom = tr.zoom;
                        if (options.around) {
                around = LatLng.convert(options.around);
                } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
                }

                if (options.animate === false) options.duration = 0;
                        if (!this.zooming) {
                this.zooming = true;
                        this.fire('movestart');
                }

                this._ease(function(k) {
                tr.setZoomAround(util.interp(startZoom, zoom, k), around);
                        this.style.animationLoop.set(300); // text fading
                        this._move(true);
                }, function() {
                this.ease = null;
                        if (options.duration >= 200) {
                this.zooming = false;
                        this.fire('moveend');
                }
                }, options);
                        if (options.duration < 200) {
                clearTimeout(this._onZoomEnd);
                        this._onZoomEnd = setTimeout(function() {
                        this.zooming = false;
                                this._rerender();
                                this.fire('moveend');
                        }.bind(this), 200);
                }

                return this;
                },
                zoomIn: function(options) {
                this.zoomTo(this.getZoom() + 1, options);
                },
                zoomOut: function(options) {
                this.zoomTo(this.getZoom() - 1, options);
                },
                rotateTo: function(bearing, options) {
                this.stop();
                        options = util.extend({
                        duration: 500,
                                easing: util.ease
                        }, options);
                        var tr = this.transform,
                        start = this.getBearing(),
                        around = tr.center;
                        if (options.around) {
                around = LatLng.convert(options.around);
                } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
                }

                this.rotating = true;
                        this.fire('movestart');
                        this._ease(function(k) {
                        tr.setBearingAround(util.interp(start, bearing, k), around);
                                this._move(false, true);
                        }, function() {
                        this.rotating = false;
                                this.fire('moveend');
                        }, options);
                        return this;
                },
                resetNorth: function(options) {
                return this.rotateTo(0, util.extend({duration: 1000}, options));
                },
                fitBounds: function(bounds, options) {

                options = util.extend({
                padding: 0,
                        offset: [0, 0],
                        maxZoom: Infinity
                }, options);
                        bounds = LatLngBounds.convert(bounds);
                        var offset = Point.convert(options.offset),
                        tr = this.transform,
                        nw = tr.project(bounds.getNorthWest()),
                        se = tr.project(bounds.getSouthEast()),
                        size = se.sub(nw),
                        center = tr.unproject(nw.add(se).div(2)),
                        scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
                        scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y,
                        zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
                        return options.linear ?
                        this.easeTo(center, zoom, 0, options) :
                        this.flyTo(center, zoom, 0, options);
                },
                easeTo: function(latlng, zoom, bearing, options) {

                options = util.extend({
                offset: [0, 0],
                        duration: 500,
                        easing: util.ease
                }, options);
                        var tr = this.transform,
                        offset = Point.convert(options.offset).rotate( - tr.angle),
                        startZoom = this.getZoom(),
                        startBearing = this.getBearing();
                        latlng = LatLng.convert(latlng);
                        zoom = zoom === undefined ? startZoom : zoom;
                        bearing = bearing === undefined ? startBearing : bearing;
                        var scale = tr.zoomScale(zoom - startZoom),
                        from = tr.point,
                        to = latlng ? tr.project(latlng).sub(offset.div(scale)) : tr.point,
                        around;
                        if (zoom !== startZoom) {
                around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));
                        this.zooming = true;
                }
                if (startBearing !== bearing) this.rotating = true;
                        this.fire('movestart');
                        this._ease(function (k) {
                        if (zoom !== startZoom) {
                        tr.setZoomAround(util.interp(startZoom, zoom, k), around);
                        } else {
                        tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                        }

                        if (bearing !== startBearing) {
                        tr.bearing = util.interp(startBearing, bearing, k);
                        }

                        this.style.animationLoop.set(300); // text fading
                                this._move(zoom !== startZoom, bearing !== startBearing);
                        }, function() {
                        this.zooming = false;
                                this.rotating = false;
                                this.fire('moveend');
                        }, options);
                        return this;
                },
                flyTo: function(latlng, zoom, bearing, options) {

                options = util.extend({
                offset: [0, 0],
                        speed: 1.2,
                        curve: 1.42,
                        easing: util.ease
                }, options);
                        latlng = LatLng.convert(latlng);
                        var offset = Point.convert(options.offset),
                        tr = this.transform,
                        startZoom = this.getZoom(),
                        startBearing = this.getBearing();
                        zoom = zoom === undefined ? startZoom : zoom;
                        bearing = bearing === undefined ? startBearing : bearing;
                        var scale = tr.zoomScale(zoom - startZoom),
                        from = tr.point,
                        to = tr.project(latlng).sub(offset.div(scale));
                        if (options.animate === false) {
                return this.setView(latlng, zoom, bearing);
                }

                var startWorldSize = tr.worldSize,
                        rho = options.curve,
                        V = options.speed,
                        w0 = Math.max(tr.width, tr.height),
                        w1 = w0 / scale,
                        u1 = to.sub(from).mag(),
                        rho2 = rho * rho;
                        function r(i) {
                        var b = (w1 * w1 - w0 * w0 + (i ? - 1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
                                return Math.log(Math.sqrt(b * b + 1) - b);
                        }

                function sinh(n) { return (Math.exp(n) - Math.exp( - n)) / 2; }
                function cosh(n) { return (Math.exp(n) + Math.exp( - n)) / 2; }
                function tanh(n) { return sinh(n) / cosh(n); }

                var r0 = r(0),
                        w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
                        u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
                        S = (r(1) - r0) / rho;
                        if (Math.abs(u1) < 0.000001) {
                if (Math.abs(w0 - w1) < 0.000001) return this;
                        var k = w1 < w0 ? - 1 : 1;
                        S = Math.abs(Math.log(w1 / w0)) / rho;
                        u = function() { return 0; };
                        w = function(s) { return Math.exp(k * rho * s); };
                }

                options.duration = 1000 * S / V;
                        this.zooming = true;
                        if (startBearing != bearing) this.rotating = true;
                        this.fire('movestart');
                        this._ease(function (k) {
                        var s = k * S,
                                us = u(s);
                                tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
                                tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);
                                if (bearing !== startBearing) {
                        tr.bearing = util.interp(startBearing, bearing, k);
                        }

                        this.style.animationLoop.set(300); // text fading

                                this._move(true, bearing !== startBearing);
                        }, function() {
                        this.zooming = false;
                                this.rotating = false;
                                this.fire('moveend');
                        }, options);
                        return this;
                },
                _updateEasing: function(duration, zoom, bezier) {
                var easing;
                        if (this.ease) {
                var ease = this.ease,
                        t = (Date.now() - ease.start) / ease.duration,
                        speed = ease.easing(t + 0.01) - ease.easing(t),
                        // Quick hack to make new bezier that is continuous with last
                        x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                        y = Math.sqrt(0.27 * 0.27 - x * x);
                        easing = util.bezier(x, y, 0.25, 1);
                } else {
                easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
                }

                // store information on current easing
                this.ease = {
                start: (new Date()).getTime(),
                        to: Math.pow(2, zoom),
                        duration: duration,
                        easing: easing
                };
                        return easing;
                }
        });
        }, {"../geo/latlng.js":17, "../geo/latlngbounds.js":18, "../util/browser.js":77, "../util/util.js":87, "point-geometry":99}], 71:[function(require, module, exports){
'use strict';
        var Interaction = require('./interaction.js');
        var Point = require('point-geometry');
        var util = require('../util/util.js');
        module.exports = Handlers;
        function Handlers(map) {

        var rotateEnd;
                var inertiaLinearity = 0.2,
                inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1);
                this.interaction = new Interaction(map.container)
                .on('click', function(e) {
                map.fire('click', e);
                })
                .on('hover', function(e) {
                map.fire('hover', e);
                })
                .on('down', function () {
                map.fire('movestart');
                })
                .on('resize', function() {
                map.stop();
                        map.resize();
                        map.update();
                })
                .on('pan', function(e) {
                map.stop();
                        map.transform.panBy(e.offset);
                        map._move();
                })
                .on('panend', function(e) {
                if (!e.inertia) map.fire('moveend');
                        else {
                        // convert velocity to px/s & adjust for increased initial animation speed when easing out
                        var velocity = e.inertia.mult(1000 * inertiaLinearity),
                                speed = velocity.mag();
                                var maxSpeed = 4000; // px/s

                                if (speed >= maxSpeed) {
                        speed = maxSpeed;
                                velocity._unit()._mult(maxSpeed);
                        }

                        var deceleration = 8000, // px/s^2
                                duration = speed / (deceleration * inertiaLinearity),
                                offset = velocity.mult( - duration / 2).round();
                                map.panBy(offset, {
                                duration: duration * 1000,
                                        easing: inertiaEasing,
                                        noMoveStart: true
                                });
                        }
                })
                .on('zoom', function(e) {
                // Scale by sigmoid of scroll wheel delta.
                var scale = 2 / (1 + Math.exp( - Math.abs(e.delta / 100)));
                        if (e.delta < 0 && scale !== 0) scale = 1 / scale;
                        var fromScale = map.ease && isFinite(e.delta) ? map.ease.to : map.transform.scale,
                        duration = !isFinite(e.delta) ? 800 : e.source == 'trackpad' ? 0 : 300;
                        map.zoomTo(map.transform.scaleZoom(fromScale * scale), {
                        duration: duration,
                                around: map.unproject(e.point)
                        });
                })
                .on('rotate', function(e) {
                var center = map.transform.centerPoint, // Center of rotation
                        startToCenter = e.start.sub(center),
                        startToCenterDist = startToCenter.mag();
                        // If the first click was too close to the center, move the center of rotation by 200 pixels
                        // in the direction of the click.
                        if (startToCenterDist < 200) {
                center = e.start.add(new Point( - 200, 0)._rotate(startToCenter.angle()));
                }

                var bearingDiff = e.prev.sub(center).angleWith(e.current.sub(center)) / Math.PI * 180;
                        map.transform.bearing = map.getBearing() - bearingDiff;
                        map._move(false, true);
                        window.clearTimeout(rotateEnd);
                        rotateEnd = window.setTimeout(function() {
                        map.rotating = false;
                                map._rerender();
                        }, 200);
                });
        }

}, {"../util/util.js":87, "./interaction.js":73, "point-geometry":99}], 72:[function(require, module, exports){
'use strict';
        module.exports = Hash;
        var util = require('../util/util.js');
        function Hash(map) {
        this.map = map;
                window.addEventListener('hashchange', this.onhash.bind(this), false);
                map.on('move', util.debounce(this.updateHash.bind(this), 100));
        }

Hash.prototype = {
onhash: function() {
var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
this.map.setView([ + loc[1], + loc[2]], + loc[0], + (loc[3] || 0));
        return true;
}
return false;
},
        updateHash: function() {
        var center = this.map.getCenter(),
                zoom = this.map.getZoom(),
                bearing = this.map.getBearing(),
                precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),
                hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');
                window.history.replaceState('', '', hash);
        }
};
        }, {"../util/util.js":87}], 73:[function(require, module, exports){
'use strict';
        var Evented = require('../util/evented.js'),
        browser = require('../util/browser.js'),
        Point = require('point-geometry');
        module.exports = Interaction;
        function Interaction(el) {
        var interaction = this;
                if (!el) return;
                var rotating = false,
                panned = false,
                firstPos = null,
                pos = null,
                inertia = null,
                now;
                function mousePos(e) {
                var rect = el.getBoundingClientRect();
                        return new Point(
                                e.clientX - rect.left - el.clientLeft,
                                e.clientY - rect.top - el.clientTop);
                }

        el.addEventListener('contextmenu', function(ev) {
        rotating = true;
                firstPos = pos = mousePos(ev);
                ev.preventDefault();
        }, false);
                el.addEventListener('mousedown', onmousedown, false);
                document.addEventListener('mouseup', onmouseup, false);
                document.addEventListener('mousemove', onmousemove, false);
                el.addEventListener('click', onclick, false);
                scrollwheel(zoom);
                el.addEventListener('dblclick', ondoubleclick, false);
                window.addEventListener('resize', resize, false);
                function zoom(type, delta, point) {
                interaction.fire('zoom', {
                source: type,
                        delta: delta,
                        point: point
                });
                        inertia = null;
                        now = null;
                }

        function click(point) {
        interaction.fire('click', {point: point});
        }

        function hover(point) {
        interaction.fire('hover', {point: point});
        }

        function pan(point) {
        if (pos) {
        var offset = pos.sub(point);
                interaction.fire('pan', {offset: offset});
                // add an averaged version of this movement to the inertia vector
                if (inertia) {
        var duration = Date.now() - now;
                // sometimes it's 0 after some erratic paning
                if (duration) {
        var time = duration + now;
                inertia.push([time, point]);
                while (inertia.length > 2 && time - inertia[0][0] > 100) inertia.shift();
        }

        } else {
        inertia = [];
        }
        now = Date.now();
                pos = point;
        }
        }

        function resize() {
        interaction.fire('resize');
        }

        function rotate(point) {
        if (pos) {
        interaction.fire('rotate', {
        start: firstPos,
                prev: pos,
                current: point
        });
                pos = point;
        }
        }

        function onmousedown(ev) {
        firstPos = pos = mousePos(ev);
                interaction.fire('down');
        }

        function onmouseup() {
        panned = pos && firstPos && (pos.x != firstPos.x || pos.y != firstPos.y);
                rotating = false;
                pos = null;
                if (inertia && inertia.length >= 2 && now > Date.now() - 100) {
        var last = inertia[inertia.length - 1],
                first = inertia[0],
                velocity = last[1].sub(first[1]).div(last[0] - first[0]);
                interaction.fire('panend', {inertia: velocity});
        } else interaction.fire('panend');
                inertia = null;
                now = null;
        }

        function onmousemove(ev) {
        var point = mousePos(ev);
                if (rotating) { rotate(point); }
        else if (pos) pan(point);
                else {
                var target = ev.toElement;
                        while (target && target != el && target.parentNode) target = target.parentNode;
                        if (target == el) {
                hover(point);
                }
                }
        }

        function onclick(ev) {
        if (!panned) click(mousePos(ev));
        }

        function ondoubleclick(ev) {
        zoom('wheel', Infinity * (ev.shiftKey ? - 1 : 1), mousePos(ev));
                ev.preventDefault();
        }

        function scrollwheel(callback) {
        var firefox = /Firefox/i.test(navigator.userAgent);
                var safari = /Safari/i.test(navigator.userAgent) && !/Chrom(ium|e)/i.test(navigator.userAgent);
                var time = window.performance || Date;
                el.addEventListener('wheel', wheel, false);
                el.addEventListener('mousewheel', mousewheel, false);
                var lastEvent = 0;
                var type = null;
                var typeTimeout = null;
                var initialValue = null;
                function scroll(value, ev) {
                var stamp = time.now();
                        var timeDelta = stamp - lastEvent;
                        lastEvent = stamp;
                        var point = mousePos(ev);
                        if (value !== 0 && (value % 4.000244140625) === 0) {
                // This one is definitely a mouse wheel event.
                type = 'wheel';
                } else if (value !== 0 && Math.abs(value) < 4) {
                // This one is definitely a trackpad event because it is so small.
                type = 'trackpad';
                } else if (timeDelta > 400) {
                // This is likely a new scroll action.
                type = null;
                        initialValue = value;
                        // Start a timeout in case this was a singular event, and dely it
                        // by up to 40ms.
                        typeTimeout = setTimeout(function() {
                        type = 'wheel';
                                callback(type, - initialValue, point);
                        }, 40);
                } else if (type === null) {
                // This is a repeating event, but we don't know the type of event
                // just yet. If the delta per time is small, we assume it's a
                // fast trackpad; otherwise we switch into wheel mode.
                type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';
                        // Make sure our delayed event isn't fired again, because we
                        // accumulate the previous event (which was less than 40ms ago) into
                        // this event.
                        if (typeTimeout) {
                clearTimeout(typeTimeout);
                        typeTimeout = null;
                        value += initialValue;
                }
                }

                // Only fire the callback if we actually know what type of scrolling
                // device the user uses.
                if (type !== null) {
                callback(type, - value, point);
                }
                }

        function wheel(e) {
        var deltaY = e.deltaY;
                // Firefox doubles the values on retina screens...
                if (firefox && e.deltaMode == window.WheelEvent.DOM_DELTA_PIXEL) deltaY /= browser.devicePixelRatio;
                if (e.deltaMode == window.WheelEvent.DOM_DELTA_LINE) deltaY *= 40;
                scroll(deltaY, e);
                e.preventDefault();
        }

        function mousewheel(e) {
        var deltaY = - e.wheelDeltaY;
                if (safari) deltaY = deltaY / 3;
                scroll(deltaY, e);
                e.preventDefault();
        }
        }
        }

Interaction.prototype = Object.create(Evented);
        }, {"../util/browser.js":77, "../util/evented.js":82, "point-geometry":99}], 74:[function(require, module, exports){
'use strict';
        var Dispatcher = require('../util/dispatcher.js'),
        Canvas = require('../util/canvas.js'),
        util = require('../util/util.js'),
        browser = require('../util/browser.js'),
        ajax = require('../util/ajax.js'),
        Evented = require('../util/evented.js'),
        Style = require('../style/style.js'),
        AnimationLoop = require('../style/animationloop.js'),
        GLPainter = require('../render/painter.js'),
        Transform = require('../geo/transform.js'),
        Hash = require('./hash.js'),
        Handlers = require('./handlers.js'),
        Source = require('../source/source.js'),
        Easings = require('./easings.js'),
        LatLng = require('../geo/latlng.js'),
        LatLngBounds = require('../geo/latlngbounds.js'),
        Point = require('point-geometry'),
        GlyphSource = require('../symbol/glyphsource.js'),
        Attribution = require('./control/attribution.js');
// allow redefining Map here (jshint thinks it's global)
// jshint -W079

        var Map = module.exports = function(options) {

        options = this.options = util.inherit(this.options, options);
                this.animationLoop = new AnimationLoop();
                this.transform = new Transform(options.minZoom, options.maxZoom);
                this.hash = options.hash && new Hash(this);
                if (options.maxBounds) {
        var b = LatLngBounds.convert(options.maxBounds);
                this.transform.latRange = [b.getSouth(), b.getNorth()];
                this.transform.lngRange = [b.getWest(), b.getEast()];
        }

        this._onStyleChange = this._onStyleChange.bind(this);
                this._updateBuckets = this._updateBuckets.bind(this);
                this.render = this.render.bind(this);
                this._setupContainer();
                this._setupPainter();
                this.handlers = options.interactive && new Handlers(this);
                this.dispatcher = new Dispatcher(Math.max(options.numWorkers, 1), this);
                // don't set position from options if set through hash
                if (!this.hash || !this.hash.onhash()) {
        this.setView(options.center, options.zoom, options.bearing);
        }

        this.sources = {};
                this.stacks = {};
                this.resize();
                if (typeof options.style === 'object') {
        this.setStyle(options.style);
        } else if (typeof options.style === 'string') {
        ajax.getJSON(options.style, function (err, data) {
        if (err) throw err;
                this.setStyle(data);
        }.bind(this));
        }

        if (options.attributionControl) this.addControl(new Attribution());
        };
        util.extend(Map.prototype, Evented);
        util.extend(Map.prototype, Easings);
        util.extend(Map.prototype, {

        options: {
        center: [0, 0],
                zoom: 0,
                bearing: 0,
                minZoom: 0,
                maxZoom: 20,
                numWorkers: browser.hardwareConcurrency - 1,
                interactive: true,
                hash: false,
                attributionControl: true
        },
                addSource: function(id, source) {
                this.sources[id] = source;
                        source.id = id;
                        if (source.onAdd) {
                source.onAdd(this);
                }
                if (source.enabled) source.fire('source.add', {source: source});
                        return this;
                },
                removeSource: function(id) {
                var source = this.sources[id];
                        if (source.onRemove) {
                source.onRemove(this);
                }
                delete this.sources[id];
                        return this.fire('source.remove', {source: source});
                },
                addControl: function(control) {
                control.addTo(this);
                        return this;
                },
                // Set the map's center, zoom, and bearing
                setView: function(center, zoom, bearing) {
                this.stop();
                        var tr = this.transform,
                        zoomChanged = tr.zoom !== + zoom,
                        bearingChanged = tr.bearing !== + bearing;
                        tr.center = LatLng.convert(center);
                        tr.zoom = + zoom;
                        tr.bearing = + bearing;
                        return this
                        .fire('movestart')
                        ._move(zoomChanged, bearingChanged)
                        .fire('moveend');
                },
                setCenter: function(center) {
                this.setView(center, this.getZoom(), this.getBearing());
                },
                setZoom: function(zoom) {
                this.setView(this.getCenter(), zoom, this.getBearing());
                },
                setBearing: function(bearing) {
                this.setView(this.getCenter(), this.getZoom(), bearing);
                },
                getCenter: function() { return this.transform.center; },
                getZoom: function() { return this.transform.zoom; },
                getBearing: function() { return this.transform.bearing; },
                // Detect the map's new width and height and resize it.
                resize: function() {
                var width = 0, height = 0;
                        if (this.container) {
                width = this.container.offsetWidth || 400;
                        height = this.container.offsetHeight || 300;
                }

                this.canvas.resize(width, height);
                        this.transform.width = width;
                        this.transform.height = height;
                        this.transform._constrain();
                        if (this.style && this.style.sprite) {
                this.style.sprite.resize(this.painter.gl);
                }

                this.painter.resize(width, height);
                        return this
                        .fire('movestart')
                        ._move()
                        .fire('resize')
                        .fire('moveend');
                },
                getBounds: function() {
                return new LatLngBounds(
                        this.transform.pointLocation(new Point(0, 0)),
                        this.transform.pointLocation(this.transform.size));
                },
                project: function(latlng) {
                return this.transform.locationPoint(LatLng.convert(latlng));
                },
                unproject: function(point) {
                return this.transform.pointLocation(Point.convert(point));
                },
                featuresAt: function(point, params, callback) {
                var features = [];
                        var error = null;
                        var map = this;
                        point = Point.convert(point);
                        util.asyncEach(Object.keys(this.sources), function(id, callback) {
                        var source = map.sources[id];
                                source.featuresAt(point, params, function(err, result) {
                                if (result) features = features.concat(result);
                                        if (err) error = err;
                                        callback();
                                });
                        }, function() {
                        callback(error, features);
                        });
                        return this;
                },
                setStyle: function(style) {
                if (this.style) {
                this.style.off('change', this._onStyleChange);
                }

                if (style instanceof Style) {
                this.style = style;
                } else {
                this.style = new Style(style, this.animationLoop);
                }

                var sources = this.style.stylesheet.sources;
                        for (var id in sources) {
                this.addSource(id, Source.create(sources[id]));
                }

                this.glyphSource = new GlyphSource(this.style.stylesheet.glyphs, this.painter.glyphAtlas);
                        this.style.on('change', this._onStyleChange);
                        this._styleDirty = true;
                        this._tilesDirty = true;
                        this._updateBuckets();
                        this._updateGlyphs();
                        this.fire('style.change');
                        return this;
                },
                _move: function (zoom, rotate) {

                this.update(zoom).fire('move');
                        if (zoom) this.fire('zoom');
                        if (rotate) this.fire('rotate');
                        return this;
                },
                // map setup code

                _setupContainer: function() {
                var id = this.options.container;
                        var container = this.container = typeof id === 'string' ? document.getElementById(id) : id;
                        if (container) container.classList.add('mapboxgl-map');
                        this.canvas = new Canvas(this, container);
                },
                _setupPainter: function() {
                var gl = this.canvas.getWebGLContext();
                        if (!gl) {
                alert('Failed to initialize WebGL');
                        return;
                }

                this.painter = new GLPainter(gl, this.transform);
                },
                _contextLost: function(event) {
                event.preventDefault();
                        if (this._frameId) {
                browser.cancelFrame(this._frameId);
                }
                },
                _contextRestored: function() {
                this._setupPainter();
                        this.resize();
                        this.update();
                },
                // Callbacks from web workers

                'debug message': function(data) {
                console.log.apply(console, data);
                },
                'alert message': function(data) {
                alert.apply(window, data);
                },
                'get sprite json': function(params, callback) {
                var sprite = this.style.sprite;
                        if (sprite.loaded()) {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
                } else {
                sprite.on('loaded', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
                });
                }
                },
                'get glyphs': function(params, callback) {
                this.glyphSource.getRects(params.fontstack, params.codepoints, params.id, callback);
                },
                // Rendering

                update: function(updateStyle) {

                if (!this.style) return this;
                        this._styleDirty = this._styleDirty || updateStyle;
                        this._tilesDirty = true;
                        this._rerender();
                        return this;
                },
                // Call when a (re-)render of the map is required, e.g. when the user panned or zoomed,f or new data is available.
                render: function() {
                if (this._styleDirty) {
                this._styleDirty = false;
                        this._updateStyle();
                }

                if (this._tilesDirty) {
                for (var id in this.sources) {
                this.sources[id].update();
                }
                this._tilesDirty = false;
                }

                this._renderGroups(this.style.layerGroups);
                        this.fire('render');
                        this._frameId = null;
                        if (!this.animationLoop.stopped()) {
                this._styleDirty = true;
                }

                if (this._repaint || !this.animationLoop.stopped()) {
                this._rerender();
                }

                return this;
                },
                _renderGroups: function(groups) {
                this.painter.prepareBuffers();
                        var i, len, group, source;
                        // Render the groups
                        for (i = 0, len = groups.length; i < len; i++) {
                group = groups[i];
                        source = this.sources[group.source];
                        if (source) {
                this.painter.clearStencil();
                        source.render(group);
                } else if (group.source === undefined) {
                this.painter.draw(undefined, this.style, group, { background: true });
                }
                }
                },
                _rerender: function() {
                if (!this._frameId) {
                this._frameId = browser.frame(this.render);
                }
                },
                _onStyleChange: function () {
                this.update(true);
                },
                _updateStyle: function() {
                if (!this.style) return;
                        this.style.recalculate(this.transform.zoom);
                },
                _updateGlyphs: function() {
                this.dispatcher.broadcast('set glyphs', this.style.stylesheet.glyphs);
                },
                _updateBuckets: function() {
                // Transfer a stripped down version of the style to the workers. They only
                // need the bucket information to know what features to extract from the tile.
                this.dispatcher.broadcast('set buckets', this.style.orderedBuckets);
                        // clears all tiles to recalculate geometries (for changes to linecaps, linejoins, ...)
                        for (var s in this.sources) {
                this.sources[s].load();
                }

                this.update();
                }
        });
        util.extendAll(Map.prototype, {

        // debug code
        _debug: false,
                get debug() { return this._debug; },
                set debug(value) { this._debug = value; this._rerender(); },
                // continuous repaint
                _repaint: false,
                get repaint() { return this._repaint; },
                set repaint(value) { this._repaint = value; this._rerender(); },
                // polygon antialiasing
                _antialiasing: true,
                get antialiasing() { return this._antialiasing; },
                set antialiasing(value) { this._antialiasing = value; this._rerender(); },
                // show vertices
                _vertices: false,
                get vertices() { return this._vertices; },
                set vertices(value) { this._vertices = value; this._rerender(); },
                // show vertices
                _loadNewTiles: true,
                get loadNewTiles() { return this._loadNewTiles; },
                set loadNewTiles(value) { this._loadNewTiles = value; this.update(); }
        });
        }, {"../geo/latlng.js":17, "../geo/latlngbounds.js":18, "../geo/transform.js":19, "../render/painter.js":32, "../source/source.js":39, "../style/animationloop.js":47, "../style/style.js":53, "../symbol/glyphsource.js":61, "../util/ajax.js":76, "../util/browser.js":77, "../util/canvas.js":78, "../util/dispatcher.js":79, "../util/evented.js":82, "../util/util.js":87, "./control/attribution.js":67, "./easings.js":70, "./handlers.js":71, "./hash.js":72, "point-geometry":99}], 75:[function(require, module, exports){
'use strict';
        module.exports = Actor;
        function Actor(target, parent) {
        this.target = target;
                this.parent = parent;
                this.callbacks = {};
                this.callbackID = 0;
                this.receive = this.receive.bind(this);
                this.target.addEventListener('message', this.receive, false);
        }

Actor.prototype.receive = function(message) {
var data = message.data,
        callback;
        if (data.type == '<response>') {
callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
} else if (typeof data.id !== 'undefined') {
var id = data.id;
        this.parent[data.type](data.data, function response(err, data, buffers) {
// console.warn('trying to clone', data, buffers, message.target);
message.target.postMessage({
type: '<response>',
        id: String(id),
        error: err ? String(err) : null,
        data: data
}, buffers);
});
} else {
this.parent[data.type](data.data);
}
};
        Actor.prototype.send = function(type, data, callback, buffers) {
        var id = null;
                if (callback) this.callbacks[id = this.callbackID++] = callback;
                this.target.postMessage({ type: type, id: String(id), data: data }, buffers);
        };
        }, {}], 76:[function(require, module, exports){
'use strict';
        exports.getJSON = function(url, callback) {
        var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onerror = function(e) {
                callback(e);
                };
                xhr.onload = function() {
                if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
                var data;
                        try { data = JSON.parse(xhr.response); }
                catch (err) { return callback(err); }
                callback(null, data);
                } else {
                callback(new Error(xhr.statusText));
                }
                };
                xhr.send();
                return xhr;
        };
        exports.getArrayBuffer = function(url, callback) {
        var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'arraybuffer';
                xhr.onerror = function(e) {
                callback(e);
                };
                xhr.onload = function() {
                if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
                callback(null, xhr.response);
                } else {
                callback(new Error(xhr.statusText));
                }
                };
                xhr.send();
                return xhr;
        };
        exports.getImage = function(url, callback) {
        var img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                callback(null, img);
                };
                img.src = url;
                img.getData = function() { return getImageData(this); };
                return img;
        };
        function getImageData(img) {
        var canvas = document.createElement('canvas');
                var context = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                context.drawImage(img, 0, 0);
                return context.getImageData(0, 0, img.width, img.height).data;
        }

}, {}], 77:[function(require, module, exports){
'use strict';
        var frameName = (function() {
        if (window.requestAnimationFrame) return 'requestAnimationFrame';
                if (window.mozRequestAnimationFrame) return 'mozRequestAnimationFrame';
                if (window.webkitRequestAnimationFrame) return 'webkitRequestAnimationFrame';
                if (window.msRequestAnimationFrame) return 'msRequestAnimationFrame';
        })();
        exports.frame = function(fn) {
        return window[frameName](fn);
        };
        exports.cancelFrame = function(id) {
        (window.cancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame)(id);
        };
        exports.timed = function (fn, dur, ctx) {
        if (!dur) {
        fn.call(ctx, 1);
                return;
        }

        var abort = false,
                start = window.performance ? window.performance.now() : Date.now();
                function tick(now) {
                if (abort) return;
                        if (!window.performance) now = Date.now();
                        if (now >= start + dur) {
                fn.call(ctx, 1);
                } else {
                fn.call(ctx, (now - start) / dur);
                        exports.frame(tick);
                }
                }

        exports.frame(tick);
                return function() { abort = true; };
        };
        exports.supported = function() {
        var supports = [

                function() { return typeof window !== 'undefined'; },
                function() { return typeof document !== 'undefined'; },
                function () {
                return !!(Array.prototype &&
                        Array.prototype.every &&
                        Array.prototype.filter &&
                        Array.prototype.forEach &&
                        Array.prototype.indexOf &&
                        Array.prototype.lastIndexOf &&
                        Array.prototype.map &&
                        Array.prototype.some &&
                        Array.prototype.reduce &&
                        Array.prototype.reduceRight &&
                        Array.isArray);
                },
                function() {
                return !!(Function.prototype && Function.prototype.bind),
                        !!(Object.keys &&
                                Object.create &&
                                Object.getPrototypeOf &&
                                Object.getOwnPropertyNames &&
                                Object.isSealed &&
                                Object.isFrozen &&
                                Object.isExtensible &&
                                Object.getOwnPropertyDescriptor &&
                                Object.defineProperty &&
                                Object.defineProperties &&
                                Object.seal &&
                                Object.freeze &&
                                Object.preventExtensions);
                },
                function() {
                return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
                },
                function() {
                var canvas = document.createElement('canvas');
                        if ('supportsContext' in canvas) {
                return canvas.supportsContext('webgl') || canvas.supportsContext('experimental-webgl');
                }
                return !!window.WebGLRenderingContext &&
                        (!!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl'));
                },
                function() { return 'Worker' in window; }
        ];
                for (var i = 0; i < supports.length; i++) {
        if (!supports[i]()) return false;
        }
        return true;
        };
        exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;
        Object.defineProperty(exports, 'devicePixelRatio', {
        get: function() { return window.devicePixelRatio; }
        });
        }, {}], 78:[function(require, module, exports){
'use strict';
        module.exports = Canvas;
        function Canvas(parent, container) {
        this.canvas = document.createElement('canvas');
                this.canvas.style.position = 'absolute';
                this.canvas.classList.add('mapboxgl-canvas');
                this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
                this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
                container.appendChild(this.canvas);
        }

Canvas.prototype.resize = function(width, height) {
var pixelRatio = window.devicePixelRatio || 1;
        // Request the required canvas size taking the pixelratio into account.
        this.canvas.width = pixelRatio * width;
        this.canvas.height = pixelRatio * height;
        // Maintain the same canvas size, potentially downscaling it for HiDPI displays
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        };
        Canvas.prototype.getWebGLContext = function() {
        return this.canvas.getContext("experimental-webgl", {
        antialias: false,
                alpha: true,
                stencil: true,
                depth: false
        });
        };
        }, {}], 79:[function(require, module, exports){
'use strict';
        var Actor = require('../actor.js');
        var scripts = document.getElementsByTagName("script");
        var workerFile = scripts[scripts.length - 1].getAttribute('src');
        var absolute = workerFile.indexOf('http') !== - 1;
// Manages the WebWorkers
        module.exports = Dispatcher;
        function Dispatcher(length, parent) {
        this.actors = [];
                this.currentActor = 0;
                var url, blob, i;
                for (i = 0; i < length; i++) {
        // due to cross domain issues we can't load it directly with the url,
        // so create a blob and object url and load that
        if (absolute) {
        blob = new Blob(['importScripts("' + workerFile + '");'], {type : 'application/javascript'});
                url = window.URL.createObjectURL(blob);
        } else {
        url = workerFile;
        }

        var worker = new Worker(url);
                var actor = new Actor(worker, parent);
                actor.name = "Worker " + i;
                this.actors.push(actor);
        }
        }

Dispatcher.prototype.broadcast = function(type, data) {
for (var i = 0; i < this.actors.length; i++) {
this.actors[i].send(type, data);
}
};
        Dispatcher.prototype.send = function(type, data, callback, targetID, buffers) {
        if (typeof targetID !== 'number' || isNaN(targetID)) {
        // Use round robin to send requests to web workers.
        targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
        }

        this.actors[targetID].send(type, data, callback, buffers);
                return targetID;
        };
        }, {"../actor.js":75}], 80:[function(require, module, exports){
'use strict';
        module.exports = {
        HTTP_URL: 'http://a.tiles.mapbox.com/v4',
                HTTPS_URL: 'https://a.tiles.mapbox.com/v4',
                FORCE_HTTPS: false,
                REQUIRE_ACCESS_TOKEN: true
        };
        }, {}], 81:[function(require, module, exports){
'use strict';
        exports.create = function (tagName, className, container) {
        var el = document.createElement(tagName);
                if (className) el.className = className;
                if (container) container.appendChild(el);
                return el;
        };
        function preventDefault(e) {
        e.preventDefault();
        }

var docEl = typeof document !== 'undefined' ? document.documentElement : {},
        selectProp =
        'userSelect' in docEl ? 'userSelect' :
        'MozUserSelect' in docEl ? 'MozUserSelect' :
        'WebkitUserSelect' in docEl ? 'WebkitUserSelect' : null,
        userSelect;
        exports.disableDrag = function () {
        window.addEventListener('dragstart', preventDefault);
                if ('onselectstart' in document) window.addEventListener('selectstart', preventDefault);
                else if (selectProp) {
        userSelect = docEl.style[selectProp];
                docEl.style[selectProp] = 'none';
        }
        };
        exports.enableDrag = function () {
        window.removeEventListener('dragstart', preventDefault);
                if ('onselectstart' in document) window.removeEventListener('selectstart', preventDefault);
                else if (selectProp) docEl.style[selectProp] = userSelect;
        };
        }, {}], 82:[function(require, module, exports){
'use strict';
        var util = require('./util.js');
        module.exports = {
        on: function(type, fn) {
        this._events = this._events || {};
                this._events[type] = this._events[type] || [];
                this._events[type].push(fn);
                return this;
        },
                off: function(type, fn) {
                if (!type) {
                // clear all listeners if no arguments specified
                delete this._events;
                        return this;
                }

                if (!this.listens(type)) return this;
                        if (fn) {
                var idx = this._events[type].indexOf(fn);
                        if (idx >= 0) {
                this._events[type].splice(idx, 1);
                }
                if (!this._events[type].length) {
                delete this._events[type];
                }
                } else {
                delete this._events[type];
                }

                return this;
                },
                fire: function(type, data) {
                if (!this.listens(type)) return this;
                        data = util.extend({}, data);
                        util.extend(data, {type: type, target: this});
                        // make sure adding/removing listeners inside other listeners won't cause infinite loop
                        var listeners = this._events[type].slice();
                        for (var i = 0; i < listeners.length; i++) {
                listeners[i].call(this, data);
                }

                return this;
                },
                listens: function(type) {
                return !!(this._events && this._events[type]);
                }
        };
        }, {"./util.js":87}], 83:[function(require, module, exports){
'use strict';
        module.exports = Glyphs;
        function Glyphs(buffer, end) {
        // Public
        this.stacks = {};
                // Private
                this._buffer = buffer;
                var val, tag;
                if (typeof end === 'undefined') end = buffer.length;
                while (buffer.pos < end) {
        val = buffer.readVarint();
                tag = val >> 3;
                if (tag == 1) {
        var fontstack = this.readFontstack();
                this.stacks[fontstack.name] = fontstack;
        } else {
        // console.warn('skipping tile tag ' + tag);
        buffer.skip(val);
        }
        }
        }

Glyphs.prototype.readFontstack = function() {
var buffer = this._buffer;
        var fontstack = { glyphs: {} };
        var bytes = buffer.readVarint();
        var val, tag;
        var end = buffer.pos + bytes;
        while (buffer.pos < end) {
val = buffer.readVarint();
        tag = val >> 3;
        if (tag == 1) {
fontstack.name = buffer.readString();
} else if (tag == 2) {
var range = buffer.readString();
        fontstack.range = range;
} else if (tag == 3) {
var glyph = this.readGlyph();
        fontstack.glyphs[glyph.id] = glyph;
} else {
buffer.skip(val);
}
}

return fontstack;
        };
        Glyphs.prototype.readGlyph = function() {
        var buffer = this._buffer;
                var glyph = {};
                var bytes = buffer.readVarint();
                var val, tag;
                var end = buffer.pos + bytes;
                while (buffer.pos < end) {
        val = buffer.readVarint();
                tag = val >> 3;
                if (tag == 1) {
        glyph.id = buffer.readVarint();
        } else if (tag == 2) {
        glyph.bitmap = buffer.readBuffer();
        } else if (tag == 3) {
        glyph.width = buffer.readVarint();
        } else if (tag == 4) {
        glyph.height = buffer.readVarint();
        } else if (tag == 5) {
        glyph.left = buffer.readSVarint();
        } else if (tag == 6) {
        glyph.top = buffer.readSVarint();
        } else if (tag == 7) {
        glyph.advance = buffer.readVarint();
        } else {
        buffer.skip(val);
        }
        }

        return glyph;
        };
        }, {}], 84:[function(require, module, exports){
'use strict';
        var config = require('./config');
        function normalizeURL(url, accessToken) {
        accessToken = accessToken || config.ACCESS_TOKEN;
                if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        var https = config.FORCE_HTTPS ||
                (typeof document !== 'undefined' && 'https:' === document.location.protocol);
                url = url.replace(/^mapbox:\/\//, (https ? config.HTTPS_URL : config.HTTP_URL) + '/');
                url += url.indexOf('?') !== - 1 ? '&access_token=' : '?access_token=';
                if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
        throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
        }

        return url;
        }

module.exports.normalizeSourceURL = function(url, accessToken) {
if (!url.match(/^mapbox:\/\//))
        return url;
        url = normalizeURL(url + '.json', accessToken);
        // TileJSON requests need a secure flag appended to their URLs so
        // that the server knows to send SSL-ified resource references.
        if (url.indexOf('https') === 0)
        url += '&secure';
        return url;
        };
        module.exports.normalizeGlyphsURL = function(url, accessToken) {
        if (!url.match(/^mapbox:\/\//))
                return url;
                return normalizeURL(url, accessToken);
        };
        }, {"./config":80}], 85:[function(require, module, exports){
'use strict';
        /*
         * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
         * with hash lookup made possible by keeping a list of keys in parallel to
         * an array of dictionary of values
         */
        module.exports = MRUCache;
        function MRUCache(length, onRemove) {
        this.max = length;
                this.onRemove = onRemove;
                this.reset();
        }

/*
 * Clears the cache
 */
MRUCache.prototype.reset = function() {
this.list = {};
        this.order = [];
        return this;
        };
        /*
         * Add a key, value combination to the cache, trimming its size if this pushes
         * it over max length.
         */
        MRUCache.prototype.add = function(key, data) {
        this.list[key] = data;
                this.order.push(key);
                if (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
                if (removedData) this.onRemove(removedData);
        }

        return this;
        };
        /*
         * Determine whether the value attached to `key` is present
         */
        MRUCache.prototype.has = function(key) {
        return key in this.list;
        };
        /*
         * List all keys in the cache
         */
        MRUCache.prototype.keys = function() {
        return this.order;
        };
        /*
         * Get the value attached to a specific key. If the key is not found,
         * returns `null`
         */
        MRUCache.prototype.get = function(key) {
        if (!this.has(key)) { return null; }

        var data = this.list[key];
                delete this.list[key];
                this.order.splice(this.order.indexOf(key), 1);
                return data;
        };
        }, {}], 86:[function(require, module, exports){
'use strict';
        module.exports = resolveTokens;
        var tokenPattern = /{([\w-]+)}/;
        function resolveTokens(properties, expression) {
        var match;
                var value;
                var text = expression;
                while ((match = text.match(tokenPattern))) {
        value = typeof properties[match[1]] === 'undefined' ? '' : properties[match[1]];
                text = text.replace(match[0], value);
        }
        return text;
        }

}, {}], 87:[function(require, module, exports){
'use strict';
        var UnitBezier = require('unitbezier');
        exports.easeCubicInOut = function (t) {
        if (t <= 0) return 0;
                if (t >= 1) return 1;
                var t2 = t * t,
                t3 = t2 * t;
                return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
        };
        exports.bezier = function(p1x, p1y, p2x, p2y) {
        var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
                return function(t) {
                return bezier.solve(t);
                };
        };
        exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);
        exports.interp = function (a, b, t) {
        return (a * (1 - t)) + (b * t);
        };
        exports.premultiply = function (c) {
        c[0] *= c[3];
                c[1] *= c[3];
                c[2] *= c[3];
                return c;
        };
        exports.asyncEach = function (array, fn, callback) {
        var remaining = array.length;
                if (remaining === 0) return callback();
                function check() { if (--remaining === 0) callback(); }
        for (var i = 0; i < array.length; i++) fn(array[i], check);
        };
        exports.keysDifference = function (obj, other) {
        var difference = [];
                for (var i in obj) {
        if (!(i in other)) {
        difference.push(i);
        }
        }
        return difference;
        };
        exports.extend = function (dest, src) {
        for (var i in src) {
        dest[i] = src[i];
        }
        return dest;
        };
        exports.extendAll = function (dest, src) {
        for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
        }
        return dest;
        };
        exports.inherit = function (parent, props) {
        var parentProto = typeof parent === 'function' ? parent.prototype : parent,
                proto = Object.create(parentProto);
                exports.extendAll(proto, props);
                return proto;
        };
        var id = 1;
        exports.uniqueId = function () {
        return id++;
        };
        exports.throttle = function (fn, time, context) {
        var lock, args, wrapperFn, later;
                later = function () {
                // reset lock and call if queued
                lock = false;
                        if (args) {
                wrapperFn.apply(context, args);
                        args = false;
                }
                };
                wrapperFn = function () {
                if (lock) {
                // called too soon, queue to call later
                args = arguments;
                } else {
                // call and lock until later
                fn.apply(context, arguments);
                        setTimeout(later, time);
                        lock = true;
                }
                };
                return wrapperFn;
        };
        exports.debounce = function(fn, time) {
        var timer, args;
                return function() {
                args = arguments;
                        clearTimeout(timer);
                        timer = setTimeout(function() {
                        fn.apply(null, args);
                        }, time);
                };
        };
        }, {"unitbezier":102}], 88:[function(require, module, exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
        var ieee754 = require('ieee754')
        var isArray = require('is-array')

        exports.Buffer = Buffer
        exports.SlowBuffer = Buffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192 // not used by this implementation

        var kMaxLength = 0x3fffffff

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Note:
         *
         * - Implementation must support adding new properties to `Uint8Array` instances.
         *   Firefox 4-29 lacked support, fixed in Firefox 30+.
         *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *    incorrect length in some situations.
         *
         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
         * get the Object implementation, which is slower but will work correctly.
         */
        Buffer.TYPED_ARRAY_SUPPORT = (function () {
        try {
        var buf = new ArrayBuffer(0)
                var arr = new Uint8Array(buf)
                arr.foo = function () { return 42 }
        return 42 === arr.foo() && // typed array instances can be augmented
                typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
        } catch (e) {
        return false
        }
        })()

        /**
         * Class: Buffer
         * =============
         *
         * The Buffer constructor returns instances of `Uint8Array` that are augmented
         * with function properties for all the node `Buffer` API functions. We use
         * `Uint8Array` so that square bracket notation works as expected -- it returns
         * a single octet.
         *
         * By augmenting the instances, we can avoid modifying the `Uint8Array`
         * prototype.
         */
                function Buffer (subject, encoding, noZero) {
                if (!(this instanceof Buffer))
                        return new Buffer(subject, encoding, noZero)

                        var type = typeof subject

                        // Find the length
                        var length
                        if (type === 'number')
                        length = subject > 0 ? subject >>> 0 : 0
                        else if (type === 'string') {
                if (encoding === 'base64')
                        subject = base64clean(subject)
                        length = Buffer.byteLength(subject, encoding)
                } else if (type === 'object' && subject !== null) { // assume object is array-like
                if (subject.type === 'Buffer' && isArray(subject.data))
                        subject = subject.data
                        length = + subject.length > 0 ? Math.floor( + subject.length) : 0
                } else
                        throw new TypeError('must start with number, buffer, array or string')

                        if (this.length > kMaxLength)
                        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                'size: 0x' + kMaxLength.toString(16) + ' bytes')

                        var buf
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Preferred: Return an augmented `Uint8Array` instance for best performance
                buf = Buffer._augment(new Uint8Array(length))
                } else {
                // Fallback: Return THIS instance of Buffer (created by `new`)
                buf = this
                        buf.length = length
                        buf._isBuffer = true
                }

                var i
                        if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
                // Speed optimization -- use set if we're copying from a typed array
                buf._set(subject)
                } else if (isArrayish(subject)) {
                // Treat array-ish objects as a byte array
                if (Buffer.isBuffer(subject)) {
                for (i = 0; i < length; i++)
                        buf[i] = subject.readUInt8(i)
                } else {
                for (i = 0; i < length; i++)
                        buf[i] = ((subject[i] % 256) + 256) % 256
                }
                } else if (type === 'string') {
                buf.write(subject, 0, encoding)
                } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
                for (i = 0; i < length; i++) {
                buf[i] = 0
                }
                }

                return buf
                }

        Buffer.isBuffer = function (b) {
        return !!(b != null && b._isBuffer)
        }

        Buffer.compare = function (a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
                throw new TypeError('Arguments must be Buffers')

                var x = a.length
                var y = b.length
                for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
        if (i !== len) {
        x = a[i]
                y = b[i]
        }
        if (x < y) return - 1
                if (y < x) return 1
                return 0
        }

        Buffer.isEncoding = function (encoding) {
        switch (String(encoding).toLowerCase()) {
        case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'raw':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                return true
                default:
                return false
        }
        }

        Buffer.concat = function (list, totalLength) {
        if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

                if (list.length === 0) {
        return new Buffer(0)
        } else if (list.length === 1) {
        return list[0]
        }

        var i
                if (totalLength === undefined) {
        totalLength = 0
                for (i = 0; i < list.length; i++) {
        totalLength += list[i].length
        }
        }

        var buf = new Buffer(totalLength)
                var pos = 0
                for (i = 0; i < list.length; i++) {
        var item = list[i]
                item.copy(buf, pos)
                pos += item.length
        }
        return buf
        }

        Buffer.byteLength = function (str, encoding) {
        var ret
                str = str + ''
                switch (encoding || 'utf8') {
        case 'ascii':
                case 'binary':
                case 'raw':
                ret = str.length
                break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                ret = str.length * 2
                break
                case 'hex':
                ret = str.length >>> 1
                break
                case 'utf8':
                case 'utf-8':
                ret = utf8ToBytes(str).length
                break
                case 'base64':
                ret = base64ToBytes(str).length
                break
                default:
                ret = str.length
        }
        return ret
        }

// pre-set for values that may exist in the future
        Buffer.prototype.length = undefined
                Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
                Buffer.prototype.toString = function (encoding, start, end) {
                var loweredCase = false

                        start = start >>> 0
                        end = end === undefined || end === Infinity ? this.length : end >>> 0

                        if (!encoding) encoding = 'utf8'
                        if (start < 0) start = 0
                        if (end > this.length) end = this.length
                        if (end <= start) return ''

                        while (true) {
                switch (encoding) {
                case 'hex':
                        return hexSlice(this, start, end)

                        case 'utf8':
                        case 'utf-8':
                        return utf8Slice(this, start, end)

                        case 'ascii':
                        return asciiSlice(this, start, end)

                        case 'binary':
                        return binarySlice(this, start, end)

                        case 'base64':
                        return base64Slice(this, start, end)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                        return utf16leSlice(this, start, end)

                        default:
                        if (loweredCase)
                        throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                }
                }
                }

        Buffer.prototype.equals = function (b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function () {
        var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                if (this.length > max)
                str += ' ... '
        }
        return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function (b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                return Buffer.compare(this, b)
        }

// `get` will be removed in Node 0.13+
        Buffer.prototype.get = function (offset) {
        console.log('.get() is deprecated. Access using array indexes instead.')
                return this.readUInt8(offset)
        }

// `set` will be removed in Node 0.13+
        Buffer.prototype.set = function (v, offset) {
        console.log('.set() is deprecated. Access using array indexes instead.')
                return this.writeUInt8(v, offset)
        }

        function hexWrite (buf, string, offset, length) {
        offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
        length = remaining
        } else {
        length = Number(length)
                if (length > remaining) {
        length = remaining
        }
        }

        // must be an even number of digits
        var strLen = string.length
                if (strLen % 2 !== 0) throw new Error('Invalid hex string')

                if (length > strLen / 2) {
        length = strLen / 2
        }
        for (var i = 0; i < length; i++) {
        var byte = parseInt(string.substr(i * 2, 2), 16)
                if (isNaN(byte)) throw new Error('Invalid hex string')
                buf[offset + i] = byte
        }
        return i
        }

        function utf8Write (buf, string, offset, length) {
        var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
                return charsWritten
        }

        function asciiWrite (buf, string, offset, length) {
        var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
                return charsWritten
        }

        function binaryWrite (buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
        }

        function base64Write (buf, string, offset, length) {
        var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
                return charsWritten
        }

        function utf16leWrite (buf, string, offset, length) {
        var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
                return charsWritten
        }

        Buffer.prototype.write = function (string, offset, length, encoding) {
        // Support both (string, offset, length, encoding)
        // and the legacy (string, encoding, offset, length)
        if (isFinite(offset)) {
        if (!isFinite(length)) {
        encoding = length
                length = undefined
        }
        } else {  // legacy
        var swap = encoding
                encoding = offset
                offset = length
                length = swap
        }

        offset = Number(offset) || 0
                var remaining = this.length - offset
                if (!length) {
        length = remaining
        } else {
        length = Number(length)
                if (length > remaining) {
        length = remaining
        }
        }
        encoding = String(encoding || 'utf8').toLowerCase()

                var ret
                switch (encoding) {
        case 'hex':
                ret = hexWrite(this, string, offset, length)
                break
                case 'utf8':
                case 'utf-8':
                ret = utf8Write(this, string, offset, length)
                break
                case 'ascii':
                ret = asciiWrite(this, string, offset, length)
                break
                case 'binary':
                ret = binaryWrite(this, string, offset, length)
                break
                case 'base64':
                ret = base64Write(this, string, offset, length)
                break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                ret = utf16leWrite(this, string, offset, length)
                break
                default:
                throw new TypeError('Unknown encoding: ' + encoding)
        }
        return ret
        }

        Buffer.prototype.toJSON = function () {
        return {
        type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
        }
        }

        function base64Slice (buf, start, end) {
        if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
        } else {
        return base64.fromByteArray(buf.slice(start, end))
        }
        }

        function utf8Slice (buf, start, end) {
        var res = ''
                var tmp = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; i++) {
        if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
                tmp = ''
        } else {
        tmp += '%' + buf[i].toString(16)
        }
        }

        return res + decodeUtf8Char(tmp)
        }

        function asciiSlice (buf, start, end) {
        var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; i++) {
        ret += String.fromCharCode(buf[i])
        }
        return ret
        }

        function binarySlice (buf, start, end) {
        return asciiSlice(buf, start, end)
        }

        function hexSlice (buf, start, end) {
        var len = buf.length

                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len

                var out = ''
                for (var i = start; i < end; i++) {
        out += toHex(buf[i])
        }
        return out
        }

        function utf16leSlice (buf, start, end) {
        var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
        }
        return res
        }

        Buffer.prototype.slice = function (start, end) {
        var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end

                if (start < 0) {
        start += len;
                if (start < 0)
                start = 0
        } else if (start > len) {
        start = len
        }

        if (end < 0) {
        end += len
                if (end < 0)
                end = 0
        } else if (end > len) {
        end = len
        }

        if (end < start)
                end = start

                if (Buffer.TYPED_ARRAY_SUPPORT) {
        return Buffer._augment(this.subarray(start, end))
        } else {
        var sliceLen = end - start
                var newBuf = new Buffer(sliceLen, undefined, true)
                for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start]
        }
        return newBuf
        }
        }

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset (offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0)
                throw new RangeError('offset is not uint')
                if (offset + ext > length)
                throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUInt8 = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 1, this.length)
                return this[offset]
        }

        Buffer.prototype.readUInt16LE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)

                return ((this[offset]) |
                        (this[offset + 1] << 8) |
                        (this[offset + 2] << 16)) +
                (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)

                return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                        (this[offset + 2] << 8) |
                        this[offset + 3])
        }

        Buffer.prototype.readInt8 = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80))
                return (this[offset])
                return ((0xff - this[offset] + 1) * - 1)
        }

        Buffer.prototype.readInt16LE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)

                return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)

                return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function (offset, noAssert) {
        if (!noAssert)
                checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt (buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
                if (value > max || value < min) throw new TypeError('value is out of bounds')
                if (offset + ext > buf.length) throw new TypeError('index out of range')
        }

        Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                this[offset] = value
                return offset + 1
        }

        function objectWriteUInt16 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                (littleEndian ? i : 1 - i) * 8
        }
        }

        Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value
                this[offset + 1] = (value >>> 8)
        } else objectWriteUInt16(this, value, offset, true)
                return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
                this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false)
                return offset + 2
        }

        function objectWriteUInt32 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
        }
        }

        Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
                this[offset + 2] = (value >>> 16)
                this[offset + 1] = (value >>> 8)
                this[offset] = value
        } else objectWriteUInt32(this, value, offset, true)
                return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false)
                return offset + 4
        }

        Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 1, 0x7f, - 0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                if (value < 0) value = 0xff + value + 1
                this[offset] = value
                return offset + 1
        }

        Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 2, 0x7fff, - 0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value
                this[offset + 1] = (value >>> 8)
        } else objectWriteUInt16(this, value, offset, true)
                return offset + 2
        }

        Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 2, 0x7fff, - 0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
                this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false)
                return offset + 2
        }

        Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, - 0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value
                this[offset + 1] = (value >>> 8)
                this[offset + 2] = (value >>> 16)
                this[offset + 3] = (value >>> 24)
        } else objectWriteUInt32(this, value, offset, true)
                return offset + 4
        }

        Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
        value = + value
                offset = offset >>> 0
                if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, - 0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false)
                return offset + 4
        }

        function checkIEEE754 (buf, value, offset, ext, max, min) {
        if (value > max || value < min) throw new TypeError('value is out of bounds')
                if (offset + ext > buf.length) throw new TypeError('index out of range')
        }

        function writeFloat (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, - 3.4028234663852886e+38)
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
        }

        Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, - 1.7976931348623157E+308)
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
        }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function (target, target_start, start, end) {
        var source = this

                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (!target_start) target_start = 0

                // Copy 0 bytes; we're done
                if (end === start) return
                if (target.length === 0 || source.length === 0) return

                // Fatal error conditions
                if (end < start) throw new TypeError('sourceEnd < sourceStart')
                if (target_start < 0 || target_start >= target.length)
                throw new TypeError('targetStart out of bounds')
                if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
                if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

                // Are we oob?
                if (end > this.length)
                end = this.length
                if (target.length - target_start < end - start)
                end = target.length - target_start + start

                var len = end - start

                if (len < 100 || !Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < len; i++) {
        target[i + target_start] = this[i + start]
        }
        } else {
        target._set(this.subarray(start, start + len), target_start)
        }
        }

// fill(value, start=0, end=buffer.length)
        Buffer.prototype.fill = function (value, start, end) {
        if (!value) value = 0
                if (!start) start = 0
                if (!end) end = this.length

                if (end < start) throw new TypeError('end < start')

                // Fill 0 bytes; we're done
                if (end === start) return
                if (this.length === 0) return

                if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
                if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

                var i
                if (typeof value === 'number') {
        for (i = start; i < end; i++) {
        this[i] = value
        }
        } else {
        var bytes = utf8ToBytes(value.toString())
                var len = bytes.length
                for (i = start; i < end; i++) {
        this[i] = bytes[i % len]
        }
        }

        return this
        }

        /**
         * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
         * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
         */
        Buffer.prototype.toArrayBuffer = function () {
        if (typeof Uint8Array !== 'undefined') {
        if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer
        } else {
        var buf = new Uint8Array(this.length)
                for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
        }
        return buf.buffer
        }
        } else {
        throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
        }
        }

// HELPER FUNCTIONS
// ================

        var BP = Buffer.prototype

                /**
                 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
                 */
                Buffer._augment = function (arr) {
                arr._isBuffer = true

                        // save reference to original Uint8Array get/set methods before overwriting
                        arr._get = arr.get
                        arr._set = arr.set

                        // deprecated, will be removed in node 0.13+
                        arr.get = BP.get
                        arr.set = BP.set

                        arr.write = BP.write
                        arr.toString = BP.toString
                        arr.toLocaleString = BP.toString
                        arr.toJSON = BP.toJSON
                        arr.equals = BP.equals
                        arr.compare = BP.compare
                        arr.copy = BP.copy
                        arr.slice = BP.slice
                        arr.readUInt8 = BP.readUInt8
                        arr.readUInt16LE = BP.readUInt16LE
                        arr.readUInt16BE = BP.readUInt16BE
                        arr.readUInt32LE = BP.readUInt32LE
                        arr.readUInt32BE = BP.readUInt32BE
                        arr.readInt8 = BP.readInt8
                        arr.readInt16LE = BP.readInt16LE
                        arr.readInt16BE = BP.readInt16BE
                        arr.readInt32LE = BP.readInt32LE
                        arr.readInt32BE = BP.readInt32BE
                        arr.readFloatLE = BP.readFloatLE
                        arr.readFloatBE = BP.readFloatBE
                        arr.readDoubleLE = BP.readDoubleLE
                        arr.readDoubleBE = BP.readDoubleBE
                        arr.writeUInt8 = BP.writeUInt8
                        arr.writeUInt16LE = BP.writeUInt16LE
                        arr.writeUInt16BE = BP.writeUInt16BE
                        arr.writeUInt32LE = BP.writeUInt32LE
                        arr.writeUInt32BE = BP.writeUInt32BE
                        arr.writeInt8 = BP.writeInt8
                        arr.writeInt16LE = BP.writeInt16LE
                        arr.writeInt16BE = BP.writeInt16BE
                        arr.writeInt32LE = BP.writeInt32LE
                        arr.writeInt32BE = BP.writeInt32BE
                        arr.writeFloatLE = BP.writeFloatLE
                        arr.writeFloatBE = BP.writeFloatBE
                        arr.writeDoubleLE = BP.writeDoubleLE
                        arr.writeDoubleBE = BP.writeDoubleBE
                        arr.fill = BP.fill
                        arr.inspect = BP.inspect
                        arr.toArrayBuffer = BP.toArrayBuffer

                        return arr
                }

        var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

                function base64clean (str) {
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                        while (str.length % 4 !== 0) {
                str = str + '='
                }
                return str
                }

        function stringtrim (str) {
        if (str.trim) return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
        }

        function isArrayish (subject) {
        return isArray(subject) || Buffer.isBuffer(subject) ||
                subject && typeof subject === 'object' &&
                typeof subject.length === 'number'
        }

        function toHex (n) {
        if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
        }

        function utf8ToBytes (str) {
        var byteArray = []
                for (var i = 0; i < str.length; i++) {
        var b = str.charCodeAt(i)
                if (b <= 0x7F) {
        byteArray.push(b)
        } else {
        var start = i
                if (b >= 0xD800 && b <= 0xDFFF) i++
                var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%')
                for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
        }
        }
        }
        return byteArray
        }

        function asciiToBytes (str) {
        var byteArray = []
                for (var i = 0; i < str.length; i++) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
        }
        return byteArray
        }

        function utf16leToBytes (str) {
        var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
        c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
        }

        return byteArray
        }

        function base64ToBytes (str) {
        return base64.toByteArray(str)
        }

        function blitBuffer (src, dst, offset, length) {
        for (var i = 0; i < length; i++) {
        if ((i + offset >= dst.length) || (i >= src.length))
                break
                dst[i + offset] = src[i]
        }
        return i
        }

        function decodeUtf8Char (str) {
        try {
        return decodeURIComponent(str)
        } catch (err) {
        return String.fromCharCode(0xFFFD) // UTF 8 invalid char
        }
        }

        }, {"base64-js":89, "ieee754":90, "is-array":91}], 89:[function(require, module, exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        ; (function (exports) {
        'use strict';
                var Arr = (typeof Uint8Array !== 'undefined')
                ? Uint8Array
                : Array

                var PLUS = '+'.charCodeAt(0)
                var SLASH = '/'.charCodeAt(0)
                var NUMBER = '0'.charCodeAt(0)
                var LOWER = 'a'.charCodeAt(0)
                var UPPER = 'A'.charCodeAt(0)

                function decode (elt) {
                var code = elt.charCodeAt(0)
                        if (code === PLUS)
                        return 62 // '+'
                        if (code === SLASH)
                        return 63 // '/'
                        if (code < NUMBER)
                        return - 1 //no match
                        if (code < NUMBER + 10)
                        return code - NUMBER + 26 + 26
                        if (code < UPPER + 26)
                        return code - UPPER
                        if (code < LOWER + 26)
                        return code - LOWER + 26
                }

        function b64ToByteArray (b64) {
        var i, j, l, tmp, placeHolders, arr

                if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
        }

        // the number of equal signs (place holders)
        // if there are two placeholders, than the two characters before it
        // represent one byte
        // if there is only one, then the three characters before it represent 2 bytes
        // this is just a cheap hack to not do indexOf twice
        var len = b64.length
                placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

                // base64 is 4/3 + up to two characters of the original data
                arr = new Arr(b64.length * 3 / 4 - placeHolders)

                // if there are placeholders, only get up to the last complete 4 chars
                l = placeHolders > 0 ? b64.length - 4 : b64.length

                var L = 0

                function push (v) {
                arr[L++] = v
                }

        for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                push((tmp & 0xFF0000) >> 16)
                push((tmp & 0xFF00) >> 8)
                push(tmp & 0xFF)
        }

        if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                push(tmp & 0xFF)
        } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                push((tmp >> 8) & 0xFF)
                push(tmp & 0xFF)
        }

        return arr
        }

        function uint8ToBase64 (uint8) {
        var i,
                extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                output = "",
                temp, length

                function encode (num) {
                return lookup.charAt(num)
                }

        function tripletToBase64 (num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
        }

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output += tripletToBase64(temp)
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        switch (extraBytes) {
        case 1:
                temp = uint8[uint8.length - 1]
                output += encode(temp >> 2)
                output += encode((temp << 4) & 0x3F)
                output += '=='
                break
                case 2:
                temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                output += encode(temp >> 10)
                output += encode((temp >> 4) & 0x3F)
                output += encode((temp << 2) & 0x3F)
                output += '='
                break
        }

        return output
        }

        exports.toByteArray = b64ToByteArray
                exports.fromByteArray = uint8ToBase64
        }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

        }, {}], 90:[function(require, module, exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
var e, m,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = - 7,
        i = isLE ? (nBytes - 1) : 0,
        d = isLE ? - 1 : 1,
        s = buffer[offset + i];
        i += d;
        e = s & ((1 << ( - nBits)) - 1);
        s >>= ( - nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
        m = e & ((1 << ( - nBits)) - 1);
        e >>= ( - nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
        if (e === 0) {
e = 1 - eBias;
} else if (e === eMax) {
return m ? NaN : ((s ? - 1 : 1) * Infinity);
} else {
m = m + Math.pow(2, mLen);
        e = e - eBias;
}
return (s ? - 1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = (mLen === 23 ? Math.pow(2, - 24) - Math.pow(2, - 77) : 0),
                i = isLE ? 0 : (nBytes - 1),
                d = isLE ? 1 : - 1,
                s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
                value = Math.abs(value);
                if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
                e = eMax;
        } else {
        e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, - e)) < 1) {
        e--;
                c *= 2;
        }
        if (e + eBias >= 1) {
        value += rt / c;
        } else {
        value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
        e++;
                c /= 2;
        }

        if (e + eBias >= eMax) {
        m = 0;
                e = eMax;
        } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
        } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
        }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
                e = (e << mLen) | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
                buffer[offset + i - d] |= s * 128;
        };
        }, {}], 91:[function(require, module, exports){

/**
 * isArray
 */

var isArray = Array.isArray;
        /**
         * toString
         */

        var str = Object.prototype.toString;
        /**
         * Whether or not the given `val`
         * is an array.
         *
         * example:
         *
         *        isArray([]);
         *        // > true
         *        isArray(arguments);
         *        // > false
         *        isArray('');
         *        // > false
         *
         * @param {mixed} val
         * @return {bool}
         */

        module.exports = isArray || function (val) {
        return !! val && '[object Array]' == str.call(val);
        };
        }, {}], 92:[function(require, module, exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
"transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
        }

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
return f < 0 ? 0 : f > 1 ? 1 : f;
        }

function parse_css_int(str) {  // int or percentage.
if (str[str.length - 1] === '%')
        return clamp_css_byte(parseFloat(str) / 100 * 255);
        return clamp_css_byte(parseInt(str));
        }

function parse_css_float(str) {  // float or percentage.
if (str[str.length - 1] === '%')
        return clamp_css_float(parseFloat(str) / 100);
        return clamp_css_float(parseFloat(str));
        }

function css_hue_to_rgb(m1, m2, h) {
if (h < 0) h += 1;
        else if (h > 1) h -= 1;
        if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1) return m2;
        if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        return m1;
        }

function parseCSSColor(css_str) {
// Remove all whitespace, not compliant, but should just be more accepting.
var str = css_str.replace(/ /g, '').toLowerCase();
        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
if (str.length === 4) {
var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                (iv & 0xf0) | ((iv & 0xf0) >> 4),
                (iv & 0xf) | ((iv & 0xf) << 4),
                1];
} else if (str.length === 7) {
var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.
        return [(iv & 0xff0000) >> 16,
                (iv & 0xff00) >> 8,
                iv & 0xff,
                1];
}

return null;
}

var op = str.indexOf('('), ep = str.indexOf(')');
        if (op !== - 1 && ep + 1 === str.length) {
var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1; // To allow case fallthrough.
        switch (fname) {
case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
        case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
        case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
        case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360; // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                alpha];
        default:
        return null;
}
}

return null;
        }

try { exports.parseCSSColor = parseCSSColor } catch (e) { }

}, {}], 93:[function(require, module, exports){
var geojsonArea = require('geojson-area');
        module.exports = rewind;
        function rewind(gj, outer) {
        switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
                gj.features = gj.features.map(curryOuter(rewind, outer));
                return gj;
                case 'Feature':
                gj.geometry = rewind(gj.geometry, outer);
                return gj;
                case 'Polygon':
                case 'MultiPolygon':
                return correct(gj, outer);
                default:
                return gj;
        }
        }

function curryOuter(a, b) {
return function(_) { return a(_, b); };
        }

function correct(_, outer) {
if (_.type === 'Polygon') {
_.coordinates = correctRings(_.coordinates, outer);
} else if (_.type === 'MultiPolygon') {
_.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
}
return _;
        }

function correctRings(_, outer) {
outer = !!outer;
        _[0] = wind(_[0], !outer);
        for (var i = 1; i < _.length; i++) {
_[i] = wind(_[i], outer);
}
return _;
        }

function wind(_, dir) {
return cw(_) === dir ? _ : _.reverse();
        }

function cw(_) {
return geojsonArea.ring(_) >= 0;
        }

}, {"geojson-area":94}], 94:[function(require, module, exports){
var wgs84 = require('wgs84');
        module.exports.geometry = geometry;
        module.exports.ring = ringArea;
        function geometry(_) {
        if (_.type === 'Polygon') return polygonArea(_.coordinates);
                else if (_.type === 'MultiPolygon') {
        var area = 0;
                for (var i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
        }
        return area;
        } else {
        return null;
        }
        }

function polygonArea(coords) {
var area = 0;
        if (coords && coords.length > 0) {
area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
area -= Math.abs(ringArea(coords[i]));
}
}
return area;
        }

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
var area = 0;
        if (coords.length > 2) {
var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
p1 = coords[i];
        p2 = coords[i + 1];
        area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
}

area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
}

return area;
        }

function rad(_) {
return _ * Math.PI / 180;
        }

}, {"wgs84":95}], 95:[function(require, module, exports){
module.exports.RADIUS = 6378137;
        module.exports.FLATTENING = 1 / 298.257223563;
        module.exports.POLAR_RADIUS = 6356752.3142;
        }, {}], 96:[function(require, module, exports){
module.exports = {
"$version": 5,
        "$root": {
        "version": {
        "required": true,
                "type": "enum",
                "values": [
                        5
                ],
                "doc": "Stylesheet version number. Must be 5."
        },
                "constants": {
                "type": "constants",
                        "doc": "An object of constants to be referenced in layers."
                },
                "sources": {
                "required": true,
                        "type": "sources",
                        "doc": "Data source specifications for layers to pull from."
                },
                "layers": {
                "required": true,
                        "type": "array",
                        "value": "layer",
                        "doc": "An array of layers. The order of layers coincides with the order they will be drawn."
                },
                "sprite": {
                "type": "sprite",
                        "doc": "Sprite definition."
                },
                "glyphs": {
                "type": "string",
                        "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
                },
                "transition": {
                "type": "transition",
                        "doc": "A global transition definition to use as a default across properties."
                }
        },
        "sprite": [{
        "type": "string",
                "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
        }],
        "constants": {
        "*": {
        "type": "*",
                "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
        }
        },
        "sources": {
        "*": {
        "type": "source",
                "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
        }
        },
        "source": {
        "type": {
        "required": true,
                "type": "enum",
                "values": [
                        "vector",
                        "raster",
                        "geojson",
                        "video"
                ],
                "doc": "The data type of the source."
        },
                "url": {
                "type": "string",
                        "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
                },
                "tiles": {
                "type": "string",
                        "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
                },
                "minzoom": {
                "type": "number",
                        "default": 0,
                        "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
                },
                "maxzoom": {
                "type": "number",
                        "default": 22,
                        "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
                },
                "tileSize": {
                "type": "number",
                        "default": 512,
                        "doc": "The minimum visual size (in px) to display tiles for this layer. Only configurable for raster layers."
                },
                "*": {
                "type": "*",
                        "doc": "Other keys to configure the data source."
                }
        },
        "layer": {
        "id": {
        "type": "string",
                "doc": "Unique layer name."
        },
                "type": {
                "type": "enum",
                        "values": [
                                "fill",
                                "line",
                                "symbol",
                                "raster",
                                "background"
                        ],
                        "doc": "Rendering type of this layer."
                },
                "ref": {
                "type": "string",
                        "doc": "References another layer to copy `source`, `source_layer`, `filter`, and `render` properties from. This allows the layers to share processing and be more efficient."
                },
                "source": {
                "type": "string",
                        "doc": "Name of a source description to be used for this layer."
                },
                "source-layer": {
                "type": "string",
                        "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
                },
                "min-zoom": {
                "type": "number",
                        "doc": "The minimum zoom level on which the layer gets parsed and appears on."
                },
                "max-zoom": {
                "type": "number",
                        "doc": "The maximum zoom level on which the layer gets parsed and appears on."
                },
                "interactive": {
                "type": "boolean",
                        "doc": "Enable querying of feature data from this layer for interactivity.",
                        "default": false
                },
                "render": {
                "type": "render",
                        "doc": "Symbolizer type that should be used to visualize this layer. If unspecified or null, this layer is not treated as a symbolizer and only exists to have properties inherited to other layers using ref."
                },
                "filter": {
                "type": "filter",
                        "doc": "Array or object of filters or expressions."
                },
                "layers": {
                "type": "array",
                        "value": "layer",
                        "doc": "If `type` is `raster`, the child layers are composited together onto the previous level layer level."
                },
                "style": {
                "type": "class",
                        "doc": "Default style properties for this layer."
                },
                "style.*": {
                "type": "class",
                        "doc": "Override style properties for this layer. The class name is the part after the first dot."
                }
        },
        "render": [
                "render_fill",
                "render_line",
                "render_symbol",
                "render_raster",
                "render_background"
        ],
        "render_background": {
        },
        "render_fill": {
        },
        "render_line": {
        "line-cap": {
        "type": "enum",
                "values": [
                        "butt",
                        "round",
                        "square"
                ],
                "default": "butt",
                "doc": "The display of line endings."
        },
                "line-join": {
                "type": "enum",
                        "values": [
                                "bevel",
                                "round",
                                "miter"
                        ],
                        "default": "miter",
                        "doc": "The display of lines when joining."
                },
                "line-miter-limit": {
                "type": "number",
                        "default": 2,
                        "doc": "Used to automatically convert miter joins to bevel joins for sharp angles."
                },
                "line-round-limit": {
                "type": "number",
                        "default": 1,
                        "doc": "Used to automatically convert round joins to miter joins for shallow angles."
                }
        },
        "render_symbol": {
        "symbol-placement": {
        "type": "enum",
                "values": [
                        "point",
                        "line"
                ],
                "default": "point",
                "doc": "Placement of a label relative to its geometry. `Line` can only be used on LineStrings and Polygons."
        },
                "symbol-min-distance": {
                "type": "number",
                        "default": 250,
                        "doc": "Minimum distance between two symbol anchors (px)"
                },
                "symbol-avoid-edges": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the symbols will not cross tile edges. Symbols that cross tile edges may cause collisions in some cases. This property should be set to true if the layer does not have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
                },
                "icon-allow-overlap": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the icon will be visible even if it collides with other icons and text."
                },
                "icon-ignore-placement": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the icon won't affect placement of other icons and text."
                },
                "icon-optional": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, text can be shown without its corresponding icon."
                },
                "icon-rotation-alignment": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "default": "viewport",
                        "doc": "Orientation of icon when map is rotated"
                },
                "icon-max-size": {
                "type": "number",
                        "default": 1,
                        "doc": "The maximum amount to scale the icon by."
                },
                "icon-image": {
                "type": "string",
                        "doc": "A string with {tokens} replaced, referencing the data property to pull from."
                },
                "icon-rotate": {
                "type": "number",
                        "default": 0,
                        "doc": "Rotates the icon clockwise by the specified number of degrees."
                },
                "icon-padding": {
                "type": "number",
                        "default": 2,
                        "doc": "Padding value around icon bounding box to avoid icon collisions (px)."
                },
                "icon-keep-upright": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down"
                },
                "icon-offset": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ],
                        "doc": "Icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
                },
                "text-rotation-alignment": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "default": "viewport",
                        "doc": "Orientation of icon or text when map is rotated"
                },
                "text-field": {
                "type": "string",
                        "default": "",
                        "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
                },
                "text-font": {
                "type": "string",
                        "doc": "Font stack to use for displaying text."
                },
                "text-max-size": {
                "type": "number",
                        "default": 16,
                        "doc": "The maximum size text will be displayed."
                },
                "text-max-width": {
                "type": "number",
                        "default": 15,
                        "doc": "The maximum line width for text wrapping (em)."
                },
                "text-line-height": {
                "type": "number",
                        "default": 1.2,
                        "doc": "Text leading value for multi-line text."
                },
                "text-letter-spacing": {
                "type": "number",
                        "default": 0,
                        "doc": "Text kerning value (em)."
                },
                "text-justify": {
                "type": "enum",
                        "values": [
                                "center",
                                "left",
                                "right"
                        ],
                        "default": "center",
                        "doc": "Text justification options."
                },
                "text-horizontal-align": {
                "type": "enum",
                        "values": [
                                "left",
                                "center",
                                "right"
                        ],
                        "default": "center",
                        "doc": "Horizontal alignment of the text relative to the anchor."
                },
                "text-vertical-align": {
                "type": "enum",
                        "values": [
                                "top",
                                "center",
                                "bottom"
                        ],
                        "default": "center",
                        "doc": "Vertical alignment of the text relative to the anchor."
                },
                "text-max-angle": {
                "type": "number",
                        "default": 45,
                        "doc": "The maximum angle change, in degrees, allowed between adjacent characters."
                },
                "text-rotate": {
                "type": "number",
                        "default": 0,
                        "doc": "Rotates the text clockwise by the specified number of degrees."
                },
                "text-padding": {
                "type": "number",
                        "default": 2,
                        "doc": "Padding value around text bounding box to avoid label collisions (px)."
                },
                "text-keep-upright": {
                "type": "boolean",
                        "default": true,
                        "doc": "If true, the direction of the text may be flipped to prevent it from being rendered upside-down"
                },
                "text-transform": {
                "type": "enum",
                        "values": [
                                "none",
                                "uppercase",
                                "lowercase"
                        ],
                        "default": "none",
                        "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property."
                },
                "text-offset": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ]
                },
                "text-allow-overlap": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the text will be visible even if it collides with other icons and labels."
                },
                "text-ignore-placement": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, the text won't affect placement of other icons and labels."
                },
                "text-optional": {
                "type": "boolean",
                        "default": false,
                        "doc": "If true, icons can be shown without their corresponding text."
                }
        },
        "render_raster": {
        "raster-size": {
        "type": "number",
                "function": true,
                "default": 256,
                "doc": "The texture image size (in pixels) vector layers will be rasterized at. Will automatically by scaled to match the visual tile size."
        },
                "raster-blur": {
                "type": "number",
                        "function": true,
                        "default": 0,
                        "doc": "Blur radius to apply to the raster texture before display."
                }
        },
        "filter": [
        {
        "type": "filter_expression",
                "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `AND`."
        },
        {
        "type": "array",
                "value": "filter_expression",
                "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `OR`."
        }
        ],
        "filter_expression": {
        "&": {
        "type": "filter",
                "doc": "AND operator."
        },
                "|": {
                "type": "filter",
                        "doc": "OR operator."
                },
                "^": {
                "type": "filter",
                        "doc": "XOR operator."
                },
                "!": {
                "type": "filter",
                        "doc": "NOR operator."
                },
                "$type": {
                "type": "enum",
                        "values": [
                                "Point",
                                "LineString",
                                "Polygon"
                        ],
                        "doc": "Geometry type that features must match."
                },
                "*": [
                {
                "type": "filter_comparison",
                        "doc": "Arbitarily named feature member. A comparison object defining a filter expression."
                },
                {
                "type": "filter_value",
                        "doc": "Arbitarily named feature member. A filter_value implies the equality (string/number/boolean) or set membership operator (array)."
                }
                ]
        },
        "filter_comparison": {
        "==": {
        "type": "filter_value",
                "doc": "Equality operator."
        },
                "!=": {
                "type": "filter_value",
                        "doc": "Inequality operator."
                },
                ">": {
                "type": "filter_value",
                        "doc": "Greater than operator."
                },
                ">=": {
                "type": "filter_value",
                        "doc": "Greater or equal than operator."
                },
                "<": {
                "type": "filter_value",
                        "doc": "Less than operator."
                },
                "<=": {
                "type": "filter_value",
                        "doc": "Less than or equal operator."
                },
                "in": {
                "type": "array",
                        "value": "filter_primitive",
                        "doc": "Set member operator."
                },
                "!in": {
                "type": "array",
                        "value": "filter_primitive",
                        "doc": "Not in set operator."
                }
        },
        "filter_value": [
        {
        "type": "filter_primitive"
        },
        {
        "type": "array",
                "value": "filter_primitive"
        }
        ],
        "filter_primitive": [
        {
        "type": "string"
        },
        {
        "type": "number"
        },
        {
        "type": "boolean"
        }
        ],
        "function": {
        "stops": {
        "type": "array",
                "required": true,
                "doc": "An array of stops.",
                "value": "function_stop"
        },
                "base": {
                "type": "number",
                        "default": 1,
                        "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
                }
        },
        "function_stop": {
        "type": "array",
                "value": ["number", "color"],
                "length": 2,
                "doc": "Zoom level and value pair."
        },
        "class": [
                "class_fill",
                "class_line",
                "class_symbol",
                "class_raster",
                "class_background"
        ],
        "class_fill": {
        "fill-antialias": {
        "type": "boolean",
                "default": true,
                "function": true,
                "doc": "Whether or not the fill should be antialiased."
        },
                "fill-opacity": {
                "type": "number",
                        "function": true,
                        "default": 1,
                        "transition": true
                },
                "fill-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                1
                        ],
                        "function": true,
                        "transition": true
                },
                "fill-outline-color": {
                "type": "color",
                        "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
                        "function": true,
                        "transition": true
                },
                "fill-translate": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
                },
                "fill-translate-anchor": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                        "default": "map"
                },
                "fill-image": {
                "type": "string",
                        "doc": "Name of image in sprite to use for drawing image fills."
                }
        },
        "class_line": {
        "line-opacity": {
        "type": "number",
                "function": true,
                "default": 1,
                "transition": true
        },
                "line-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                1
                        ],
                        "function": true,
                        "transition": true
                },
                "line-translate": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
                },
                "line-translate-anchor": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                        "default": "map"
                },
                "line-width": {
                "type": "number",
                        "default": 1,
                        "function": true,
                        "transition": true,
                        "doc": "Line width (in px)"
                },
                "line-offset": {
                "type": "number",
                        "default": 0,
                        "doc": "Line casing where `line-offset` indicates total width. @TODO rename?",
                        "function": true,
                        "transition": true
                },
                "line-blur": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "Line blur, in pixels."
                },
                "line-dasharray": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                1,
                                - 1
                        ],
                        "function": true,
                        "transition": true
                },
                "line-image": {
                "type": "string",
                        "doc": "Name of image in sprite to use for drawing image lines."
                }
        },
        "class_symbol": {
        "icon-opacity": {
        "type": "number",
                "default": 1,
                "function": true,
                "transition": true
        },
                "icon-size": {
                "type": "number",
                        "default": 1,
                        "function": true,
                        "transition": true,
                        "doc": "The amount to scale the icon by. 1 is original size, 3 triples the size."
                },
                "icon-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                1
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "The color of the icon. This can only be used with sdf icons."
                },
                "icon-halo-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons."
                },
                "icon-halo-width": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "How far away the halo is from the icon outline, in pixels."
                },
                "icon-halo-blur": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "Fade out the halo towards the outside, in pixels."
                },
                "icon-translate": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "An icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
                },
                "icon-translate-anchor": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                        "default": "map"
                },
                "text-opacity": {
                "type": "number",
                        "default": 1,
                        "function": true,
                        "transition": true
                },
                "text-size": {
                "type": "number",
                        "default": 16,
                        "function": true,
                        "transition": true,
                        "doc": "Font size in pixels. If unspecified, the text will be as big as allowed by the layer definition."
                },
                "text-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                1
                        ],
                        "function": true,
                        "transition": true
                },
                "text-halo-color": {
                "type": "color",
                        "default": [
                                0,
                                0,
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true
                },
                "text-halo-width": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "How far away the halo is from the font outline, in pixels. Max text halo width is 1/4 of the font-size (px)."
                },
                "text-halo-blur": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "Fade out the halo towards the outside, in pixels."
                },
                "text-translate": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                0
                        ],
                        "function": true,
                        "transition": true,
                        "doc": "A label's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
                },
                "text-translate-anchor": {
                "type": "enum",
                        "values": [
                                "map",
                                "viewport"
                        ],
                        "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                        "default": "map"
                }
        },
        "class_raster": {
        "raster-opacity": {
        "type": "number",
                "default": 1,
                "transition": true
        },
                "raster-hue-rotate": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true,
                        "doc": "Rotates hues around the color wheel by the specified number of degrees."
                },
                "raster-brightness": {
                "type": "array",
                        "value": "number",
                        "length": 2,
                        "default": [
                                0,
                                1
                        ],
                        "function": true,
                        "transition": true
                },
                "raster-saturation": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true
                },
                "raster-contrast": {
                "type": "number",
                        "default": 0,
                        "function": true,
                        "transition": true
                },
                "raster-fade-duration": {
                "type": "number",
                        "default": 300,
                        "function": true,
                        "transition": true,
                        "doc": "Duration in milliseconds of the fade when a new tile is added."
                }
        },
        "class_background": {
        "background-color": {
        "type": "color",
                "default": [
                        0,
                        0,
                        0,
                        1
                ],
                "function": true,
                "transition": true
        },
                "background-image": {
                "type": "string"
                },
                "background-opacity": {
                "type": "number",
                        "default": 1,
                        "function": true,
                        "transition": true
                }
        },
        "transition": {
        "duration": {
        "type": "number",
                "default": 300,
                "doc": "Time in milliseconds that it takes for transitions to complete."
        },
                "delay": {
                "type": "number",
                        "default": 0,
                        "doc": "Time in milliseconds before a transition begins."
                }
        }
}

}, {}], 97:[function(require, module, exports){
(function (Buffer){
'use strict';
        var ieee754 = require('ieee754');
        module.exports = Protobuf;
        function Protobuf(buf) {
        this.buf = buf;
                this.pos = 0;
        }

Protobuf.prototype = {
get length() { return this.buf.length; }
};
        Protobuf.Varint = 0;
        Protobuf.Int64 = 1;
        Protobuf.Message = 2;
        Protobuf.String = 2;
        Protobuf.Packed = 2;
        Protobuf.Int32 = 5;
        Protobuf.prototype.destroy = function() {
        this.buf = null;
        };
// === READING =================================================================

        Protobuf.prototype.readUInt32 = function() {
        var val = this.buf.readUInt32LE(this.pos);
                this.pos += 4;
                return val;
        };
        Protobuf.prototype.readUInt64 = function() {
        var val = this.buf.readUInt64LE(this.pos);
                this.pos += 8;
                return val;
        };
        Protobuf.prototype.readDouble = function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
                this.pos += 8;
                return val;
        };
        Protobuf.prototype.readVarint = function() {
        // TODO: bounds checking
        var pos = this.pos;
                if (this.buf[pos] <= 0x7f) {
        this.pos++;
                return this.buf[pos];
        } else if (this.buf[pos + 1] <= 0x7f) {
        this.pos += 2;
                return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] << 7);
        } else if (this.buf[pos + 2] <= 0x7f) {
        this.pos += 3;
                return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2]) << 14;
        } else if (this.buf[pos + 3] <= 0x7f) {
        this.pos += 4;
                return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21;
        } else if (this.buf[pos + 4] <= 0x7f) {
        this.pos += 5;
                return ((this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21) + (this.buf[pos + 4] * 268435456);
        } else {
        this.skip(Protobuf.Varint);
                return 0;
                // throw new Error("TODO: Handle 6+ byte varints");
        }
        };
        Protobuf.prototype.readSVarint = function() {
        var num = this.readVarint();
                if (num > 2147483647) throw new Error('TODO: Handle numbers >= 2^30');
                // zigzag encoding
                return ((num >> 1) ^ - (num & 1));
        };
        Protobuf.prototype.readString = function() {
        var bytes = this.readVarint();
                // TODO: bounds checking
                var chr = String.fromCharCode;
                var b = this.buf;
                var p = this.pos;
                var end = this.pos + bytes;
                var str = '';
                while (p < end) {
        if (b[p] <= 0x7F) str += chr(b[p++]);
                else if (b[p] <= 0xBF) throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
                else if (b[p] <= 0xDF) str += chr((b[p++] & 0x1F) << 6 | (b[p++] & 0x3F));
                else if (b[p] <= 0xEF) str += chr((b[p++] & 0x1F) << 12 | (b[p++] & 0x3F) << 6 | (b[p++] & 0x3F));
                else if (b[p] <= 0xF7) p += 4; // We can't handle these codepoints in JS, so skip.
                else if (b[p] <= 0xFB) p += 5;
                else if (b[p] <= 0xFD) p += 6;
                else throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
        }
        this.pos += bytes;
                return str;
        };
        Protobuf.prototype.readBuffer = function() {
        var bytes = this.readVarint();
                var buffer = this.buf.subarray(this.pos, this.pos + bytes);
                this.pos += bytes;
                return buffer;
        };
        Protobuf.prototype.readPacked = function(type) {
        // TODO: bounds checking
        var bytes = this.readVarint();
                var end = this.pos + bytes;
                var array = [];
                while (this.pos < end) {
        array.push(this['read' + type]());
        }
        return array;
        };
        Protobuf.prototype.skip = function(val) {
        // TODO: bounds checking
        var type = val & 0x7;
                switch (type) {
        /* varint */ case Protobuf.Varint: while (this.buf[this.pos++] > 0x7f); break;
                /* 64 bit */ case Protobuf.Int64: this.pos += 8; break;
                /* length */ case Protobuf.Message: var bytes = this.readVarint(); this.pos += bytes; break;
                /* 32 bit */ case Protobuf.Int32: this.pos += 4; break;
                default: throw new Error('Unimplemented type: ' + type);
        }
        };
// === WRITING =================================================================

        Protobuf.prototype.writeTag = function(tag, type) {
        this.writeVarint((tag << 3) | type);
        };
        Protobuf.prototype.realloc = function(min) {
        var length = this.buf.length;
                while (length < this.pos + min) length *= 2;
                if (length != this.buf.length) {
        var buf = new Buffer(length);
                this.buf.copy(buf);
                this.buf = buf;
        }
        };
        Protobuf.prototype.finish = function() {
        return this.buf.slice(0, this.pos);
        };
        Protobuf.prototype.writePacked = function(type, tag, items) {
        if (!items.length) return;
                var message = new Protobuf();
                for (var i = 0; i < items.length; i++) {
        message['write' + type](items[i]);
        }
        var data = message.finish();
                this.writeTag(tag, Protobuf.Packed);
                this.writeBuffer(data);
        };
        Protobuf.prototype.writeUInt32 = function(val) {
        this.realloc(4);
                this.buf.writeUInt32LE(val, this.pos);
                this.pos += 4;
        };
        Protobuf.prototype.writeTaggedUInt32 = function(tag, val) {
        this.writeTag(tag, Protobuf.Int32);
                this.writeUInt32(val);
        };
        Protobuf.prototype.writeVarint = function(val) {
        val = Number(val);
                if (isNaN(val)) {
        val = 0;
        }

        if (val <= 0x7f) {
        this.realloc(1);
                this.buf[this.pos++] = val;
        } else if (val <= 0x3fff) {
        this.realloc(2);
                this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
                this.buf[this.pos++] = 0x00 | ((val >>> 7) & 0x7f);
        } else if (val <= 0x1ffffff) {
        this.realloc(3);
                this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
                this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
                this.buf[this.pos++] = 0x00 | ((val >>> 14) & 0x7f);
        } else if (val <= 0xfffffff) {
        this.realloc(4);
                this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
                this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
                this.buf[this.pos++] = 0x80 | ((val >>> 14) & 0x7f);
                this.buf[this.pos++] = 0x00 | ((val >>> 21) & 0x7f);
        } else {
        while (val > 0) {
        var b = val & 0x7f;
                val = Math.floor(val / 128);
                if (val > 0) b |= 0x80
                this.realloc(1);
                this.buf[this.pos++] = b;
        }
        }
        };
        Protobuf.prototype.writeTaggedVarint = function(tag, val) {
        this.writeTag(tag, Protobuf.Varint);
                this.writeVarint(val);
        };
        Protobuf.prototype.writeSVarint = function(val) {
        if (val >= 0) {
        this.writeVarint(val * 2);
        } else {
        this.writeVarint(val * - 2 - 1);
        }
        };
        Protobuf.prototype.writeTaggedSVarint = function(tag, val) {
        this.writeTag(tag, Protobuf.Varint);
                this.writeSVarint(val);
        };
        Protobuf.prototype.writeBoolean = function(val) {
        this.writeVarint(Boolean(val));
        };
        Protobuf.prototype.writeTaggedBoolean = function(tag, val) {
        this.writeTaggedVarint(tag, Boolean(val));
        };
        Protobuf.prototype.writeString = function(str) {
        str = String(str);
                var bytes = Buffer.byteLength(str);
                this.writeVarint(bytes);
                this.realloc(bytes);
                this.buf.write(str, this.pos);
                this.pos += bytes;
        };
        Protobuf.prototype.writeTaggedString = function(tag, str) {
        this.writeTag(tag, Protobuf.String);
                this.writeString(str);
        };
        Protobuf.prototype.writeFloat = function(val) {
        this.realloc(4);
                this.buf.writeFloatLE(val, this.pos);
                this.pos += 4;
        };
        Protobuf.prototype.writeTaggedFloat = function(tag, val) {
        this.writeTag(tag, Protobuf.Int32);
                this.writeFloat(val);
        };
        Protobuf.prototype.writeDouble = function(val) {
        this.realloc(8);
                this.buf.writeDoubleLE(val, this.pos);
                this.pos += 8;
        };
        Protobuf.prototype.writeTaggedDouble = function(tag, val) {
        this.writeTag(tag, Protobuf.Int64);
                this.writeDouble(val);
        };
        Protobuf.prototype.writeBuffer = function(buffer) {
        var bytes = buffer.length;
                this.writeVarint(bytes);
                this.realloc(bytes);
                buffer.copy(this.buf, this.pos);
                this.pos += bytes;
        };
        Protobuf.prototype.writeTaggedBuffer = function(tag, buffer) {
        this.writeTag(tag, Protobuf.String);
                this.writeBuffer(buffer);
        };
        Protobuf.prototype.writeMessage = function(tag, protobuf) {
        var buffer = protobuf.finish();
                this.writeTag(tag, Protobuf.Message);
                this.writeBuffer(buffer);
        };
        }).call(this, require("buffer").Buffer)
        }, {"buffer":88, "ieee754":98}], 98:[function(require, module, exports){
module.exports = require(90)
        }, {}], 99:[function(require, module, exports){
'use strict';
        module.exports = Point;
        function Point(x, y) {
        this.x = x;
                this.y = y;
        }

Point.prototype = {
clone: function() { return new Point(this.x, this.y); },
        add:     function(p) { return this.clone()._add(p); },
        sub:     function(p) { return this.clone()._sub(p); },
        mult:    function(k) { return this.clone()._mult(k); },
        div:     function(k) { return this.clone()._div(k); },
        rotate:  function(a) { return this.clone()._rotate(a); },
        matMult: function(m) { return this.clone()._matMult(m); },
        unit:    function() { return this.clone()._unit(); },
        perp:    function() { return this.clone()._perp(); },
        round:   function() { return this.clone()._round(); },
        mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        equals: function(p) {
        return this.x === p.x &&
                this.y === p.y;
        },
        dist: function(p) {
        return Math.sqrt(this.distSqr(p));
        },
        distSqr: function(p) {
        var dx = p.x - this.x,
                dy = p.y - this.y;
                return dx * dx + dy * dy;
        },
        angle: function() {
        return Math.atan2(this.y, this.x);
        },
        angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
        },
        angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
        },
        // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
        angleWithSep: function(x, y) {
        return Math.atan2(
                this.x * y - this.y * x,
                this.x * x + this.y * y);
        },
        _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
                y = m[2] * this.x + m[3] * this.y;
                this.x = x;
                this.y = y;
                return this;
        },
        _add: function(p) {
        this.x += p.x;
                this.y += p.y;
                return this;
        },
        _sub: function(p) {
        this.x -= p.x;
                this.y -= p.y;
                return this;
        },
        _mult: function(k) {
        this.x *= k;
                this.y *= k;
                return this;
        },
        _div: function(k) {
        this.x /= k;
                this.y /= k;
                return this;
        },
        _unit: function() {
        this._div(this.mag());
                return this;
        },
        _perp: function() {
        var y = this.y;
                this.y = this.x;
                this.x = - y;
                return this;
        },
        _rotate: function(angle) {
        var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = cos * this.x - sin * this.y,
                y = sin * this.x + cos * this.y;
                this.x = x;
                this.y = y;
                return this;
        },
        _round: function() {
        this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                return this;
        }
};
// constructs Point from an array if necessary
        Point.convert = function (a) {
        if (a instanceof Point) {
        return a;
        }
        if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
        }
        return a;
        };
        }, {}], 100:[function(require, module, exports){
(function() {
var slice = [].slice;
        function queue(parallelism) {
        var q,
                tasks = [],
                started = 0, // number of tasks that have been started (and perhaps finished)
                active = 0, // number of tasks currently being executed (started but not finished)
                remaining = 0, // number of tasks not yet finished
                popping, // inside a synchronous task callback?
                error = null,
                await = noop,
                all;
                if (!parallelism) parallelism = Infinity;
                function pop() {
                while (popping = started < tasks.length && active < parallelism) {
                var i = started++,
                        t = tasks[i],
                        a = slice.call(t, 1);
                        a.push(callback(i));
                        ++active;
                        t[0].apply(null, a);
                }
                }

        function callback(i) {
        return function(e, r) {
        --active;
                if (error != null) return;
                if (e != null) {
        error = e; // ignore new tasks and squelch active callbacks
                started = remaining = NaN; // stop queued tasks from starting
                notify();
        } else {
        tasks[i] = r;
                if (--remaining) popping || pop();
                else notify();
        }
        };
        }

        function notify() {
        if (error != null) await(error);
                else if (all) await(error, tasks);
                else await.apply(null, [error].concat(tasks));
        }

        return q = {
        defer: function() {
        if (!error) {
        tasks.push(arguments);
                ++remaining;
                pop();
        }
        return q;
        },
                await: function(f) {
                await = f;
                        all = false;
                        if (!remaining) notify();
                        return q;
                },
                awaitAll: function(f) {
                await = f;
                        all = true;
                        if (!remaining) notify();
                        return q;
                }
        };
        }

function noop() {}

queue.version = "1.0.7";
        if (typeof define === "function" && define.amd) define(function() { return queue; });
        else if (typeof module === "object" && module.exports) module.exports = queue;
        else this.queue = queue;
        })();
        }, {}], 101:[function(require, module, exports){
/*
 (c) 2013, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
 */

(function () { 'use strict';
        function rbush(maxEntries, format) {

        // jshint newcap: false, validthis: true
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);
                // max entries in a node is 9 by default; min node fill is 40% for best performance
                this._maxEntries = Math.max(4, maxEntries || 9);
                this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
                if (format) {
        this._initFormat(format);
        }

        this.clear();
        }

rbush.prototype = {

all: function () {
return this._all(this.data, []);
},
        search: function (bbox) {

        var node = this.data,
                result = [],
                toBBox = this.toBBox;
                if (!intersects(bbox, node.bbox)) return result;
                var nodesToSearch = [],
                i, len, child, childBBox;
                while (node) {
        for (i = 0, len = node.children.length; i < len; i++) {

        child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;
                if (intersects(bbox, childBBox)) {
        if (node.leaf) result.push(child);
                else if (contains(bbox, childBBox)) this._all(child, result);
                else nodesToSearch.push(child);
        }
        }
        node = nodesToSearch.pop();
        }

        return result;
        },
        load: function (data) {
        if (!(data && data.length)) return this;
                if (data.length < this._minEntries) {
        for (var i = 0, len = data.length; i < len; i++) {
        this.insert(data[i]);
        }
        return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);
                if (!this.data.children.length) {
        // save as is if tree is empty
        this.data = node;
        } else if (this.data.height === node.height) {
        // split root if trees have the same height
        this._splitRoot(this.data, node);
        } else {
        if (this.data.height < node.height) {
        // swap trees if inserted one is bigger
        var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
        }

        // insert the small tree into the large tree at appropriate level
        this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
        },
        insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
                return this;
        },
        clear: function () {
        this.data = {
        children: [],
                height: 1,
                bbox: empty(),
                leaf: true
        };
                return this;
        },
        remove: function (item) {
        if (!item) return this;
                var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i, parent, index, goingUp;
                // depth-first iterative tree traversal
                while (node || path.length) {

        if (!node) { // go up
        node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
        }

        if (node.leaf) { // check current node
        index = node.children.indexOf(item);
                if (index !== - 1) {
        // item found, remove the item and condense tree upwards
        node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
        }
        }

        if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
        path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];
        } else if (parent) { // go right
        i++;
                node = parent.children[i];
                goingUp = false;
        } else node = null; // nothing found
        }

        return this;
        },
        toBBox: function (item) { return item; },
        compareMinX: function (a, b) { return a[0] - b[0]; },
        compareMinY: function (a, b) { return a[1] - b[1]; },
        toJSON: function () { return this.data; },
        fromJSON: function (data) {
        this.data = data;
                return this;
        },
        _all: function (node, result) {
        var nodesToSearch = [];
                while (node) {
        if (node.leaf) result.push.apply(result, node.children);
                else nodesToSearch.push.apply(nodesToSearch, node.children);
                node = nodesToSearch.pop();
        }
        return result;
        },
        _build: function (items, left, right, height) {

        var N = right - left + 1,
                M = this._maxEntries,
                node;
                if (N <= M) {
        // reached leaf level; return leaf
        node = {
        children: items.slice(left, right + 1),
                height: 1,
                bbox: null,
                leaf: true
        };
                calcBBox(node, this.toBBox);
                return node;
        }

        if (!height) {
        // target height of the bulk-loaded tree
        height = Math.ceil(Math.log(N) / Math.log(M));
                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
        }

        // TODO eliminate recursion?

        node = {
        children: [],
                height: height,
                bbox: null
        };
                // split the items into M mostly square tiles

                var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i, j, right2, right3;
                multiSelect(items, left, right, N1, this.compareMinX);
                for (i = left; i <= right; i += N1) {

        right2 = Math.min(i + N1 - 1, right);
                multiSelect(items, i, right2, N2, this.compareMinY);
                for (j = i; j <= right2; j += N2) {

        right3 = Math.min(j + N2 - 1, right2);
                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
        }
        }

        calcBBox(node, this.toBBox);
                return node;
        },
        _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
                while (true) {
        path.push(node);
                if (node.leaf || path.length - 1 === level) break;
                minArea = minEnlargement = Infinity;
                for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
                area = bboxArea(child.bbox);
                enlargement = enlargedArea(bbox, child.bbox) - area;
                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
        minEnlargement = enlargement;
                minArea = area < minArea ? area : minArea;
                targetNode = child;
        } else if (enlargement === minEnlargement) {
        // otherwise choose one with the smallest area
        if (area < minArea) {
        minArea = area;
                targetNode = child;
        }
        }
        }

        node = targetNode;
        }

        return node;
        },
        _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
                bbox = isNode ? item.bbox : toBBox(item),
                insertPath = [];
                // find the best node for accommodating the item, saving all nodes along the path too
                var node = this._chooseSubtree(bbox, this.data, level, insertPath);
                // put the item into the node
                node.children.push(item);
                extend(node.bbox, bbox);
                // split on node overflow; propagate upwards if necessary
                while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
                level--;
        } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
        },
        // split overflowed node into two
        _split: function (insertPath, level) {

        var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;
                this._chooseSplitAxis(node, m, M);
                var newNode = {
                children: node.children.splice(this._chooseSplitIndex(node, m, M)),
                        height: node.height
                };
                if (node.leaf) newNode.leaf = true;
                calcBBox(node, this.toBBox);
                calcBBox(newNode, this.toBBox);
                if (level) insertPath[level - 1].children.push(newNode);
                else this._splitRoot(node, newNode);
        },
        _splitRoot: function (node, newNode) {
        // split root node
        this.data = {
        children: [node, newNode],
                height: node.height + 1
        };
                calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
                minOverlap = minArea = Infinity;
                for (i = m; i <= M - m; i++) {
        bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);
                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);
                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
        minOverlap = overlap;
                index = i;
                minArea = area < minArea ? area : minArea;
        } else if (overlap === minOverlap) {
        // otherwise choose distribution with minimum area
        if (area < minArea) {
        minArea = area;
                index = i;
        }
        }
        }

        return index;
        },
        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);
                // if total distributions margin value is minimal for x, sort by minX,
                // otherwise it's already sorted by minY
                if (xMargin < yMargin) node.children.sort(compareMinX);
        },
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);
                var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i, child;
                for (i = m; i < M - m; i++) {
        child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
                margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
        child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
                margin += bboxMargin(rightBBox);
        }

        return margin;
        },
        _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
        extend(path[i].bbox, bbox);
        }
        },
        _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
        if (path[i].children.length === 0) {
        if (i > 0) {
        siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
        } else calcBBox(path[i], this.toBBox);
        }
        },
        _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];
                this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
                this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
                this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
        }
};
// calculate node's bbox from bboxes of its children
        function calcBBox(node, toBBox) {
        node.bbox = distBBox(node, 0, node.children.length, toBBox);
        }

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox) {
var bbox = empty();
        for (var i = k, child; i < p; i++) {
child = node.children[i];
        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
}

return bbox;
        }

function empty() { return [Infinity, Infinity, - Infinity, - Infinity]; }

function extend(a, b) {
a[0] = Math.min(a[0], b[0]);
        a[1] = Math.min(a[1], b[1]);
        a[2] = Math.max(a[2], b[2]);
        a[3] = Math.max(a[3], b[3]);
        return a;
        }

function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

function enlargedArea(a, b) {
return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
        (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
        }

function intersectionArea (a, b) {
var minX = Math.max(a[0], b[0]),
        minY = Math.max(a[1], b[1]),
        maxX = Math.min(a[2], b[2]),
        maxY = Math.min(a[3], b[3]);
        return Math.max(0, maxX - minX) *
        Math.max(0, maxY - minY);
        }

function contains(a, b) {
return a[0] <= b[0] &&
        a[1] <= b[1] &&
        b[2] <= a[2] &&
        b[3] <= a[3];
        }

function intersects (a, b) {
return b[0] <= a[2] &&
        b[1] <= a[3] &&
        b[2] >= a[0] &&
        b[3] >= a[1];
        }

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
var stack = [left, right],
        mid;
        while (stack.length) {
right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        select(arr, left, right, mid, compare);
        stack.push(left, mid, mid, right);
}
}

// sort array between left and right (inclusive) so that the smallest k elements come first (unordered)
function select(arr, left, right, k, compare) {
var n, i, z, s, sd, newLeft, newRight, t, j;
        while (right > left) {
if (right - left > 600) {
n = right - left + 1;
        i = k - left + 1;
        z = Math.log(n);
        s = 0.5 * Math.exp(2 * z / 3);
        sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? - 1 : 1);
        newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
        newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
        select(arr, newLeft, newRight, k, compare);
}

t = arr[k];
        i = left;
        j = right;
        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);
        while (i < j) {
swap(arr, i, j);
        i++;
        j--;
        while (compare(arr[i], t) < 0) i++;
        while (compare(arr[j], t) > 0) j--;
}

if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
        j++;
                swap(arr, j, right);
        }

if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
}
}

function swap(arr, i, j) {
var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        }


// export as AMD/CommonJS module or global variable
if (typeof define === 'function' && define.amd) define(function() { return rbush; });
        else if (typeof module !== 'undefined') module.exports = rbush;
        else if (typeof self !== 'undefined') self.rbush = rbush;
        else window.rbush = rbush;
        })();
        }, {}], 102:[function(require, module, exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;
        function UnitBezier(p1x, p1y, p2x, p2y) {
        // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
        this.cx = 3.0 * p1x;
                this.bx = 3.0 * (p2x - p1x) - this.cx;
                this.ax = 1.0 - this.cx - this.bx;
                this.cy = 3.0 * p1y;
                this.by = 3.0 * (p2y - p1y) - this.cy;
                this.ay = 1.0 - this.cy - this.by;
                this.p1x = p1x;
                this.p1y = p2y;
                this.p2x = p2x;
                this.p2y = p2y;
        }

UnitBezier.prototype.sampleCurveX = function(t) {
// `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
return ((this.ax * t + this.bx) * t + this.cx) * t;
        };
        UnitBezier.prototype.sampleCurveY = function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
        };
        UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
        };
        UnitBezier.prototype.solveCurveX = function(x, epsilon) {
        if (typeof epsilon === 'undefined') epsilon = 1e-6;
                var t0, t1, t2, x2, i;
                // First try a few iterations of Newton's method -- normally very fast.
                for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
                if (Math.abs(x2) < epsilon) return t2;
                var d2 = this.sampleCurveDerivativeX(t2);
                if (Math.abs(d2) < 1e-6) break;
                t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
                t1 = 1.0;
                t2 = x;
                if (t2 < t0) return t0;
                if (t2 > t1) return t1;
                while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
                if (Math.abs(x2 - x) < epsilon) return t2;
                if (x > x2) {
        t0 = t2;
        } else {
        t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
        }

        // Failure.
        return t2;
        };
        UnitBezier.prototype.solve = function(x, epsilon) {
        return this.sampleCurveY(this.solveCurveX(x, epsilon));
        };
        }, {}], 103:[function(require, module, exports){
module.exports.VectorTile = require('./lib/vectortile.js');
        module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
        module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');
        }, {"./lib/vectortile.js":104, "./lib/vectortilefeature.js":105, "./lib/vectortilelayer.js":106}], 104:[function(require, module, exports){
'use strict';
        var VectorTileLayer = require('./vectortilelayer');
        module.exports = VectorTile;
        function VectorTile(buffer, end) {

        this.layers = {};
                this._buffer = buffer;
                end = end || buffer.length;
                while (buffer.pos < end) {
        var val = buffer.readVarint(),
                tag = val >> 3;
                if (tag == 3) {
        var layer = this.readLayer();
                if (layer.length) this.layers[layer.name] = layer;
        } else {
        buffer.skip(val);
        }
        }
        }

VectorTile.prototype.readLayer = function() {
var buffer = this._buffer,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        layer = new VectorTileLayer(buffer, end);
        buffer.pos = end;
        return layer;
        };
        }, {"./vectortilelayer":106}], 105:[function(require, module, exports){
'use strict';
        var Point = require('point-geometry');
        module.exports = VectorTileFeature;
        function VectorTileFeature(buffer, end, extent, keys, values) {

        this.properties = {};
                // Public
                this.extent = extent;
                this.type = 0;
                // Private
                this._buffer = buffer;
                this._geometry = - 1;
                end = end || buffer.length;
                while (buffer.pos < end) {
        var val = buffer.readVarint(),
                tag = val >> 3;
                if (tag == 1) {
        this._id = buffer.readVarint();
        } else if (tag == 2) {
        var tagEnd = buffer.pos + buffer.readVarint();
                while (buffer.pos < tagEnd) {
        var key = keys[buffer.readVarint()];
                var value = values[buffer.readVarint()];
                this.properties[key] = value;
        }

        } else if (tag == 3) {
        this.type = buffer.readVarint();
        } else if (tag == 4) {
        this._geometry = buffer.pos;
                buffer.skip(val);
        } else {
        buffer.skip(val);
        }
        }
        }

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];
        VectorTileFeature.prototype.loadGeometry = function() {
        var buffer = this._buffer;
                buffer.pos = this._geometry;
                var bytes = buffer.readVarint(),
                end = buffer.pos + bytes,
                cmd = 1,
                length = 0,
                x = 0,
                y = 0,
                lines = [],
                line;
                while (buffer.pos < end) {
        if (!length) {
        var cmd_length = buffer.readVarint();
                cmd = cmd_length & 0x7;
                length = cmd_length >> 3;
        }

        length--;
                if (cmd === 1 || cmd === 2) {
        x += buffer.readSVarint();
                y += buffer.readSVarint();
                if (cmd === 1) {
        // moveTo
        if (line) {
        lines.push(line);
        }
        line = [];
        }

        line.push(new Point(x, y));
        } else if (cmd === 7) {
        // closePolygon
        line.push(line[0].clone());
        } else {
        throw new Error('unknown command ' + cmd);
        }
        }

        if (line) lines.push(line);
                return lines;
        };
        VectorTileFeature.prototype.bbox = function() {
        var buffer = this._buffer;
                buffer.pos = this._geometry;
                var bytes = buffer.readVarint(),
                end = buffer.pos + bytes,
                cmd = 1,
                length = 0,
                x = 0,
                y = 0,
                x1 = Infinity,
                x2 = - Infinity,
                y1 = Infinity,
                y2 = - Infinity;
                while (buffer.pos < end) {
        if (!length) {
        var cmd_length = buffer.readVarint();
                cmd = cmd_length & 0x7;
                length = cmd_length >> 3;
        }

        length--;
                if (cmd === 1 || cmd === 2) {
        x += buffer.readSVarint();
                y += buffer.readSVarint();
                if (x < x1) x1 = x;
                if (x > x2) x2 = x;
                if (y < y1) y1 = y;
                if (y > y2) y2 = y;
        } else if (cmd !== 7) {
        throw new Error('unknown command ' + cmd);
        }
        }

        return [x1, y1, x2, y2];
        };
        }, {"point-geometry":99}], 106:[function(require, module, exports){
'use strict';
        var VectorTileFeature = require('./vectortilefeature.js');
        module.exports = VectorTileLayer;
        function VectorTileLayer(buffer, end) {
        // Public
        this.version = 1;
                this.name = null;
                this.extent = 4096;
                this.length = 0;
                // Private
                this._buffer = buffer;
                this._keys = [];
                this._values = [];
                this._features = [];
                var val, tag;
                end = end || buffer.length;
                while (buffer.pos < end) {
        val = buffer.readVarint();
                tag = val >> 3;
                if (tag === 15) {
        this.version = buffer.readVarint();
        } else if (tag === 1) {
        this.name = buffer.readString();
        } else if (tag === 5) {
        this.extent = buffer.readVarint();
        } else if (tag === 2) {
        this.length++;
                this._features.push(buffer.pos);
                buffer.skip(val);
        } else if (tag === 3) {
        this._keys.push(buffer.readString());
        } else if (tag === 4) {
        this._values.push(this.readFeatureValue());
        } else {
        buffer.skip(val);
        }
        }
        }

VectorTileLayer.prototype.readFeatureValue = function() {
var buffer = this._buffer,
        value = null,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        val, tag;
        while (buffer.pos < end) {
val = buffer.readVarint();
        tag = val >> 3;
        if (tag == 1) {
value = buffer.readString();
} else if (tag == 2) {
throw new Error('read float');
} else if (tag == 3) {
value = buffer.readDouble();
} else if (tag == 4) {
value = buffer.readVarint();
} else if (tag == 5) {
throw new Error('read uint');
} else if (tag == 6) {
value = buffer.readSVarint();
} else if (tag == 7) {
value = Boolean(buffer.readVarint());
} else {
buffer.skip(val);
}
}

return value;
        };
// return feature `i` from this layer as a `VectorTileFeature`
        VectorTileLayer.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');
                this._buffer.pos = this._features[i];
                var end = this._buffer.readVarint() + this._buffer.pos;
                return new VectorTileFeature(this._buffer, end, this.extent, this._keys, this._values);
        };
        }, {"./vectortilefeature.js":105}]}, {}, [22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRGF2aWRcXERldlxcbWFwYm94XFxtYXBib3gtZ2wtanNcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvYnVmZmVyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZmlsbGVsZW1lbnRzYnVmZmVyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZmlsbHZlcnRleGJ1ZmZlci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2dseXBodmVydGV4YnVmZmVyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvaWNvbnZlcnRleGJ1ZmZlci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2xpbmVlbGVtZW50YnVmZmVyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvbGluZXZlcnRleGJ1ZmZlci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL291dGxpbmVlbGVtZW50c2J1ZmZlci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvY3JlYXRlYnVja2V0LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9lbGVtZW50Z3JvdXBzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9mZWF0dXJldHJlZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvZmlsbGJ1Y2tldC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvbGluZWJ1Y2tldC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2RhdGEvcmFzdGVyYnVja2V0LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZGF0YS9zeW1ib2xidWNrZXQuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9nZW8vbGF0bG5nLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvZ2VvL2xhdGxuZ2JvdW5kcy5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL2dlby90cmFuc2Zvcm0uanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9saWIvZGVidWd0ZXh0LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvbGliL2dsbWF0cml4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvbWFwYm94LWdsLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdiYWNrZ3JvdW5kLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdkZWJ1Zy5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3ZmlsbC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3bGluZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3cmFzdGVyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdzeW1ib2wuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd3ZlcnRpY2VzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2ZyYW1laGlzdG9yeS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9nbHV0aWwuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9yZW5kZXIvcGFpbnRlci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9wcmVyZW5kZXJlZC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9zaGFkZXJzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc291cmNlL2dlb2pzb25zb3VyY2UuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbnRpbGUuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbndyYXBwZXIuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvcmFzdGVydGlsZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS9zb3VyY2UuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdGlsZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS90aWxlY29vcmQuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdGlsZWdlb2pzb24uanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdmVjdG9ydGlsZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS92aWRlb3NvdXJjZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS93b3JrZXIuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvd29ya2VydGlsZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N0eWxlL2FuaW1hdGlvbmxvb3AuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zdHlsZS9idWNrZXRmaWx0ZXIuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zdHlsZS9jYWxjdWxhdGVkc3R5bGUuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zdHlsZS9pbWFnZXNwcml0ZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3JlZmVyZW5jZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3JlbmRlcnByb3BlcnRpZXMuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZS5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlY29uc3RhbnQuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZWRlY2xhcmF0aW9uLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3R5bGUvc3R5bGV0cmFuc2l0aW9uLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2FuY2hvci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9iaW5wYWNrLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2NvbGxpc2lvbi5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9nbHlwaGF0bGFzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2dseXBoc291cmNlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2ludGVycG9sYXRlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3BsYWNlbWVudC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9yZXNvbHZldGV4dC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9yb3RhdGlvbnJhbmdlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3NoYXBpbmcuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy91aS9jb250cm9sL2F0dHJpYnV0aW9uLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9jb250cm9sLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9uYXZpZ2F0aW9uLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdWkvZWFzaW5ncy5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3VpL2hhbmRsZXJzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdWkvaGFzaC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3VpL2ludGVyYWN0aW9uLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdWkvbWFwLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC9hY3Rvci5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3V0aWwvYnJvd3Nlci9hamF4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy91dGlsL2Jyb3dzZXIvY2FudmFzLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Rpc3BhdGNoZXIuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy91dGlsL2NvbmZpZy5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3V0aWwvZG9tLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC9ldmVudGVkLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC9nbHlwaHMuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy91dGlsL21hcGJveC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL2pzL3V0aWwvbXJ1Y2FjaGUuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9qcy91dGlsL3Rva2VuLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvanMvdXRpbC91dGlsLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIkM6L1VzZXJzL0RhdmlkL0Rldi9tYXBib3gvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL2luZGV4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL25vZGVfbW9kdWxlcy9nZW9qc29uLWFyZWEvaW5kZXguanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvbm9kZV9tb2R1bGVzL2dlb2pzb24tYXJlYS9ub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y1Lmpzb24iLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3BvaW50LWdlb21ldHJ5L2luZGV4LmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3F1ZXVlLWFzeW5jL3F1ZXVlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3JidXNoL3JidXNoLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3VuaXRiZXppZXIvaW5kZXguanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvaW5kZXguanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGUuanMiLCJDOi9Vc2Vycy9EYXZpZC9EZXYvbWFwYm94L21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzIiwiQzovVXNlcnMvRGF2aWQvRGV2L21hcGJveC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBhIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCBhIHNpbmdsZSBhcnJheWJ1ZmZlclxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBCdWZmZXIoYnVmZmVyKSB7XHJcbiAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5kZWZhdWx0TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGVmYXVsdExlbmd0aDtcclxuICAgICAgICB0aGlzLnNldHVwVmlld3MoKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHdlIG9ubHkgcmVjcmVhdGUgYnVmZmVycyBhZnRlciByZWNlaXZpbmcgdGhlbSBmcm9tIHdvcmtlcnMgZm9yIGJpbmRpbmcgdG8gZ2wsXHJcbiAgICAgICAgLy8gc28gd2Ugb25seSBuZWVkIHRoZXNlIDIgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBidWZmZXIuYXJyYXk7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBidWZmZXIucG9zO1xyXG4gICAgfVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlID0ge1xyXG4gICAgcG9zOiAwLFxyXG4gICAgaXRlbVNpemU6IDQsIC8vIGJ5dGVzIGluIG9uZSBpdGVtXHJcbiAgICBkZWZhdWx0TGVuZ3RoOiA4MTkyLCAvLyBpbml0aWFsIGJ1ZmZlciBzaXplXHJcbiAgICBhcnJheVR5cGU6ICdBUlJBWV9CVUZGRVInLCAvLyBnbCBidWZmZXIgdHlwZVxyXG5cclxuICAgIGdldCBpbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLyB0aGlzLml0ZW1TaXplO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXR1cFZpZXdzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBzZXQgdXAgdmlld3MgZm9yIGVhY2ggdHlwZSB0byBhZGQgZGF0YSBvZiBkaWZmZXJlbnQgdHlwZXMgdG8gdGhlIHNhbWUgYnVmZmVyXHJcbiAgICAgICAgdGhpcy51Ynl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5KTtcclxuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IEludDhBcnJheSh0aGlzLmFycmF5KTtcclxuICAgICAgICB0aGlzLnVzaG9ydHMgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheSk7XHJcbiAgICAgICAgdGhpcy5zaG9ydHMgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gYmluZHMgdGhlIGJ1ZmZlciB0byBhIHdlYmdsIGNvbnRleHRcclxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsKSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBnbFt0aGlzLmFycmF5VHlwZV07XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBuZXcgRGF0YVZpZXcodGhpcy5hcnJheSwgMCwgdGhpcy5wb3MpLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICAvLyBkdW1wIGFycmF5IGJ1ZmZlciBvbmNlIGl0J3MgYm91bmQgdG8gZ2xcclxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbihnbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlciBzaXplIGJ5IDUwJSBpZiBhIG5ldyBpdGVtIGRvZXNuJ3QgZml0XHJcbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMucG9zICsgdGhpcy5pdGVtU2l6ZSkge1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgdGhpcy5wb3MgKyB0aGlzLml0ZW1TaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGVuZ3RoIGJ5IDUwJSBidXQga2VlcCBpdCBldmVuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgucm91bmQodGhpcy5sZW5ndGggKiAxLjUgLyAyKSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFycmF5IGJ1ZmZlcnMgY2FuJ3QgYmUgcmVzaXplZCwgc28gd2UgY3JlYXRlIGEgbmV3IG9uZSBhbmQgcmVzZXQgYWxsIGJ5dGVzIHRoZXJlXHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xyXG4gICAgICAgICAgICB1Ynl0ZXMuc2V0KHRoaXMudWJ5dGVzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXBWaWV3cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIExpbmVWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2xpbmV2ZXJ0ZXhidWZmZXIuanMnKTtcclxudmFyIExpbmVFbGVtZW50QnVmZmVyID0gcmVxdWlyZSgnLi9saW5lZWxlbWVudGJ1ZmZlci5qcycpO1xyXG52YXIgRmlsbFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZmlsbHZlcnRleGJ1ZmZlci5qcycpO1xyXG52YXIgRmlsbEVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL2ZpbGxlbGVtZW50c2J1ZmZlci5qcycpO1xyXG52YXIgT3V0bGluZUVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL291dGxpbmVlbGVtZW50c2J1ZmZlci5qcycpO1xyXG52YXIgR2x5cGhWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2dseXBodmVydGV4YnVmZmVyLmpzJyk7XHJcbnZhciBJY29uVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9pY29udmVydGV4YnVmZmVyLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcnNldCkge1xyXG4gICAgYnVmZmVyc2V0ID0gYnVmZmVyc2V0IHx8IHt9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnbHlwaFZlcnRleDogbmV3IEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5nbHlwaFZlcnRleCksXHJcbiAgICAgICAgaWNvblZlcnRleDogbmV3IEljb25WZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0Lmljb25WZXJ0ZXgpLFxyXG4gICAgICAgIGZpbGxWZXJ0ZXg6IG5ldyBGaWxsVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5maWxsVmVydGV4KSxcclxuICAgICAgICBmaWxsRWxlbWVudDogbmV3IEZpbGxFbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5maWxsRWxlbWVudCksXHJcbiAgICAgICAgb3V0bGluZUVsZW1lbnQ6IG5ldyBPdXRsaW5lRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQub3V0bGluZUVsZW1lbnQpLFxyXG4gICAgICAgIGxpbmVWZXJ0ZXg6IG5ldyBMaW5lVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5saW5lVmVydGV4KSxcclxuICAgICAgICBsaW5lRWxlbWVudDogbmV3IExpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5saW5lRWxlbWVudClcclxuICAgIH07XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxsRWxlbWVudHNCdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBGaWxsRWxlbWVudHNCdWZmZXIoYnVmZmVyKSB7XHJcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xyXG59XHJcblxyXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcclxuXHJcbkZpbGxFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA2OyAvLyBieXRlcyBwZXIgdHJpYW5nbGUgKDMgKiB1bnNpZ25lZCBzaG9ydCA9PSA2IGJ5dGVzKVxyXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFycmF5VHlwZSA9ICdFTEVNRU5UX0FSUkFZX0JVRkZFUic7XHJcblxyXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xyXG5cclxuICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XHJcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcclxuICAgIHRoaXMudXNob3J0c1twb3MyICsgMl0gPSBjO1xyXG5cclxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxsVmVydGV4QnVmZmVyO1xyXG5cclxuZnVuY3Rpb24gRmlsbFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcclxuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XHJcbn1cclxuXHJcbkZpbGxWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcclxuXHJcbkZpbGxWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLml0ZW1TaXplID0gNDsgLy8gYnl0ZXMgcGVyIHZlcnRleCAoMiAqIHNob3J0ID09IDQgYnl0ZXMpXHJcblxyXG5GaWxsVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgcG9zMiA9IHRoaXMucG9zIC8gMjtcclxuXHJcbiAgICB0aGlzLnJlc2l6ZSgpO1xyXG5cclxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHg7XHJcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSB5O1xyXG5cclxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFZlcnRleEJ1ZmZlcjtcclxuXHJcbmZ1bmN0aW9uIEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcclxufVxyXG5cclxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcclxuXHJcbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZS5kZWZhdWx0TGVuZ3RoID0gMjA0OCAqIDE2O1xyXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSAxNjtcclxuXHJcbi8vIENvbnZlcnRzIHRoZSAwLi4ycGkgdG8gYW4gaW50MTYgcmFuZ2VcclxuR2x5cGhWZXJ0ZXhCdWZmZXIuYW5nbGVGYWN0b3IgPSAxMjggLyBNYXRoLlBJO1xyXG5cclxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHksIG94LCBveSwgdHgsIHR5LCBhbmdsZSwgbWluem9vbSwgcmFuZ2UsIG1heHpvb20sIGxhYmVsbWluem9vbSkge1xyXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zLFxyXG4gICAgICAgIHBvczIgPSBwb3MgLyAyLFxyXG4gICAgICAgIGFuZ2xlRmFjdG9yID0gR2x5cGhWZXJ0ZXhCdWZmZXIuYW5nbGVGYWN0b3I7XHJcblxyXG4gICAgdGhpcy5yZXNpemUoKTtcclxuXHJcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSB4O1xyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0geTtcclxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAyXSA9IE1hdGgucm91bmQob3ggKiA2NCk7IC8vIHVzZSAxLzY0IHBpeGVscyBmb3IgcGxhY2VtZW50XHJcbiAgICB0aGlzLnNob3J0c1twb3MyICsgM10gPSBNYXRoLnJvdW5kKG95ICogNjQpO1xyXG5cclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDhdID0gTWF0aC5mbG9vcigobGFiZWxtaW56b29tIHx8IDApICogMTApO1xyXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gPSBNYXRoLmZsb29yKChtaW56b29tIHx8IDApICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxyXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTBdID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXh6b29tIHx8IDI1LCAyNSkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXHJcbiAgICB0aGlzLnVieXRlc1twb3MgKyAxMV0gPSBNYXRoLnJvdW5kKGFuZ2xlICogYW5nbGVGYWN0b3IpICUgMjU2O1xyXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTJdID0gTWF0aC5tYXgoTWF0aC5yb3VuZChyYW5nZVswXSAqIGFuZ2xlRmFjdG9yKSwgMCkgJSAyNTY7XHJcbiAgICB0aGlzLnVieXRlc1twb3MgKyAxM10gPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJhbmdlWzFdICogYW5nbGVGYWN0b3IpLCAyNTUpICUgMjU2O1xyXG5cclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDE0XSA9IE1hdGguZmxvb3IodHggLyA0KTtcclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDE1XSA9IE1hdGguZmxvb3IodHkgLyA0KTtcclxuXHJcbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2x5cGhWZXJ0ZXhCdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBHbHlwaFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcclxuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XHJcbn1cclxuXHJcbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XHJcblxyXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZGVmYXVsdExlbmd0aCA9IDIwNDggKiAyMDtcclxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLml0ZW1TaXplID0gMjA7XHJcblxyXG4vLyBDb252ZXJ0cyB0aGUgMC4uMnBpIHRvIGFuIGludDE2IHJhbmdlXHJcbkdseXBoVmVydGV4QnVmZmVyLmFuZ2xlRmFjdG9yID0gMTI4IC8gTWF0aC5QSTtcclxuXHJcbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5LCBveCwgb3ksIHR4LCB0eSwgYW5nbGUsIG1pbnpvb20sIHJhbmdlLCBtYXh6b29tLCBsYWJlbG1pbnpvb20pIHtcclxuICAgIHZhciBwb3MgPSB0aGlzLnBvcyxcclxuICAgICAgICBwb3MyID0gcG9zIC8gMixcclxuICAgICAgICBhbmdsZUZhY3RvciA9IEdseXBoVmVydGV4QnVmZmVyLmFuZ2xlRmFjdG9yO1xyXG5cclxuICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0geDtcclxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHk7XHJcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMl0gPSBNYXRoLnJvdW5kKG94ICogNjQpOyAvLyB1c2UgMS82NCBwaXhlbHMgZm9yIHBsYWNlbWVudFxyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDNdID0gTWF0aC5yb3VuZChveSAqIDY0KTtcclxuXHJcbiAgICB0aGlzLnVieXRlc1twb3MgKyA4XSA9IE1hdGguZmxvb3IoKGxhYmVsbWluem9vbSB8fCAwKSAqIDEwKTtcclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDldID0gTWF0aC5mbG9vcigobWluem9vbSB8fCAwKSAqIDEwKTsgLy8gMS8xMCB6b29tIGxldmVsczogejE2ID09IDE2MC5cclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEwXSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4em9vbSB8fCAyNSwgMjUpICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxyXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTFdID0gTWF0aC5yb3VuZChhbmdsZSAqIGFuZ2xlRmFjdG9yKSAlIDI1NjtcclxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEyXSA9IE1hdGgubWF4KE1hdGgucm91bmQocmFuZ2VbMF0gKiBhbmdsZUZhY3RvciksIDApICUgMjU2O1xyXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTNdID0gTWF0aC5taW4oTWF0aC5yb3VuZChyYW5nZVsxXSAqIGFuZ2xlRmFjdG9yKSwgMjU1KSAlIDI1NjtcclxuXHJcbiAgICB0aGlzLnNob3J0c1twb3MyICsgOF0gPSB0eDtcclxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyA5XSA9IHR5O1xyXG5cclxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lRWxlbWVudEJ1ZmZlcjtcclxuXHJcbmZ1bmN0aW9uIExpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcclxufVxyXG5cclxuTGluZUVsZW1lbnRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcclxuXHJcbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDY7IC8vIGJ5dGVzIHBlciB0cmlhbmdsZSAoMyAqIHVuc2lnbmVkIHNob3J0ID09IDYgYnl0ZXMpXHJcbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZS5hcnJheVR5cGUgPSAnRUxFTUVOVF9BUlJBWV9CVUZGRVInO1xyXG5cclxuTGluZUVsZW1lbnRCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xyXG5cclxuICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XHJcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcclxuICAgIHRoaXMudXNob3J0c1twb3MyICsgMl0gPSBjO1xyXG5cclxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVmVydGV4QnVmZmVyO1xyXG5cclxuZnVuY3Rpb24gTGluZVZlcnRleEJ1ZmZlcihidWZmZXIpIHtcclxuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XHJcbn1cclxuXHJcbi8vIHNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIHNvIHRoYXQgdGhlIG5vcm1hbCBsZW5ndGggaXMgdGhpcyB2YWx1ZS5cclxuLy8gY29udGFpbnMgdGhlIFwidGV4dHVyZVwiIG5vcm1hbHMgKC0xLi4xKS4gdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBleHRydWRlXHJcbi8vIG5vcm1hbHMgZm9yIGxpbmUgam9pbnMsIGJlY2F1c2UgdGhlIHgtdmFsdWUgcmVtYWlucyAwIGZvciB0aGUgdGV4dHVyZVxyXG4vLyBub3JtYWwgYXJyYXksIHdoaWxlIHRoZSBleHRydWRlIG5vcm1hbCBhY3R1YWxseSBtb3ZlcyB0aGUgdmVydGV4IHRvIGNyZWF0ZVxyXG4vLyB0aGUgYWN1dGUvYmV2ZWxsZWQgbGluZSBqb2luLlxyXG5MaW5lVmVydGV4QnVmZmVyLmV4dHJ1ZGVTY2FsZSA9IDYzO1xyXG5cclxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpO1xyXG5cclxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA4OyAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgKyAxICogc2hvcnQgKyAyICogYnl0ZSA9IDggYnl0ZXMpXHJcbkxpbmVWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmRlZmF1bHRMZW5ndGggPSAzMjc2ODtcclxuXHJcbi8vIGFkZCBhIHZlcnRleCB0byB0aGlzIGJ1ZmZlcjtcclxuLy8geCwgeSAtIHZlcnRleCBwb3NpdGlvblxyXG4vLyBleCwgZXkgLSBleHRydWRlIG5vcm1hbFxyXG4vLyB0eCwgdHkgLSB0ZXh0dXJlIG5vcm1hbFxyXG5cclxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocG9pbnQsIGV4dHJ1ZGUsIHR4LCB0eSwgbGluZXNvZmFyKSB7XHJcbiAgICB2YXIgcG9zID0gdGhpcy5wb3MsXHJcbiAgICAgICAgcG9zMiA9IHBvcyAvIDIsXHJcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4LFxyXG4gICAgICAgIGV4dHJ1ZGVTY2FsZSA9IExpbmVWZXJ0ZXhCdWZmZXIuZXh0cnVkZVNjYWxlO1xyXG5cclxuICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0gKE1hdGguZmxvb3IocG9pbnQueCkgKiAyKSB8IHR4O1xyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0gKE1hdGguZmxvb3IocG9pbnQueSkgKiAyKSB8IHR5O1xyXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChsaW5lc29mYXIgfHwgMCk7XHJcbiAgICB0aGlzLmJ5dGVzW3BvcyArIDZdID0gTWF0aC5yb3VuZChleHRydWRlU2NhbGUgKiBleHRydWRlLngpO1xyXG4gICAgdGhpcy5ieXRlc1twb3MgKyA3XSA9IE1hdGgucm91bmQoZXh0cnVkZVNjYWxlICogZXh0cnVkZS55KTtcclxuXHJcbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3V0bGluZUVsZW1lbnRzQnVmZmVyO1xyXG5cclxuZnVuY3Rpb24gT3V0bGluZUVsZW1lbnRzQnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcclxufVxyXG5cclxuT3V0bGluZUVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XHJcblxyXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLml0ZW1TaXplID0gNDsgLy8gYnl0ZXMgcGVyIGxpbmUgKDIgKiB1bnNpZ25lZCBzaG9ydCA9PSA0IGJ5dGVzKVxyXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFycmF5VHlwZSA9ICdFTEVNRU5UX0FSUkFZX0JVRkZFUic7XHJcblxyXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xyXG5cclxuICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XHJcbiAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcclxuXHJcbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJ1Y2tldDtcclxuXHJcbnZhciBMaW5lQnVja2V0ID0gcmVxdWlyZSgnLi9saW5lYnVja2V0LmpzJyk7XHJcbnZhciBGaWxsQnVja2V0ID0gcmVxdWlyZSgnLi9maWxsYnVja2V0LmpzJyk7XHJcbnZhciBTeW1ib2xCdWNrZXQgPSByZXF1aXJlKCcuL3N5bWJvbGJ1Y2tldC5qcycpO1xyXG52YXIgUmFzdGVyQnVja2V0ID0gcmVxdWlyZSgnLi9yYXN0ZXJidWNrZXQuanMnKTtcclxudmFyIFJlbmRlclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9zdHlsZS9yZW5kZXJwcm9wZXJ0aWVzLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVCdWNrZXQobGF5ZXIsIGJ1ZmZlcnMsIGNvbGxpc2lvbiwgaW5kaWNlcykge1xyXG5cclxuICAgIGlmICghUmVuZGVyUHJvcGVydGllc1tsYXllci50eXBlXSkge1xyXG4gICAgICAgIC8vY29uc29sZS53YXJuKCd1bmtub3duIGJ1Y2tldCB0eXBlJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmZvID0gbmV3IFJlbmRlclByb3BlcnRpZXNbbGF5ZXIudHlwZV0obGF5ZXIucmVuZGVyKTtcclxuXHJcbiAgICB2YXIgQnVja2V0Q2xhc3MgPVxyXG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdsaW5lJyA/IExpbmVCdWNrZXQgOlxyXG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdmaWxsJyA/IEZpbGxCdWNrZXQgOlxyXG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdzeW1ib2wnID8gU3ltYm9sQnVja2V0IDpcclxuICAgICAgICBsYXllci50eXBlID09PSAncmFzdGVyJyA/IFJhc3RlckJ1Y2tldCA6IG51bGw7XHJcblxyXG4gICAgdmFyIGJ1Y2tldCA9IG5ldyBCdWNrZXRDbGFzcyhpbmZvLCBidWZmZXJzLCBjb2xsaXNpb24sIGluZGljZXMpO1xyXG4gICAgYnVja2V0LnR5cGUgPSBsYXllci50eXBlO1xyXG4gICAgYnVja2V0LmludGVyYWN0aXZlID0gbGF5ZXIuaW50ZXJhY3RpdmU7XHJcbiAgICBidWNrZXQubWluWm9vbSA9IGxheWVyWydtaW4tem9vbSddO1xyXG4gICAgYnVja2V0Lm1heFpvb20gPSBsYXllclsnbWF4LXpvb20nXTtcclxuXHJcbiAgICByZXR1cm4gYnVja2V0O1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudEdyb3VwcztcclxuXHJcbmZ1bmN0aW9uIEVsZW1lbnRHcm91cHModmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCBzZWNvbmRFbGVtZW50QnVmZmVyKSB7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XHJcbiAgICB0aGlzLmVsZW1lbnRCdWZmZXIgPSBlbGVtZW50QnVmZmVyO1xyXG4gICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyID0gc2Vjb25kRWxlbWVudEJ1ZmZlcjtcclxuICAgIHRoaXMuZ3JvdXBzID0gW107XHJcbn1cclxuXHJcbkVsZW1lbnRHcm91cHMucHJvdG90eXBlLm1ha2VSb29tRm9yID0gZnVuY3Rpb24obnVtVmVydGljZXMpIHtcclxuICAgIGlmICghdGhpcy5jdXJyZW50IHx8IHRoaXMuY3VycmVudC52ZXJ0ZXhMZW5ndGggKyBudW1WZXJ0aWNlcyA+IDY1NTM1KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IEVsZW1lbnRHcm91cCh0aGlzLnZlcnRleEJ1ZmZlci5pbmRleCxcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEJ1ZmZlciAmJiB0aGlzLmVsZW1lbnRCdWZmZXIuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZEVsZW1lbnRCdWZmZXIgJiYgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyLmluZGV4KTtcclxuICAgICAgICB0aGlzLmdyb3Vwcy5wdXNoKHRoaXMuY3VycmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFbGVtZW50R3JvdXAodmVydGV4U3RhcnRJbmRleCwgZWxlbWVudFN0YXJ0SW5kZXgsIHNlY29uZEVsZW1lbnRTdGFydEluZGV4KSAge1xyXG4gICAgLy8gdGhlIG9mZnNldCBpbnRvIHRoZSB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggaW4gdGhpcyBncm91cFxyXG4gICAgdGhpcy52ZXJ0ZXhTdGFydEluZGV4ID0gdmVydGV4U3RhcnRJbmRleDtcclxuICAgIHRoaXMuZWxlbWVudFN0YXJ0SW5kZXggPSBlbGVtZW50U3RhcnRJbmRleDtcclxuICAgIHRoaXMuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggPSBzZWNvbmRFbGVtZW50U3RhcnRJbmRleDtcclxuICAgIHRoaXMuZWxlbWVudExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLnZlcnRleExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRMZW5ndGggPSAwO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyksXHJcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmVUcmVlO1xyXG5cclxuZnVuY3Rpb24gRmVhdHVyZVRyZWUoZ2V0R2VvbWV0cnksIGdldFR5cGUpIHtcclxuXHJcbiAgICB0aGlzLmdldEdlb21ldHJ5ID0gZ2V0R2VvbWV0cnk7XHJcbiAgICB0aGlzLmdldFR5cGUgPSBnZXRUeXBlO1xyXG5cclxuICAgIHRoaXMucnRyZWUgPSByYnVzaCg5KTtcclxuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XHJcbn1cclxuXHJcbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihiYm94LCBidWNrZXRfbmFtZSwgZmVhdHVyZSkge1xyXG4gICAgYmJveC5idWNrZXQgPSBidWNrZXRfbmFtZTtcclxuICAgIGJib3guZmVhdHVyZSA9IGZlYXR1cmU7XHJcbiAgICB0aGlzLnRvQmVJbnNlcnRlZC5wdXNoKGJib3gpO1xyXG59O1xyXG5cclxuLy8gYnVsayBpbnNlcnQgaW50byB0cmVlXHJcbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ydHJlZS5sb2FkKHRoaXMudG9CZUluc2VydGVkKTtcclxuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XHJcbn07XHJcblxyXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxyXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihhcmdzLCBjYWxsYmFjaykge1xyXG5cclxuICAgIGlmICh0aGlzLnRvQmVJbnNlcnRlZC5sZW5ndGgpIHRoaXMuX2xvYWQoKTtcclxuXHJcbiAgICB2YXIgcmFkaXVzID0gYXJncy5wYXJhbXMgJiYgYXJncy5wYXJhbXMucmFkaXVzIHx8IDA7XHJcbiAgICByYWRpdXMgKj0gNDA5NiAvIGFyZ3Muc2NhbGU7XHJcblxyXG4gICAgdmFyIHggPSBhcmdzLngsXHJcbiAgICAgICAgeSA9IGFyZ3MueTtcclxuXHJcbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLnJ0cmVlLnNlYXJjaChbIHggLSByYWRpdXMsIHkgLSByYWRpdXMsIHggKyByYWRpdXMsIHkgKyByYWRpdXMgXSk7XHJcblxyXG4gICAgaWYgKGFyZ3MucGFyYW1zLmJ1Y2tldHMpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5QnVja2V0cyhtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBhcmdzLnBhcmFtcywgY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5RmVhdHVyZXMobWF0Y2hpbmcsIHgsIHksIHJhZGl1cywgYXJncy5wYXJhbXMsIGNhbGxiYWNrKTtcclxuICAgIH1cclxufTtcclxuXHJcbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeUZlYXR1cmVzID0gZnVuY3Rpb24obWF0Y2hpbmcsIHgsIHksIHJhZGl1cywgcGFyYW1zLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBmZWF0dXJlID0gbWF0Y2hpbmdbaV0uZmVhdHVyZTtcclxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0VHlwZShmZWF0dXJlKTtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KGZlYXR1cmUpO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKHBhcmFtcy5idWNrZXQgJiYgbWF0Y2hpbmdbaV0uYnVja2V0ICE9PSBwYXJhbXMuYnVja2V0KSBjb250aW51ZTtcclxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgJiYgdHlwZSAhPT0gcGFyYW1zLnR5cGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAoZ2VvbWV0cnlDb250YWluc1BvaW50KGdlb21ldHJ5LCB0eXBlLCBuZXcgUG9pbnQoeCwgeSksIHJhZGl1cykpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgX2J1Y2tldDogbWF0Y2hpbmdbaV0uYnVja2V0LFxyXG4gICAgICAgICAgICAgICAgX3R5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBmZWF0dXJlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xyXG59O1xyXG5cclxuLy8gTGlzdHMgYWxsIGJ1Y2tldHMgdGhhdCBhdCB0aGUgcG9zaXRpb24uXHJcbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeUJ1Y2tldHMgPSBmdW5jdGlvbihtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYnVja2V0cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChidWNrZXRzLmluZGV4T2YobWF0Y2hpbmdbaV0uYnVja2V0KSA+PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBtYXRjaGluZ1tpXS5mZWF0dXJlO1xyXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRUeXBlKGZlYXR1cmUpO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoZmVhdHVyZSk7XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5Q29udGFpbnNQb2ludChnZW9tZXRyeSwgdHlwZSwgbmV3IFBvaW50KHgsIHkpLCByYWRpdXMpKSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldHMucHVzaChtYXRjaGluZ1tpXS5idWNrZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhudWxsLCBidWNrZXRzKTtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBnZW9tZXRyeUNvbnRhaW5zUG9pbnQocmluZ3MsIHR5cGUsIHAsIHJhZGl1cykge1xyXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnRDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdQb2x5Z29uJykge1xyXG4gICAgICAgIHJldHVybiBwb2x5Q29udGFpbnNQb2ludChyaW5ncywgcCkgPyB0cnVlIDogbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MDE3MjUvMzMxMzc5LlxyXG5mdW5jdGlvbiBkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSB7XHJcbiAgICB2YXIgbDIgPSB2LmRpc3RTcXIodyk7XHJcbiAgICBpZiAobDIgPT09IDApIHJldHVybiBwLmRpc3RTcXIodik7XHJcbiAgICB2YXIgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcclxuICAgIGlmICh0IDwgMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcclxuICAgIGlmICh0ID4gMSkgcmV0dXJuIHAuZGlzdFNxcih3KTtcclxuICAgIHJldHVybiBwLmRpc3RTcXIody5zdWIodikuX211bHQodCkuX2FkZCh2KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIHtcclxuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAvLyBGaW5kIGxpbmUgc2VnbWVudHMgdGhhdCBoYXZlIGEgZGlzdGFuY2UgPD0gcmFkaXVzXjIgdG8gcFxyXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHRyZWF0IHRoZSBsaW5lIGFzIFwiY29udGFpbmluZyBwb2ludCBwXCIuXHJcbiAgICAgICAgICAgIHZhciB2ID0gcmluZ1tqLTFdLCB3ID0gcmluZ1tqXTtcclxuICAgICAgICAgICAgaWYgKGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIDwgcikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBwb2ludCBpbiBwb2x5Z29uIHJheSBjYXN0aW5nIGFsZ29yaXRobVxyXG5mdW5jdGlvbiBwb2x5Q29udGFpbnNQb2ludChyaW5ncywgcCkge1xyXG4gICAgdmFyIGMgPSBmYWxzZSxcclxuICAgICAgICByaW5nLCBwMSwgcDI7XHJcblxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgIHJpbmcgPSByaW5nc1trXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XHJcbiAgICAgICAgICAgIHAxID0gcmluZ1tpXTtcclxuICAgICAgICAgICAgcDIgPSByaW5nW2pdO1xyXG4gICAgICAgICAgICBpZiAoKChwMS55ID4gcC55KSAhPSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gIWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYztcclxufVxyXG5cclxuZnVuY3Rpb24gcG9pbnRDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIHtcclxuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAocmluZ1tqXS5kaXN0U3FyKHApIDw9IHIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxCdWNrZXQ7XHJcblxyXG5mdW5jdGlvbiBGaWxsQnVja2V0KGluZm8sIGJ1ZmZlcnMsIHBsYWNlbWVudCwgZWxlbWVudEdyb3Vwcykge1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMgPSBlbGVtZW50R3JvdXBzIHx8IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMuZmlsbFZlcnRleCwgYnVmZmVycy5maWxsRWxlbWVudCwgYnVmZmVycy5vdXRsaW5lRWxlbWVudCk7XHJcbn1cclxuXHJcbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUubG9hZEdlb21ldHJ5KCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5hZGRGaWxsKGxpbmVzW2ldKTtcclxuICAgIH1cclxufTtcclxuXHJcbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZpbGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAvL2NvbnNvbGUud2FybignYSBmaWxsIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSB2ZXJ0aWNlcycpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyB3ZSdyZSBnb2luZyB0byBwcm9kdWNlIHNvIHRoYXQgd2VcclxuICAgIC8vIGNhbiByZXNpemUgdGhlIGJ1ZmZlciBiZWZvcmVoYW5kLCBvciBkZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBsaW5lXHJcbiAgICAvLyB3b24ndCBmaXQgaW50byB0aGUgYnVmZmVyIGFueW1vcmUuXHJcbiAgICAvLyBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgdmVydGV4IGJ1ZmZlciBmb3IgZHJhd2luZyB0aGUgYW50aWFsaWFzZWRcclxuICAgIC8vIG91dGxpbmVzLCB3ZSBzZXBhcmF0ZSBhbGwgcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgZGVnZW5lcmF0ZSAob3V0LW9mLVxyXG4gICAgLy8gdmlld3BsYW5lKSB2ZXJ0ZXguXHJcblxyXG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgZ2VvbWV0cnkgYnVmZmVyIGNhbiBob2xkIGFsbCB0aGUgcmVxdWlyZWQgdmVydGljZXMuXHJcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IobGVuICsgMSk7XHJcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XHJcblxyXG4gICAgdmFyIGZpbGxWZXJ0ZXggPSB0aGlzLmJ1ZmZlcnMuZmlsbFZlcnRleDtcclxuICAgIHZhciBmaWxsRWxlbWVudCA9IHRoaXMuYnVmZmVycy5maWxsRWxlbWVudDtcclxuICAgIHZhciBvdXRsaW5lRWxlbWVudCA9IHRoaXMuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcclxuXHJcbiAgICAvLyBTdGFydCBhbGwgbGluZXMgd2l0aCBhIGRlZ2VuZXJhdGUgdmVydGV4XHJcbiAgICBlbGVtZW50R3JvdXAudmVydGV4TGVuZ3RoKys7XHJcblxyXG4gICAgLy8gV2UncmUgZ2VuZXJhdGluZyB0cmlhbmdsZSBmYW5zLCBzbyB3ZSBhbHdheXMgc3RhcnQgd2l0aCB0aGUgZmlyc3QgY29vcmRpbmF0ZSBpbiB0aGlzIHBvbHlnb24uXHJcbiAgICB2YXIgZmlyc3RJbmRleCA9IGZpbGxWZXJ0ZXguaW5kZXggLSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleCxcclxuICAgICAgICBwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCwgY3VycmVudFZlcnRleDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3VycmVudEluZGV4ID0gZmlsbFZlcnRleC5pbmRleCAtIGVsZW1lbnRHcm91cC52ZXJ0ZXhTdGFydEluZGV4O1xyXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcclxuXHJcbiAgICAgICAgZmlsbFZlcnRleC5hZGQoY3VycmVudFZlcnRleC54LCBjdXJyZW50VmVydGV4LnkpO1xyXG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGgrKztcclxuXHJcbiAgICAgICAgLy8gT25seSBhZGQgdHJpYW5nbGVzIHRoYXQgaGF2ZSBkaXN0aW5jdCB2ZXJ0aWNlcy5cclxuICAgICAgICBpZiAoaSA+PSAyICYmIChjdXJyZW50VmVydGV4LnggIT09IHZlcnRpY2VzWzBdLnggfHwgY3VycmVudFZlcnRleC55ICE9PSB2ZXJ0aWNlc1swXS55KSkge1xyXG4gICAgICAgICAgICBmaWxsRWxlbWVudC5hZGQoZmlyc3RJbmRleCwgcHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkgPj0gMSkge1xyXG4gICAgICAgICAgICBvdXRsaW5lRWxlbWVudC5hZGQocHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xyXG4gICAgfVxyXG59O1xyXG5cclxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuaGFzRGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVCdWNrZXQ7XHJcblxyXG5mdW5jdGlvbiBMaW5lQnVja2V0KGluZm8sIGJ1ZmZlcnMsIHBsYWNlbWVudCwgZWxlbWVudEdyb3Vwcykge1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMgPSBlbGVtZW50R3JvdXBzIHx8IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMubGluZVZlcnRleCwgYnVmZmVycy5saW5lRWxlbWVudCk7XHJcbn1cclxuXHJcbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUubG9hZEdlb21ldHJ5KCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XHJcbiAgICB2YXIgaW5mbyA9IHRoaXMuaW5mbztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmFkZExpbmUobGluZXNbaV0sIGluZm9bJ2xpbmUtam9pbiddLCBpbmZvWydsaW5lLWNhcCddLFxyXG4gICAgICAgICAgICAgICAgaW5mb1snbGluZS1taXRlci1saW1pdCddLCBpbmZvWydsaW5lLXJvdW5kLWxpbWl0J10pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBqb2luLCBjYXAsIG1pdGVyTGltaXQsIHJvdW5kTGltaXQpIHtcclxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLndhcm4oJ2EgbGluZSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHZlcnRpY2VzJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChqb2luID09PSAnYmV2ZWwnKSBtaXRlckxpbWl0ID0gMS4wNTtcclxuXHJcbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXHJcbiAgICAgICAgbGFzdFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDFdLFxyXG4gICAgICAgIGNsb3NlZCA9IGZpcnN0VmVydGV4LmVxdWFscyhsYXN0VmVydGV4KTtcclxuXHJcbiAgICB2YXIgbGluZVZlcnRleCA9IHRoaXMuYnVmZmVycy5saW5lVmVydGV4O1xyXG4gICAgdmFyIGxpbmVFbGVtZW50ID0gdGhpcy5idWZmZXJzLmxpbmVFbGVtZW50O1xyXG5cclxuICAgIC8vIHdlIGNvdWxkIGJlIG1vcmUgcHJlY2llcywgYnV0IGl0IHdvdWxkIG9ubHkgc2F2ZSBhIG5lZ2xpZ2libGUgYW1vdW50IG9mIHNwYWNlXHJcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IobGVuICogNCk7XHJcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XHJcbiAgICB2YXIgdmVydGV4U3RhcnRJbmRleCA9IGVsZW1lbnRHcm91cC52ZXJ0ZXhTdGFydEluZGV4O1xyXG5cclxuICAgIGlmIChsZW4gPT0gMiAmJiBjbG9zZWQpIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2EgbGluZSBtYXkgbm90IGhhdmUgY29pbmNpZGVudCBwb2ludHMnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJlZ2luQ2FwID0gY2FwLFxyXG4gICAgICAgIGVuZENhcCA9IGNsb3NlZCA/ICdidXR0JyA6IGNhcCxcclxuICAgICAgICBmbGlwID0gMSxcclxuICAgICAgICBkaXN0YW5jZSA9IDAsXHJcbiAgICAgICAgY3VycmVudFZlcnRleCwgcHJldlZlcnRleCwgIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsICBuZXh0Tm9ybWFsO1xyXG5cclxuICAgIC8vIHRoZSBsYXN0IHRocmVlIHZlcnRpY2VzIGFkZGVkXHJcbiAgICB2YXIgZTEsIGUyLCBlMztcclxuXHJcbiAgICBpZiAoY2xvc2VkKSB7XHJcbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDJdO1xyXG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgbmV4dFZlcnRleCA9IGNsb3NlZCAmJiBpID09PSBsZW4gLSAxID9cclxuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICsgMV07IC8vIGp1c3QgdGhlIG5leHQgdmVydGV4XHJcblxyXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcclxuICAgICAgICBpZiAobmV4dFZlcnRleCAmJiB2ZXJ0aWNlc1tpXS5lcXVhbHMobmV4dFZlcnRleCkpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJ0ZXgpIHByZXZWZXJ0ZXggPSBjdXJyZW50VmVydGV4O1xyXG5cclxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgZmFyIGFsb25nIHRoZSBsaW5lIHRoZSBjdXJyZW50VmVydGV4IGlzXHJcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIGRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdG93YXJkcyB0aGUgbmV4dCB2ZXJ0ZXggaW4gdGhpcyBsaW5lLiBJbiBjYXNlXHJcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmV4dCB2ZXJ0ZXgsIHByZXRlbmQgdGhhdCB0aGUgbGluZSBpcyBjb250aW51aW5nIHN0cmFpZ2h0LFxyXG4gICAgICAgIC8vIG1lYW5pbmcgdGhhdCB3ZSBhcmUganVzdCB1c2luZyB0aGUgcHJldmlvdXMgbm9ybWFsLlxyXG4gICAgICAgIG5leHROb3JtYWwgPSBuZXh0VmVydGV4ID8gbmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpIDogcHJldk5vcm1hbDtcclxuXHJcbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzIG5vcm1hbCwgdGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIGFcclxuICAgICAgICAvLyBub24tY2xvc2VkIGxpbmUsIHNvIHdlJ3JlIGRvaW5nIGEgc3RyYWlnaHQgXCJqb2luXCIuXHJcbiAgICAgICAgcHJldk5vcm1hbCA9IHByZXZOb3JtYWwgfHwgbmV4dE5vcm1hbDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub3JtYWwgb2YgdGhlIGpvaW4gZXh0cnVzaW9uLiBJdCBpcyB0aGUgYW5nbGUgYmlzZWN0b3JcclxuICAgICAgICAvLyBvZiB0aGUgc2VnbWVudHMgYmV0d2VlbiB0aGUgcHJldmlvdXMgbGluZSBhbmQgdGhlIG5leHQgbGluZS5cclxuICAgICAgICB2YXIgam9pbk5vcm1hbCA9IHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLl91bml0KCk7XHJcblxyXG4gICAgICAgIC8qICBqb2luTm9ybWFsICAgICBwcmV2Tm9ybWFsXHJcbiAgICAgICAgICogICAgICAgICAgICAg4oaWICAgICAg4oaRXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgLl9fX19fX19fLiBwcmV2VmVydGV4XHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAqIG5leHROb3JtYWwgIOKGkCAgfCAgY3VycmVudFZlcnRleFxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAgKiAgICAgbmV4dFZlcnRleCAhXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIG1pdGVyICh0aGUgcmF0aW8gb2YgdGhlIG1pdGVyIHRvIHRoZSB3aWR0aCkuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBuZXh0IGFuZCBqb2luIG5vcm1hbHNcclxuICAgICAgICAvLyB1c2luZyBkb3QgcHJvZHVjdC4gVGhlIGludmVyc2Ugb2YgdGhhdCBpcyB0aGUgbWl0ZXIgbGVuZ3RoLlxyXG4gICAgICAgIHZhciBjb3NIYWxmQW5nbGUgPSBqb2luTm9ybWFsLnggKiBuZXh0Tm9ybWFsLnggKyBqb2luTm9ybWFsLnkgKiBuZXh0Tm9ybWFsLnk7XHJcbiAgICAgICAgdmFyIG1pdGVyTGVuZ3RoID0gMSAvIGNvc0hhbGZBbmdsZTtcclxuXHJcbiAgICAgICAgLy8gV2hldGhlciBhbnkgdmVydGljZXMgaGF2ZSBiZWVuXHJcbiAgICAgICAgdmFyIHN0YXJ0T2ZMaW5lID0gZTEgPT09IHVuZGVmaW5lZCB8fCBlMiA9PT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyBUaGUgam9pbiBpZiBhIG1pZGRsZSB2ZXJ0ZXgsIG90aGVyd2lzZSB0aGUgY2FwLlxyXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRKb2luID0gbWlkZGxlVmVydGV4ID8gam9pbiA6IG5leHRWZXJ0ZXggPyBiZWdpbkNhcCA6IGVuZENhcDtcclxuXHJcbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJyAmJiBtaXRlckxlbmd0aCA8IHJvdW5kTGltaXQpIHtcclxuICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnbWl0ZXInO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInICYmIG1pdGVyTGVuZ3RoID4gbWl0ZXJMaW1pdCkge1xyXG4gICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdiZXZlbCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXh0cnVkZSBsZW5ndGggaXMgNjMgLyAyNTYgPSA0IHRpbWVzIHRoZSB3aWR0aCBvZiB0aGUgbGluZVxyXG4gICAgICAgICAgICAvLyBzbyBpZiBtaXRlckxlbmd0aCA+PSA0IHdlIG5lZWQgdG8gZHJhdyBhIGRpZmZlcmVudCB0eXBlIG9mIGJldmVsIHdoZXJlLlxyXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiA0KSBjdXJyZW50Sm9pbiA9ICdmbGlwYmV2ZWwnO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIG1pdGVyTGVuZ3RoIGlzIHJlYWxseSBzbWFsbCBhbmQgdGhlIGxpbmUgYmV2ZWwgd291bGRuJ3QgYmUgdmlzaWJsZSxcclxuICAgICAgICAgICAgLy8ganVzdCBkcmF3IGEgbWl0ZXIgam9pbiB0byBzYXZlIGEgdHJpYW5nbGUuXHJcbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IG1pdGVyTGltaXQpIGN1cnJlbnRKb2luID0gJ21pdGVyJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1pdGVyZWQgam9pbnNcclxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicpIHtcclxuICAgICAgICAgICAgLy8gc2NhbGUgdGhlIHVuaXQgdmVjdG9yIGJ5IHRoZSBtaXRlciBsZW5ndGhcclxuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XHJcbiAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgoam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xyXG4gICAgICAgICAgICAvLyBtaXRlciBpcyB0b28gYmlnLCBmbGlwIHRoZSBkaXJlY3Rpb24gdG8gbWFrZSBhIGJldmVsZWQgam9pblxyXG5cclxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbG1vc3QgcGFyYWxsZWwgbGluZXNcclxuICAgICAgICAgICAgICAgIGZsaXAgPSAtZmxpcDtcclxuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZXZlbExlbmd0aCA9IG1pdGVyTGVuZ3RoICogcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkubWFnKCkgLyBwcmV2Tm9ybWFsLnN1YihuZXh0Tm9ybWFsKS5tYWcoKTtcclxuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwuX3BlcnAoKS5fbXVsdChmbGlwICogYmV2ZWxMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZmxpcCA9IC1mbGlwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgoam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBBbGwgb3RoZXIgdHlwZXMgb2Ygam9pbnNcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZnNldEEsIG9mZnNldEI7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHByZXZOb3JtYWwueCAqIG5leHROb3JtYWwueSAtIHByZXZOb3JtYWwueSAqIG5leHROb3JtYWwueDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtTWF0aC5zcXJ0KG1pdGVyTGVuZ3RoICogbWl0ZXJMZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChmbGlwICogZGlyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdzcXVhcmUnKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QiA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIGJ1dHQgb3IgYSBzcXVhcmUgY2FwIG9yIGJldmVsXHJcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgocHJldk5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIG9yIGxpbmVqb2luIGF0IGVuZCBvZiBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUgJiYgY3VycmVudEpvaW4gPT09ICdyb3VuZCcpIHtcclxuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgocHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlZ21lbnQgaW5jbHVkZSBjYXAgYXJlIGRvbmUsIHVuc2V0IHZlcnRpY2VzIHRvIGRpc2Nvbm5lY3Qgc2VnbWVudHMuXHJcbiAgICAgICAgICAgIC8vIE9yIGxlYXZlIHRoZW0gdG8gY3JlYXRlIGEgYmV2ZWwuXHJcbiAgICAgICAgICAgIGlmIChzdGFydE9mTGluZSB8fCBjdXJyZW50Sm9pbiAhPT0gJ2JldmVsJykge1xyXG4gICAgICAgICAgICAgICAgZTEgPSBlMiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZmxpcCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgYmVmb3JlIGZpcnN0IHNlZ21lbnRcclxuICAgICAgICAgICAgaWYgKHN0YXJ0T2ZMaW5lICYmIGJlZ2luQ2FwID09PSAncm91bmQnKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KG5leHROb3JtYWwsIC0xLCAtMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dCBvciBzcXVhcmUgY2FwIG9yIGJldmVsXHJcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KG5leHROb3JtYWwsIC1vZmZzZXRBLCAtb2Zmc2V0QiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIEFkZHMgdHdvIHZlcnRpY2VzIHRvIHRoZSBidWZmZXIgdGhhdCBhcmVcclxuICAgICAqIG5vcm1hbCBhbmQgLW5vcm1hbCBmcm9tIHRoZSBjdXJyZW50VmVydGV4LlxyXG4gICAgICpcclxuICAgICAqIGVuZEJveCBtb3ZlcyB0aGUgZXh0cnVkZSBvbmUgdW5pdCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXHJcbiAgICAgKiB0byBjcmVhdGUgc3F1YXJlIG9yIHJvdW5kIGNhcC5cclxuICAgICAqXHJcbiAgICAgKiBlbmRMZWZ0IGFuZCBlbmRSaWdodCBzaGlmdHMgdGhlIGV4dHJ1ZGUgYWxvbmcgdGhlIGxpbmVcclxuICAgICAqIGVuZExlZnQgPT09IDEgbW92ZXMgdGhlIGV4dHJ1ZGUgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxyXG4gICAgICogZW5kTGVmdCA9PT0gLTEgbW92ZXMgdGhlIGV4dHJ1ZGUgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEN1cnJlbnRWZXJ0ZXgobm9ybWFsLCBlbmRMZWZ0LCBlbmRSaWdodCwgcm91bmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHR4ID0gcm91bmQgPyAxIDogMDtcclxuICAgICAgICB2YXIgZXh0cnVkZTtcclxuXHJcbiAgICAgICAgZXh0cnVkZSA9IG5vcm1hbC5tdWx0KGZsaXApO1xyXG4gICAgICAgIGlmIChlbmRMZWZ0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRMZWZ0KSk7XHJcbiAgICAgICAgZTMgPSBsaW5lVmVydGV4LmFkZChjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMCwgZGlzdGFuY2UpIC0gdmVydGV4U3RhcnRJbmRleDtcclxuICAgICAgICBpZiAoZTEgPj0gMCAmJiBlMiA+PSAwKSB7XHJcbiAgICAgICAgICAgIGxpbmVFbGVtZW50LmFkZChlMSwgZTIsIGUzKTtcclxuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZTEgPSBlMjtcclxuICAgICAgICBlMiA9IGUzO1xyXG5cclxuICAgICAgICBleHRydWRlID0gbm9ybWFsLm11bHQoLWZsaXApO1xyXG4gICAgICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcclxuICAgICAgICBlMyA9IGxpbmVWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAxLCBkaXN0YW5jZSkgLSB2ZXJ0ZXhTdGFydEluZGV4O1xyXG4gICAgICAgIGlmIChlMSA+PSAwICYmIGUyID49IDApIHtcclxuICAgICAgICAgICAgbGluZUVsZW1lbnQuYWRkKGUxLCBlMiwgZTMpO1xyXG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlMSA9IGUyO1xyXG4gICAgICAgIGUyID0gZTM7XHJcblxyXG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcclxuICAgIH1cclxufTtcclxuXHJcbkxpbmVCdWNrZXQucHJvdG90eXBlLmhhc0RhdGEgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhIXRoaXMuZWxlbWVudEdyb3Vwcy5jdXJyZW50O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlckJ1Y2tldDtcclxuXHJcbmZ1bmN0aW9uIFJhc3RlckJ1Y2tldChpbmZvKSB7XHJcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50Z3JvdXBzLmpzJyk7XHJcbnZhciBBbmNob3IgPSByZXF1aXJlKCcuLi9zeW1ib2wvYW5jaG9yLmpzJyk7XHJcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pbnRlcnBvbGF0ZS5qcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xyXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4uanMnKTtcclxudmFyIFBsYWNlbWVudCA9IHJlcXVpcmUoJy4uL3N5bWJvbC9wbGFjZW1lbnQuanMnKTtcclxudmFyIFNoYXBpbmcgPSByZXF1aXJlKCcuLi9zeW1ib2wvc2hhcGluZy5qcycpO1xyXG52YXIgcmVzb2x2ZVRleHQgPSByZXF1aXJlKCcuLi9zeW1ib2wvcmVzb2x2ZXRleHQuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sQnVja2V0O1xyXG5cclxudmFyIGZ1bGxSYW5nZSA9IFsyICogTWF0aC5QSSAsIDBdO1xyXG5cclxuZnVuY3Rpb24gU3ltYm9sQnVja2V0KGluZm8sIGJ1ZmZlcnMsIGNvbGxpc2lvbiwgZWxlbWVudEdyb3Vwcykge1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICB0aGlzLmNvbGxpc2lvbiA9IGNvbGxpc2lvbjtcclxuXHJcbiAgICBpZiAoaW5mb1snc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcclxuICAgICAgICBpZiAoIWluZm8uaGFzT3duUHJvcGVydHkoJ3RleHQtcm90YXRpb24tYWxpZ25tZW50JykpIHtcclxuICAgICAgICAgICAgaW5mb1sndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9ICdtYXAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWluZm8uaGFzT3duUHJvcGVydHkoJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JykpIHtcclxuICAgICAgICAgICAgaW5mb1snaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9ICdtYXAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5mb1snc3ltYm9sLWF2b2lkLWVkZ2VzJ10gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbGVtZW50R3JvdXBzKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZWxlbWVudEdyb3VwcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmdseXBoVmVydGV4KSxcclxuICAgICAgICAgICAgaWNvbjogbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5pY29uVmVydGV4KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpbmZvID0gdGhpcy5pbmZvO1xyXG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcclxuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSB0aGlzLnRleHRGZWF0dXJlcztcclxuXHJcbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41O1xyXG4gICAgaWYgKGluZm9bJ3RleHQtaG9yaXpvbnRhbC1hbGlnbiddID09PSAncmlnaHQnKSBob3Jpem9udGFsQWxpZ24gPSAxO1xyXG4gICAgZWxzZSBpZiAoaW5mb1sndGV4dC1ob3Jpem9udGFsLWFsaWduJ10gPT09ICdsZWZ0JykgaG9yaXpvbnRhbEFsaWduID0gMDtcclxuXHJcbiAgICB2YXIgdmVydGljYWxBbGlnbiA9IDAuNTtcclxuICAgIGlmIChpbmZvWyd0ZXh0LXZlcnRpY2FsLWFsaWduJ10gPT09ICdib3R0b20nKSB2ZXJ0aWNhbEFsaWduID0gMTtcclxuICAgIGVsc2UgaWYgKGluZm9bJ3RleHQtdmVydGljYWwtYWxpZ24nXSA9PT0gJ3RvcCcpIHZlcnRpY2FsQWxpZ24gPSAwO1xyXG5cclxuICAgIHZhciBqdXN0aWZ5ID0gMC41O1xyXG4gICAgaWYgKGluZm9bJ3RleHQtanVzdGlmeSddID09PSAncmlnaHQnKSBqdXN0aWZ5ID0gMTtcclxuICAgIGVsc2UgaWYgKGluZm9bJ3RleHQtanVzdGlmeSddID09PSAnbGVmdCcpIGp1c3RpZnkgPSAwO1xyXG5cclxuICAgIHZhciBvbmVFbSA9IDI0O1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBpbmZvWyd0ZXh0LWxpbmUtaGVpZ2h0J10gKiBvbmVFbTtcclxuICAgIHZhciBtYXhXaWR0aCA9IGluZm9bJ3N5bWJvbC1wbGFjZW1lbnQnXSAhPT0gJ2xpbmUnICYmIGluZm9bJ3RleHQtbWF4LXdpZHRoJ10gKiBvbmVFbTtcclxuICAgIHZhciBzcGFjaW5nID0gaW5mb1sndGV4dC1sZXR0ZXItc3BhY2luZyddICogb25lRW07XHJcbiAgICB2YXIgZm9udHN0YWNrID0gaW5mb1sndGV4dC1mb250J107XHJcbiAgICB2YXIgdGV4dE9mZnNldCA9IFtpbmZvWyd0ZXh0LW9mZnNldCddWzBdICogb25lRW0sIGluZm9bJ3RleHQtb2Zmc2V0J11bMV0gKiBvbmVFbV07XHJcblxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2tdO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgIHZhciBzaGFwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgc2hhcGluZyA9IFNoYXBpbmcuc2hhcGUodGV4dCwgZm9udHN0YWNrLCB0aGlzLnN0YWNrcywgbWF4V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0ZXh0T2Zmc2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnNwcml0ZSAmJiB0aGlzLmluZm9bJ2ljb24taW1hZ2UnXSkge1xyXG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMuc3ByaXRlW3Jlc29sdmVUb2tlbnMoZmVhdHVyZS5wcm9wZXJ0aWVzLCBpbmZvWydpY29uLWltYWdlJ10pXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggZ2x5cGggdGV4IG9iamVjdC4gVE9ETyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGltYWdlLncgPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGltYWdlLmggPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnNkZikgdGhpcy5lbGVtZW50R3JvdXBzLnNkZkljb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFzaGFwaW5nICYmICFpbWFnZSkgY29udGludWU7XHJcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGxpbmVzLCB0aGlzLnN0YWNrcywgc2hhcGluZywgaW1hZ2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYnlTY2FsZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5zY2FsZSAtIGIuc2NhbGU7XHJcbn1cclxuXHJcblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBmYWNlcywgc2hhcGluZywgaW1hZ2UpIHtcclxuICAgIHZhciBpbmZvID0gdGhpcy5pbmZvO1xyXG4gICAgdmFyIGNvbGxpc2lvbiA9IHRoaXMuY29sbGlzaW9uO1xyXG5cclxuICAgIHZhciBtaW5TY2FsZSA9IDAuNTtcclxuICAgIHZhciBnbHlwaFNpemUgPSAyNDtcclxuXHJcbiAgICB2YXIgaG9yaXpvbnRhbFRleHQgPSBpbmZvWyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID09PSAndmlld3BvcnQnLFxyXG4gICAgICAgIGhvcml6b250YWxJY29uID0gaW5mb1snaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ3ZpZXdwb3J0JyxcclxuICAgICAgICBmb250U2NhbGUgPSBpbmZvWyd0ZXh0LW1heC1zaXplJ10gLyBnbHlwaFNpemUsXHJcbiAgICAgICAgdGV4dEJveFNjYWxlID0gY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvICogZm9udFNjYWxlLFxyXG4gICAgICAgIGljb25Cb3hTY2FsZSA9IGNvbGxpc2lvbi50aWxlUGl4ZWxSYXRpbyAqIGluZm9bJ2ljb24tbWF4LXNpemUnXSxcclxuICAgICAgICBpY29uV2l0aG91dFRleHQgPSBpbmZvWyd0ZXh0LW9wdGlvbmFsJ10gfHwgIXNoYXBpbmcsXHJcbiAgICAgICAgdGV4dFdpdGhvdXRJY29uID0gaW5mb1snaWNvbi1vcHRpb25hbCddIHx8ICFpbWFnZSxcclxuICAgICAgICBhdm9pZEVkZ2VzID0gaW5mb1snc3ltYm9sLWF2b2lkLWVkZ2VzJ107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgIHZhciBhbmNob3JzO1xyXG5cclxuICAgICAgICBpZiAoaW5mb1snc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgLy8gTGluZSBsYWJlbHNcclxuICAgICAgICAgICAgYW5jaG9ycyA9IGludGVycG9sYXRlKGxpbmUsIGluZm9bJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSwgbWluU2NhbGUsIGNvbGxpc2lvbi5tYXhQbGFjZW1lbnRTY2FsZSwgY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgYW5jaG9ycyBieSBzZWdtZW50IHNvIHRoYXQgd2UgY2FuIHN0YXJ0IHBsYWNlbWVudCB3aXRoIHRoZVxyXG4gICAgICAgICAgICAvLyBhbmNob3JzIHRoYXQgY2FuIGJlIHNob3duIGF0IHRoZSBsb3dlc3Qgem9vbSBsZXZlbHMuXHJcbiAgICAgICAgICAgIGFuY2hvcnMuc29ydChieVNjYWxlKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUG9pbnQgbGFiZWxzXHJcbiAgICAgICAgICAgIGFuY2hvcnMgPSBbbmV3IEFuY2hvcihsaW5lWzBdLngsIGxpbmVbMF0ueSwgMCwgbWluU2NhbGUpXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGNvcnJlY3QgYXNjZW5kZXIgaGVpZ2h0LlxyXG4gICAgICAgIHZhciBvcmlnaW4gPSBuZXcgUG9pbnQoMCwgLTE3KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFuY2hvcnNbal07XHJcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAhKGFuY2hvci54IDwgMCB8fCBhbmNob3IueCA+IDQwOTYgfHwgYW5jaG9yLnkgPCAwIHx8IGFuY2hvci55ID4gNDA5Nik7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXZvaWRFZGdlcyAmJiAhaW5zaWRlKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVzIGF0IHdoaWNoIHRoZSB0ZXh0IGFuZCBpY29ucyBjYW4gYmUgZmlyc3Qgc2hvd24gd2l0aG91dCBvdmVybGFwXHJcbiAgICAgICAgICAgIHZhciBnbHlwaDtcclxuICAgICAgICAgICAgdmFyIGljb247XHJcbiAgICAgICAgICAgIHZhciBnbHlwaFNjYWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGljb25TY2FsZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGluZykge1xyXG4gICAgICAgICAgICAgICAgZ2x5cGggPSBQbGFjZW1lbnQuZ2V0R2x5cGhzKGFuY2hvciwgb3JpZ2luLCBzaGFwaW5nLCBmYWNlcywgdGV4dEJveFNjYWxlLCBob3Jpem9udGFsVGV4dCwgbGluZSwgaW5mbyk7XHJcbiAgICAgICAgICAgICAgICBnbHlwaFNjYWxlID0gaW5mb1sndGV4dC1hbGxvdy1vdmVybGFwJ10gPyBnbHlwaC5taW5TY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFNjYWxlKGdseXBoLmJveGVzLCBnbHlwaC5taW5TY2FsZSwgYXZvaWRFZGdlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdseXBoU2NhbGUgJiYgIWljb25XaXRob3V0VGV4dCkgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgaWNvbiA9IFBsYWNlbWVudC5nZXRJY29uKGFuY2hvciwgaW1hZ2UsIGljb25Cb3hTY2FsZSwgbGluZSwgaW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpY29uU2NhbGUgPSBpbmZvWydpY29uLWFsbG93LW92ZXJsYXAnXSA/IGljb24ubWluU2NhbGVcclxuICAgICAgICAgICAgICAgICAgICA6IGNvbGxpc2lvbi5nZXRQbGFjZW1lbnRTY2FsZShpY29uLmJveGVzLCBpY29uLm1pblNjYWxlLCBhdm9pZEVkZ2VzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaWNvblNjYWxlICYmICF0ZXh0V2l0aG91dEljb24pIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWljb25XaXRob3V0VGV4dCAmJiAhdGV4dFdpdGhvdXRJY29uKSB7XHJcbiAgICAgICAgICAgICAgICBpY29uU2NhbGUgPSBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGV4dFdpdGhvdXRJY29uICYmIGdseXBoU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgaWNvblNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpY29uU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdGF0aW9uIHJhbmdlcyBpdCBpcyBzYWZlIHRvIHNob3cgdGhlIGdseXBoc1xyXG4gICAgICAgICAgICB2YXIgZ2x5cGhSYW5nZSA9ICghZ2x5cGhTY2FsZSB8fCBpbmZvWyd0ZXh0LWFsbG93LW92ZXJsYXAnXSkgPyBmdWxsUmFuZ2VcclxuICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFJhbmdlKGdseXBoLmJveGVzLCBnbHlwaFNjYWxlLCBob3Jpem9udGFsVGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBpY29uUmFuZ2UgPSAoIWljb25TY2FsZSB8fCBpbmZvWydpY29uLWFsbG93LW92ZXJsYXAnXSkgPyBmdWxsUmFuZ2VcclxuICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFJhbmdlKGljb24uYm94ZXMsIGljb25TY2FsZSwgaG9yaXpvbnRhbEljb24pO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1heFJhbmdlID0gW1xyXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaWNvblJhbmdlWzBdLCBnbHlwaFJhbmdlWzBdKSxcclxuICAgICAgICAgICAgICAgIE1hdGgubWF4KGljb25SYW5nZVsxXSwgZ2x5cGhSYW5nZVsxXSldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgIXRleHRXaXRob3V0SWNvbikge1xyXG4gICAgICAgICAgICAgICAgaWNvblJhbmdlID0gZ2x5cGhSYW5nZSA9IG1heFJhbmdlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0ZXh0V2l0aG91dEljb24pIHtcclxuICAgICAgICAgICAgICAgIGdseXBoUmFuZ2UgPSBtYXhSYW5nZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBpY29uUmFuZ2UgPSBtYXhSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5zZXJ0IGZpbmFsIHBsYWNlbWVudCBpbnRvIGNvbGxpc2lvbiB0cmVlIGFuZCBhZGQgZ2x5cGhzL2ljb25zIHRvIGJ1ZmZlcnNcclxuICAgICAgICAgICAgaWYgKGdseXBoU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5mb1sndGV4dC1pZ25vcmUtcGxhY2VtZW50J10pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24uaW5zZXJ0KGdseXBoLmJveGVzLCBhbmNob3IsIGdseXBoU2NhbGUsIGdseXBoUmFuZ2UsIGhvcml6b250YWxUZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHRoaXMuYWRkU3ltYm9scyh0aGlzLmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXgsIHRoaXMuZWxlbWVudEdyb3Vwcy50ZXh0LCBnbHlwaC5zaGFwZXMsIGdseXBoU2NhbGUsIGdseXBoUmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaWNvblNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluZm9bJ2ljb24taWdub3JlLXBsYWNlbWVudCddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLmluc2VydChpY29uLmJveGVzLCBhbmNob3IsIGljb25TY2FsZSwgaWNvblJhbmdlLCBob3Jpem9udGFsSWNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB0aGlzLmFkZFN5bWJvbHModGhpcy5idWZmZXJzLmljb25WZXJ0ZXgsIHRoaXMuZWxlbWVudEdyb3Vwcy5pY29uLCBpY29uLnNoYXBlcywgaWNvblNjYWxlLCBpY29uUmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkU3ltYm9scyA9IGZ1bmN0aW9uKGJ1ZmZlciwgZWxlbWVudEdyb3Vwcywgc3ltYm9scywgc2NhbGUsIHBsYWNlbWVudFJhbmdlKSB7XHJcblxyXG4gICAgdmFyIHpvb20gPSB0aGlzLmNvbGxpc2lvbi56b29tO1xyXG5cclxuICAgIGVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IoMCk7XHJcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gZWxlbWVudEdyb3Vwcy5jdXJyZW50O1xyXG5cclxuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tO1xyXG5cclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltYm9scy5sZW5ndGg7IGsrKykge1xyXG5cclxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1trXSxcclxuICAgICAgICAgICAgdGwgPSBzeW1ib2wudGwsXHJcbiAgICAgICAgICAgIHRyID0gc3ltYm9sLnRyLFxyXG4gICAgICAgICAgICBibCA9IHN5bWJvbC5ibCxcclxuICAgICAgICAgICAgYnIgPSBzeW1ib2wuYnIsXHJcbiAgICAgICAgICAgIHRleCA9IHN5bWJvbC50ZXgsXHJcbiAgICAgICAgICAgIGFuZ2xlID0gc3ltYm9sLmFuZ2xlLFxyXG4gICAgICAgICAgICBhbmNob3IgPSBzeW1ib2wuYW5jaG9yLFxyXG5cclxuXHJcbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heCh6b29tICsgTWF0aC5sb2coc3ltYm9sLm1pblNjYWxlKSAvIE1hdGguTE4yLCBwbGFjZW1lbnRab29tKSxcclxuICAgICAgICAgICAgbWF4Wm9vbSA9IE1hdGgubWluKHpvb20gKyBNYXRoLmxvZyhzeW1ib2wubWF4U2NhbGUpIC8gTWF0aC5MTjIsIDI1KTtcclxuXHJcbiAgICAgICAgaWYgKG1heFpvb20gPD0gbWluWm9vbSkgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIExvd2VyIG1pbiB6b29tIHNvIHRoYXQgd2hpbGUgZmFkaW5nIG91dCB0aGUgbGFiZWwgaXQgY2FuIGJlIHNob3duIG91dHNpZGUgb2YgY29sbGlzaW9uLWZyZWUgem9vbSBsZXZlbHNcclxuICAgICAgICBpZiAobWluWm9vbSA9PT0gcGxhY2VtZW50Wm9vbSkgbWluWm9vbSA9IDA7XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IHRyaWFuZ2xlXHJcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIHRsLngsIHRsLnksIHRleC54LCB0ZXgueSwgYW5nbGUsIG1pblpvb20sIHBsYWNlbWVudFJhbmdlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcclxuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgdHIueCwgdHIueSwgdGV4LnggKyB0ZXgudywgdGV4LnksIGFuZ2xlLCBtaW5ab29tLCBwbGFjZW1lbnRSYW5nZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XHJcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIGJsLngsIGJsLnksIHRleC54LCB0ZXgueSArIHRleC5oLCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xyXG5cclxuICAgICAgICAvLyBzZWNvbmQgdHJpYW5nbGVcclxuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgdHIueCwgdHIueSwgdGV4LnggKyB0ZXgudywgdGV4LnksIGFuZ2xlLCBtaW5ab29tLCBwbGFjZW1lbnRSYW5nZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XHJcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIGJsLngsIGJsLnksIHRleC54LCB0ZXgueSArIHRleC5oLCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xyXG4gICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLngsIGFuY2hvci55LCBici54LCBici55LCB0ZXgueCArIHRleC53LCB0ZXgueSArIHRleC5oLCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xyXG5cclxuICAgICAgICBlbGVtZW50R3JvdXAudmVydGV4TGVuZ3RoICs9IDY7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbih0aWxlLCBhY3RvciwgY2FsbGJhY2spIHtcclxuICAgIHZhciBmaXJzdGRvbmUgPSBmYWxzZTtcclxuICAgIHZhciBmaXJzdGVycjtcclxuICAgIHRoaXMuZ2V0VGV4dERlcGVuZGVuY2llcyh0aWxlLCBhY3RvciwgZG9uZSk7XHJcbiAgICB0aGlzLmdldEljb25EZXBlbmRlbmNpZXModGlsZSwgYWN0b3IsIGRvbmUpO1xyXG4gICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcclxuICAgICAgICBpZiAoZXJyIHx8IGZpcnN0ZG9uZSkgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICBmaXJzdGRvbmUgPSB0cnVlO1xyXG4gICAgICAgIGZpcnN0ZXJyID0gZXJyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXRJY29uRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYnVja2V0ID0gdGhpcztcclxuICAgIGlmICh0aGlzLmluZm9bJ2ljb24taW1hZ2UnXSkge1xyXG4gICAgICAgIGlmIChTeW1ib2xCdWNrZXQuc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gU3ltYm9sQnVja2V0LnNwcml0ZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhY3Rvci5zZW5kKCdnZXQgc3ByaXRlIGpzb24nLCB7fSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBTeW1ib2xCdWNrZXQuc3ByaXRlID0gYnVja2V0LnNwcml0ZSA9IGRhdGEuc3ByaXRlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXRUZXh0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xyXG4gICAgdmFyIGluZm8gPSB0aGlzLmluZm87XHJcblxyXG4gICAgaWYgKHRpbGUuc3RhY2tzID09PSB1bmRlZmluZWQpIHRpbGUuc3RhY2tzID0ge307XHJcbiAgICB2YXIgc3RhY2tzID0gdGhpcy5zdGFja3MgPSB0aWxlLnN0YWNrcztcclxuICAgIHZhciBmb250c3RhY2sgPSBpbmZvWyd0ZXh0LWZvbnQnXTtcclxuICAgIGlmIChzdGFja3NbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc3RhY2tzW2ZvbnRzdGFja10gPSB7IGdseXBoczoge30sIHJlY3RzOiB7fSB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0YWNrID0gc3RhY2tzW2ZvbnRzdGFja107XHJcblxyXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVGV4dChmZWF0dXJlcywgaW5mbywgc3RhY2suZ2x5cGhzKTtcclxuICAgIHRoaXMudGV4dEZlYXR1cmVzID0gZGF0YS50ZXh0RmVhdHVyZXM7XHJcblxyXG4gICAgYWN0b3Iuc2VuZCgnZ2V0IGdseXBocycsIHtcclxuICAgICAgICBpZDogdGlsZS5pZCxcclxuICAgICAgICBmb250c3RhY2s6IGZvbnRzdGFjayxcclxuICAgICAgICBjb2RlcG9pbnRzOiBkYXRhLmNvZGVwb2ludHNcclxuICAgIH0sIGZ1bmN0aW9uKGVyciwgbmV3c3RhY2spIHtcclxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcbiAgICAgICAgdmFyIG5ld2dseXBocyA9IG5ld3N0YWNrLmdseXBocztcclxuICAgICAgICB2YXIgbmV3cmVjdHMgPSBuZXdzdGFjay5yZWN0cztcclxuICAgICAgICB2YXIgZ2x5cGhzID0gc3RhY2suZ2x5cGhzO1xyXG4gICAgICAgIHZhciByZWN0cyA9IHN0YWNrLnJlY3RzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBjb2RlcG9pbnQgaW4gbmV3Z2x5cGhzKSB7XHJcbiAgICAgICAgICAgIGdseXBoc1tjb2RlcG9pbnRdID0gbmV3Z2x5cGhzW2NvZGVwb2ludF07XHJcbiAgICAgICAgICAgIHJlY3RzW2NvZGVwb2ludF0gPSBuZXdyZWN0c1tjb2RlcG9pbnRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmVsZW1lbnRHcm91cHMudGV4dC5jdXJyZW50IHx8ICEhdGhpcy5lbGVtZW50R3JvdXBzLmljb24uY3VycmVudDtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMYXRMbmc7XHJcblxyXG5mdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcpIHtcclxuICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuICAgIH1cclxuICAgIHRoaXMubGF0ID0gK2xhdDtcclxuICAgIHRoaXMubG5nID0gK2xuZztcclxufVxyXG5cclxuXHJcbi8vIGNvbnN0cnVjdHMgTGF0TG5nIGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XHJcblxyXG5MYXRMbmcuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICBpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExhdExuZ0JvdW5kcztcclxuXHJcbnZhciBMYXRMbmcgPSByZXF1aXJlKCcuL2xhdGxuZy5qcycpO1xyXG5cclxuZnVuY3Rpb24gTGF0TG5nQm91bmRzKHN3LCBuZSkge1xyXG4gICAgaWYgKCFzdykgcmV0dXJuO1xyXG5cclxuICAgIHZhciBsYXRsbmdzID0gbmUgPyBbc3csIG5lXSA6IHN3O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXHJcbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgc3cgPSB0aGlzLl9zdyxcclxuICAgICAgICAgICAgbmUgPSB0aGlzLl9uZSxcclxuICAgICAgICAgICAgc3cyLCBuZTI7XHJcblxyXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICAgICAgICAgICAgc3cyID0gb2JqO1xyXG4gICAgICAgICAgICBuZTIgPSBvYmo7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgICAgICAgICAgIHN3MiA9IG9iai5fc3c7XHJcbiAgICAgICAgICAgIG5lMiA9IG9iai5fbmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN3MiB8fCAhbmUyKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKExhdExuZy5jb252ZXJ0KG9iaikgfHwgTGF0TG5nQm91bmRzLmNvbnZlcnQob2JqKSkgOiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFzdyAmJiAhbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3cgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG4gICAgICAgICAgICB0aGlzLl9uZSA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcbiAgICAgICAgICAgIHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcbiAgICAgICAgICAgIG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcbiAgICAgICAgICAgIG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoKHRoaXMuX3N3LmxhdCArIHRoaXMuX25lLmxhdCkgLyAyLCAodGhpcy5fc3cubG5nICsgdGhpcy5fbmUubG5nKSAvIDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N3OyB9LFxyXG4gICAgZ2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZTsgfSxcclxuICAgIGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTsgfSxcclxuICAgIGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTsgfSxcclxuXHJcbiAgICBnZXRXZXN0OiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3cubG5nOyB9LFxyXG4gICAgZ2V0U291dGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcclxuICAgIGdldEVhc3Q6ICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZS5sbmc7IH0sXHJcbiAgICBnZXROb3J0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmUubGF0OyB9XHJcbn07XHJcblxyXG4vLyBjb25zdHJ1Y3RzIExhdExuZ0JvdW5kcyBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxyXG5MYXRMbmdCb3VuZHMuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICBpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykgcmV0dXJuIGE7XHJcbiAgICByZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0bG5nLmpzJyksXHJcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcclxuXHJcbi8vIEEgc2luZ2xlIHRyYW5zZm9ybSwgZ2VuZXJhbGx5IHVzZWQgZm9yIGEgc2luZ2xlIHRpbGUgdG8gYmUgc2NhbGVkLCByb3RhdGVkLCBhbmQgem9vbWVkLlxyXG5cclxuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcclxuICAgIHRoaXMudGlsZVNpemUgPSA1MTI7IC8vIGNvbnN0YW50XHJcblxyXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcclxuICAgIHRoaXMuX21heFpvb20gPSBtYXhab29tIHx8IDIyO1xyXG5cclxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICB0aGlzLnpvb20gPSAwO1xyXG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgTGF0TG5nKDAsIDApO1xyXG4gICAgdGhpcy5hbmdsZSA9IDA7XHJcbn1cclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XHJcbiAgICBnZXQgbWluWm9vbSgpIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH0sXHJcbiAgICBzZXQgbWluWm9vbSh6b29tKSB7XHJcbiAgICAgICAgdGhpcy5fbWluWm9vbSA9IHpvb207XHJcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB6b29tKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IG1heFpvb20oKSB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9LFxyXG4gICAgc2V0IG1heFpvb20oem9vbSkge1xyXG4gICAgICAgIHRoaXMuX21heFpvb20gPSB6b29tO1xyXG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgem9vbSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB3b3JsZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUgKiB0aGlzLnNjYWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgY2VudGVyUG9pbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZS5fZGl2KDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IGJlYXJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcclxuICAgIH0sXHJcbiAgICBzZXQgYmVhcmluZyhiZWFyaW5nKSB7XHJcbiAgICAgICAgLy8gY29uZmluZSB0aGUgYW5nbGUgdG8gd2l0aGluIFstMTgwLDE4MF1cclxuICAgICAgICBiZWFyaW5nID0gKCgoKGJlYXJpbmcgKyAxODApICUgMzYwKSArIDM2MCkgJSAzNjApIC0gMTgwO1xyXG4gICAgICAgIHRoaXMuYW5nbGUgPSAtYmVhcmluZyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB6b29tKCkgeyByZXR1cm4gdGhpcy5fem9vbTsgfSxcclxuICAgIHNldCB6b29tKHpvb20pIHtcclxuICAgICAgICB6b29tID0gTWF0aC5taW4oTWF0aC5tYXgoem9vbSwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcclxuICAgICAgICB0aGlzLl96b29tID0gem9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoem9vbSk7XHJcbiAgICAgICAgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3Ioem9vbSk7XHJcbiAgICAgICAgdGhpcy56b29tRnJhY3Rpb24gPSB6b29tIC0gdGhpcy50aWxlWm9vbTtcclxuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcclxuICAgIH0sXHJcblxyXG4gICAgem9vbVNjYWxlOiBmdW5jdGlvbih6b29tKSB7IHJldHVybiBNYXRoLnBvdygyLCB6b29tKTsgfSxcclxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxyXG5cclxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxhdGxuZywgd29ybGRTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcclxuICAgICAgICAgICAgdGhpcy5sbmdYKGxhdGxuZy5sbmcsIHdvcmxkU2l6ZSksXHJcbiAgICAgICAgICAgIHRoaXMubGF0WShsYXRsbmcubGF0LCB3b3JsZFNpemUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCwgd29ybGRTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpLFxyXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB4KCkgeyByZXR1cm4gdGhpcy5sbmdYKHRoaXMuY2VudGVyLmxuZyk7IH0sXHJcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxyXG5cclxuICAgIGdldCBwb2ludCgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXHJcblxyXG4gICAgLy8gbGF0L2xvbiA8LT4gYWJzb2x1dGUgcGl4ZWwgY29vcmRzIGNvbnZlcnRpb25cclxuICAgIGxuZ1g6IGZ1bmN0aW9uKGxvbiwgd29ybGRTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuICgxODAgKyBsb24pICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XHJcbiAgICB9LFxyXG4gICAgLy8gbGF0aXR1ZGUgdG8gYWJzb2x1dGUgeSBjb29yZFxyXG4gICAgbGF0WTogZnVuY3Rpb24obGF0LCB3b3JsZFNpemUpIHtcclxuICAgICAgICB2YXIgeSA9IDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGxhdCAqIE1hdGguUEkgLyAzNjApKTtcclxuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XHJcbiAgICB9LFxyXG5cclxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB4ICogMzYwIC8gKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLSAxODA7XHJcbiAgICB9LFxyXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XHJcbiAgICAgICAgdmFyIHkyID0gMTgwIC0geSAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpO1xyXG4gICAgICAgIHJldHVybiAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhbkJ5OiBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcclxuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMucG9pbnRMb2NhdGlvbihwb2ludCk7XHJcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uKHpvb20sIGNlbnRlcikge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5sb2NhdGlvblBvaW50KGNlbnRlciksXHJcbiAgICAgICAgICAgIHAxID0gdGhpcy5zaXplLl9zdWIocCksXHJcbiAgICAgICAgICAgIGxhdGxuZyA9IHRoaXMucG9pbnRMb2NhdGlvbihwMSk7XHJcbiAgICAgICAgdGhpcy56b29tID0gem9vbTtcclxuICAgICAgICB0aGlzLnBhbkJ5KHAxLnN1Yih0aGlzLmxvY2F0aW9uUG9pbnQobGF0bG5nKSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCZWFyaW5nQXJvdW5kOiBmdW5jdGlvbihiZWFyaW5nLCBjZW50ZXIpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5sb2NhdGlvblBvaW50KGNlbnRlcikuc3ViKHRoaXMuY2VudGVyUG9pbnQpO1xyXG4gICAgICAgIHRoaXMucGFuQnkob2Zmc2V0KTtcclxuICAgICAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xyXG4gICAgICAgIHRoaXMucGFuQnkob2Zmc2V0Lm11bHQoLTEpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obGF0bG5nKSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByb2plY3QobGF0bG5nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJQb2ludC5fc3ViKHRoaXMucG9pbnQuX3N1YihwKS5fcm90YXRlKHRoaXMuYW5nbGUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgcG9pbnRMb2NhdGlvbjogZnVuY3Rpb24ocCkge1xyXG4gICAgICAgIHZhciBwMiA9IHRoaXMuY2VudGVyUG9pbnQuX3N1YihwKS5fcm90YXRlKC10aGlzLmFuZ2xlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnByb2plY3QodGhpcy5wb2ludC5zdWIocDIpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbG9jYXRpb25Db29yZGluYXRlOiBmdW5jdGlvbihsYXRsbmcpIHtcclxuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxuZ1gobGF0bG5nLmxuZykgKiBrLFxyXG4gICAgICAgICAgICByb3c6IHRoaXMubGF0WShsYXRsbmcubGF0KSAqIGssXHJcbiAgICAgICAgICAgIHpvb206IHRoaXMudGlsZVpvb21cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHRpbGVDZW50ZXIsIHApIHtcclxuICAgICAgICB2YXIgem9vbUZhY3RvciA9IHRoaXMuem9vbVNjYWxlKHRoaXMuem9vbUZyYWN0aW9uKSxcclxuICAgICAgICAgICAga3QgPSB0aGlzLnpvb21TY2FsZSh0aGlzLnRpbGVab29tIC0gdGlsZUNlbnRlci56b29tKSxcclxuICAgICAgICAgICAgcDIgPSB0aGlzLmNlbnRlclBvaW50Ll9zdWIocCkuX3JvdGF0ZSgtdGhpcy5hbmdsZSkuX2Rpdih0aGlzLnRpbGVTaXplICogem9vbUZhY3Rvcik7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbHVtbjogdGlsZUNlbnRlci5jb2x1bW4gKiBrdCAtIHAyLngsXHJcbiAgICAgICAgICAgIHJvdzogdGlsZUNlbnRlci5yb3cgKiBrdCAtIHAyLnksXHJcbiAgICAgICAgICAgIHpvb206IHRoaXMudGlsZVpvb21cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBfY29uc3RyYWluOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2VudGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBtaW5ZLCBtYXhZLCBtaW5YLCBtYXhYLCBzeSwgc3gsIHgyLCB5MixcclxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcclxuICAgICAgICAgICAgbWluWSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzFdKTtcclxuICAgICAgICAgICAgbWF4WSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzBdKTtcclxuICAgICAgICAgICAgc3kgPSBtYXhZIC0gbWluWSA8IHNpemUueSA/IHNpemUueSAvIChtYXhZIC0gbWluWSkgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcclxuICAgICAgICAgICAgbWluWCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzBdKTtcclxuICAgICAgICAgICAgbWF4WCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzFdKTtcclxuICAgICAgICAgICAgc3ggPSBtYXhYIC0gbWluWCA8IHNpemUueCA/IHNpemUueCAvIChtYXhYIC0gbWluWCkgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaG93IG11Y2ggdGhlIG1hcCBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBzY3JlZW4gaW50byBnaXZlbiBsYXRpdHVkZS9sb25naXR1ZGUgcmFuZ2VzXHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heChzeCB8fCAwLCBzeSB8fCAwKTtcclxuXHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXHJcbiAgICAgICAgICAgICAgICBzeCA/IChtYXhYICsgbWluWCkgLyAyIDogdGhpcy54LFxyXG4gICAgICAgICAgICAgICAgc3kgPyAobWF4WSArIG1pblkpIC8gMiA6IHRoaXMueSkpO1xyXG4gICAgICAgICAgICB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20ocyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy55LFxyXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xyXG5cclxuICAgICAgICAgICAgaWYgKHkgLSBoMiA8IG1pblkpIHkyID0gbWluWSArIGgyO1xyXG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMueCxcclxuICAgICAgICAgICAgICAgIHcyID0gc2l6ZS54IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh4IC0gdzIgPCBtaW5YKSB4MiA9IG1pblggKyB3MjtcclxuICAgICAgICAgICAgaWYgKHggKyB3MiA+IG1heFgpIHgyID0gbWF4WCAtIHcyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcGFuIHRoZSBtYXAgaWYgdGhlIHNjcmVlbiBnb2VzIG9mZiB0aGUgcmFuZ2VcclxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IFBvaW50KFxyXG4gICAgICAgICAgICAgICAgeDIgIT09IHVuZGVmaW5lZCA/IHgyIDogdGhpcy54LFxyXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iLCIvLyBGb250IGRhdGEgRnJvbSBIZXJzaGV5IFNpbXBsZXggRm9udFxyXG4vLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvaGVyc2hleS9cclxudmFyIHNpbXBsZXhfZm9udCA9IHtcclxuICAgIFwiIFwiOiBbMTYsIFtdXSxcclxuICAgIFwiIVwiOiBbMTAsIFs1LCAyMSwgNSwgNywgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXHJcbiAgICBcIlxcXCJcIjogWzE2LCBbNCwgMjEsIDQsIDE0LCAtMSwgLTEsIDEyLCAyMSwgMTIsIDE0XV0sXHJcbiAgICBcIiNcIjogWzIxLCBbMTEsIDI1LCA0LCAtNywgLTEsIC0xLCAxNywgMjUsIDEwLCAtNywgLTEsIC0xLCA0LCAxMiwgMTgsIDEyLCAtMSwgLTEsIDMsIDYsIDE3LCA2XV0sXHJcbiAgICBcIiRcIjogWzIwLCBbOCwgMjUsIDgsIC00LCAtMSwgLTEsIDEyLCAyNSwgMTIsIC00LCAtMSwgLTEsIDE3LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxLCA1LCAyMCwgMywgMTgsIDMsIDE2LCA0LCAxNCwgNSwgMTMsIDcsIDEyLCAxMywgMTAsIDE1LCA5LCAxNiwgOCwgMTcsIDYsIDE3LCAzLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDMsIDNdXSxcclxuICAgIFwiJVwiOiBbMjQsIFsyMSwgMjEsIDMsIDAsIC0xLCAtMSwgOCwgMjEsIDEwLCAxOSwgMTAsIDE3LCA5LCAxNSwgNywgMTQsIDUsIDE0LCAzLCAxNiwgMywgMTgsIDQsIDIwLCA2LCAyMSwgOCwgMjEsIDEwLCAyMCwgMTMsIDE5LCAxNiwgMTksIDE5LCAyMCwgMjEsIDIxLCAtMSwgLTEsIDE3LCA3LCAxNSwgNiwgMTQsIDQsIDE0LCAyLCAxNiwgMCwgMTgsIDAsIDIwLCAxLCAyMSwgMywgMjEsIDUsIDE5LCA3LCAxNywgN11dLFxyXG4gICAgXCImXCI6IFsyNiwgWzIzLCAxMiwgMjMsIDEzLCAyMiwgMTQsIDIxLCAxNCwgMjAsIDEzLCAxOSwgMTEsIDE3LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA3LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA2LCA0LCA4LCA1LCA5LCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE2LCAxNCwgMTgsIDEzLCAyMCwgMTEsIDIxLCA5LCAyMCwgOCwgMTgsIDgsIDE2LCA5LCAxMywgMTEsIDEwLCAxNiwgMywgMTgsIDEsIDIwLCAwLCAyMiwgMCwgMjMsIDEsIDIzLCAyXV0sXHJcbiAgICBcIidcIjogWzEwLCBbNSwgMTksIDQsIDIwLCA1LCAyMSwgNiwgMjAsIDYsIDE4LCA1LCAxNiwgNCwgMTVdXSxcclxuICAgIFwiKFwiOiBbMTQsIFsxMSwgMjUsIDksIDIzLCA3LCAyMCwgNSwgMTYsIDQsIDExLCA0LCA3LCA1LCAyLCA3LCAtMiwgOSwgLTUsIDExLCAtN11dLFxyXG4gICAgXCIpXCI6IFsxNCwgWzMsIDI1LCA1LCAyMywgNywgMjAsIDksIDE2LCAxMCwgMTEsIDEwLCA3LCA5LCAyLCA3LCAtMiwgNSwgLTUsIDMsIC03XV0sXHJcbiAgICBcIipcIjogWzE2LCBbOCwgMjEsIDgsIDksIC0xLCAtMSwgMywgMTgsIDEzLCAxMiwgLTEsIC0xLCAxMywgMTgsIDMsIDEyXV0sXHJcbiAgICBcIitcIjogWzI2LCBbMTMsIDE4LCAxMywgMCwgLTEsIC0xLCA0LCA5LCAyMiwgOV1dLFxyXG4gICAgXCIsXCI6IFsxMCwgWzYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcclxuICAgIFwiLVwiOiBbMjYsIFs0LCA5LCAyMiwgOV1dLFxyXG4gICAgXCIuXCI6IFsxMCwgWzUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcclxuICAgIFwiL1wiOiBbMjIsIFsyMCwgMjUsIDIsIC03XV0sXHJcbiAgICBcIjBcIjogWzIwLCBbOSwgMjEsIDYsIDIwLCA0LCAxNywgMywgMTIsIDMsIDksIDQsIDQsIDYsIDEsIDksIDAsIDExLCAwLCAxNCwgMSwgMTYsIDQsIDE3LCA5LCAxNywgMTIsIDE2LCAxNywgMTQsIDIwLCAxMSwgMjEsIDksIDIxXV0sXHJcbiAgICBcIjFcIjogWzIwLCBbNiwgMTcsIDgsIDE4LCAxMSwgMjEsIDExLCAwXV0sXHJcbiAgICBcIjJcIjogWzIwLCBbNCwgMTYsIDQsIDE3LCA1LCAxOSwgNiwgMjAsIDgsIDIxLCAxMiwgMjEsIDE0LCAyMCwgMTUsIDE5LCAxNiwgMTcsIDE2LCAxNSwgMTUsIDEzLCAxMywgMTAsIDMsIDAsIDE3LCAwXV0sXHJcbiAgICBcIjNcIjogWzIwLCBbNSwgMjEsIDE2LCAyMSwgMTAsIDEzLCAxMywgMTMsIDE1LCAxMiwgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcclxuICAgIFwiNFwiOiBbMjAsIFsxMywgMjEsIDMsIDcsIDE4LCA3LCAtMSwgLTEsIDEzLCAyMSwgMTMsIDBdXSxcclxuICAgIFwiNVwiOiBbMjAsIFsxNSwgMjEsIDUsIDIxLCA0LCAxMiwgNSwgMTMsIDgsIDE0LCAxMSwgMTQsIDE0LCAxMywgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcclxuICAgIFwiNlwiOiBbMjAsIFsxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCAxMCwgMjEsIDcsIDIwLCA1LCAxNywgNCwgMTIsIDQsIDcsIDUsIDMsIDcsIDEsIDEwLCAwLCAxMSwgMCwgMTQsIDEsIDE2LCAzLCAxNywgNiwgMTcsIDcsIDE2LCAxMCwgMTQsIDEyLCAxMSwgMTMsIDEwLCAxMywgNywgMTIsIDUsIDEwLCA0LCA3XV0sXHJcbiAgICBcIjdcIjogWzIwLCBbMTcsIDIxLCA3LCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjFdXSxcclxuICAgIFwiOFwiOiBbMjAsIFs4LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTQsIDcsIDEzLCAxMSwgMTIsIDE0LCAxMSwgMTYsIDksIDE3LCA3LCAxNywgNCwgMTYsIDIsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNywgNCwgOSwgNiwgMTEsIDksIDEyLCAxMywgMTMsIDE1LCAxNCwgMTYsIDE2LCAxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMV1dLFxyXG4gICAgXCI5XCI6IFsyMCwgWzE2LCAxNCwgMTUsIDExLCAxMywgOSwgMTAsIDgsIDksIDgsIDYsIDksIDQsIDExLCAzLCAxNCwgMywgMTUsIDQsIDE4LCA2LCAyMCwgOSwgMjEsIDEwLCAyMSwgMTMsIDIwLCAxNSwgMTgsIDE2LCAxNCwgMTYsIDksIDE1LCA0LCAxMywgMSwgMTAsIDAsIDgsIDAsIDUsIDEsIDQsIDNdXSxcclxuICAgIFwiOlwiOiBbMTAsIFs1LCAxNCwgNCwgMTMsIDUsIDEyLCA2LCAxMywgNSwgMTQsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxyXG4gICAgXCI7XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXHJcbiAgICBcIjxcIjogWzI0LCBbMjAsIDE4LCA0LCA5LCAyMCwgMF1dLFxyXG4gICAgXCI9XCI6IFsyNiwgWzQsIDEyLCAyMiwgMTIsIC0xLCAtMSwgNCwgNiwgMjIsIDZdXSxcclxuICAgIFwiPlwiOiBbMjQsIFs0LCAxOCwgMjAsIDksIDQsIDBdXSxcclxuICAgIFwiP1wiOiBbMTgsIFszLCAxNiwgMywgMTcsIDQsIDE5LCA1LCAyMCwgNywgMjEsIDExLCAyMSwgMTMsIDIwLCAxNCwgMTksIDE1LCAxNywgMTUsIDE1LCAxNCwgMTMsIDEzLCAxMiwgOSwgMTAsIDksIDcsIC0xLCAtMSwgOSwgMiwgOCwgMSwgOSwgMCwgMTAsIDEsIDksIDJdXSxcclxuICAgIFwiQFwiOiBbMjcsIFsxOCwgMTMsIDE3LCAxNSwgMTUsIDE2LCAxMiwgMTYsIDEwLCAxNSwgOSwgMTQsIDgsIDExLCA4LCA4LCA5LCA2LCAxMSwgNSwgMTQsIDUsIDE2LCA2LCAxNywgOCwgLTEsIC0xLCAxMiwgMTYsIDEwLCAxNCwgOSwgMTEsIDksIDgsIDEwLCA2LCAxMSwgNSwgLTEsIC0xLCAxOCwgMTYsIDE3LCA4LCAxNywgNiwgMTksIDUsIDIxLCA1LCAyMywgNywgMjQsIDEwLCAyNCwgMTIsIDIzLCAxNSwgMjIsIDE3LCAyMCwgMTksIDE4LCAyMCwgMTUsIDIxLCAxMiwgMjEsIDksIDIwLCA3LCAxOSwgNSwgMTcsIDQsIDE1LCAzLCAxMiwgMywgOSwgNCwgNiwgNSwgNCwgNywgMiwgOSwgMSwgMTIsIDAsIDE1LCAwLCAxOCwgMSwgMjAsIDIsIDIxLCAzLCAtMSwgLTEsIDE5LCAxNiwgMTgsIDgsIDE4LCA2LCAxOSwgNV1dLFxyXG4gICAgXCJBXCI6IFsxOCwgWzksIDIxLCAxLCAwLCAtMSwgLTEsIDksIDIxLCAxNywgMCwgLTEsIC0xLCA0LCA3LCAxNCwgN11dLFxyXG4gICAgXCJCXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNSwgMTcsIDEzLCAxNiwgMTIsIDEzLCAxMSwgLTEsIC0xLCA0LCAxMSwgMTMsIDExLCAxNiwgMTAsIDE3LCA5LCAxOCwgNywgMTgsIDQsIDE3LCAyLCAxNiwgMSwgMTMsIDAsIDQsIDBdXSxcclxuICAgIFwiQ1wiOiBbMjEsIFsxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDVdXSxcclxuICAgIFwiRFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTEsIDIxLCAxNCwgMjAsIDE2LCAxOCwgMTcsIDE2LCAxOCwgMTMsIDE4LCA4LCAxNywgNSwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgNCwgMF1dLFxyXG4gICAgXCJFXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMSwgLTEsIC0xLCA0LCAwLCAxNywgMF1dLFxyXG4gICAgXCJGXCI6IFsxOCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMV1dLFxyXG4gICAgXCJHXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTgsIDgsIC0xLCAtMSwgMTMsIDgsIDE4LCA4XV0sXHJcbiAgICBcIkhcIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMCwgLTEsIC0xLCA0LCAxMSwgMTgsIDExXV0sXHJcbiAgICBcIklcIjogWzgsIFs0LCAyMSwgNCwgMF1dLFxyXG4gICAgXCJKXCI6IFsxNiwgWzEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN11dLFxyXG4gICAgXCJLXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgNCwgNywgLTEsIC0xLCA5LCAxMiwgMTgsIDBdXSxcclxuICAgIFwiTFwiOiBbMTcsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAwLCAxNiwgMF1dLFxyXG4gICAgXCJNXCI6IFsyNCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMjAsIDBdXSxcclxuICAgIFwiTlwiOiBbMjIsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTgsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMF1dLFxyXG4gICAgXCJPXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjFdXSxcclxuICAgIFwiUFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTQsIDE3LCAxMiwgMTYsIDExLCAxMywgMTAsIDQsIDEwXV0sXHJcbiAgICBcIlFcIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgLTEsIC0xLCAxMiwgNCwgMTgsIC0yXV0sXHJcbiAgICBcIlJcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE1LCAxNywgMTMsIDE2LCAxMiwgMTMsIDExLCA0LCAxMSwgLTEsIC0xLCAxMSwgMTEsIDE4LCAwXV0sXHJcbiAgICBcIlNcIjogWzIwLCBbMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxyXG4gICAgXCJUXCI6IFsxNiwgWzgsIDIxLCA4LCAwLCAtMSwgLTEsIDEsIDIxLCAxNSwgMjFdXSxcclxuICAgIFwiVVwiOiBbMjIsIFs0LCAyMSwgNCwgNiwgNSwgMywgNywgMSwgMTAsIDAsIDEyLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA2LCAxOCwgMjFdXSxcclxuICAgIFwiVlwiOiBbMTgsIFsxLCAyMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDBdXSxcclxuICAgIFwiV1wiOiBbMjQsIFsyLCAyMSwgNywgMCwgLTEsIC0xLCAxMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCAxNywgMCwgLTEsIC0xLCAyMiwgMjEsIDE3LCAwXV0sXHJcbiAgICBcIlhcIjogWzIwLCBbMywgMjEsIDE3LCAwLCAtMSwgLTEsIDE3LCAyMSwgMywgMF1dLFxyXG4gICAgXCJZXCI6IFsxOCwgWzEsIDIxLCA5LCAxMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDExXV0sXHJcbiAgICBcIlpcIjogWzIwLCBbMTcsIDIxLCAzLCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjEsIC0xLCAtMSwgMywgMCwgMTcsIDBdXSxcclxuICAgIFwiW1wiOiBbMTQsIFs0LCAyNSwgNCwgLTcsIC0xLCAtMSwgNSwgMjUsIDUsIC03LCAtMSwgLTEsIDQsIDI1LCAxMSwgMjUsIC0xLCAtMSwgNCwgLTcsIDExLCAtN11dLFxyXG4gICAgXCJcXFxcXCI6IFsxNCwgWzAsIDIxLCAxNCwgLTNdXSxcclxuICAgIFwiXVwiOiBbMTQsIFs5LCAyNSwgOSwgLTcsIC0xLCAtMSwgMTAsIDI1LCAxMCwgLTcsIC0xLCAtMSwgMywgMjUsIDEwLCAyNSwgLTEsIC0xLCAzLCAtNywgMTAsIC03XV0sXHJcbiAgICBcIl5cIjogWzE2LCBbNiwgMTUsIDgsIDE4LCAxMCwgMTUsIC0xLCAtMSwgMywgMTIsIDgsIDE3LCAxMywgMTIsIC0xLCAtMSwgOCwgMTcsIDgsIDBdXSxcclxuICAgIFwiX1wiOiBbMTYsIFswLCAtMiwgMTYsIC0yXV0sXHJcbiAgICBcImBcIjogWzEwLCBbNiwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE1LCA2LCAxNiwgNSwgMTddXSxcclxuICAgIFwiYVwiOiBbMTksIFsxNSwgMTQsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcclxuICAgIFwiYlwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcclxuICAgIFwiY1wiOiBbMTgsIFsxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXHJcbiAgICBcImRcIjogWzE5LCBbMTUsIDIxLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXHJcbiAgICBcImVcIjogWzE4LCBbMywgOCwgMTUsIDgsIDE1LCAxMCwgMTQsIDEyLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxyXG4gICAgXCJmXCI6IFsxMiwgWzEwLCAyMSwgOCwgMjEsIDYsIDIwLCA1LCAxNywgNSwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcclxuICAgIFwiZ1wiOiBbMTksIFsxNSwgMTQsIDE1LCAtMiwgMTQsIC01LCAxMywgLTYsIDExLCAtNywgOCwgLTcsIDYsIC02LCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcclxuICAgIFwiaFwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxyXG4gICAgXCJpXCI6IFs4LCBbMywgMjEsIDQsIDIwLCA1LCAyMSwgNCwgMjIsIDMsIDIxLCAtMSwgLTEsIDQsIDE0LCA0LCAwXV0sXHJcbiAgICBcImpcIjogWzEwLCBbNSwgMjEsIDYsIDIwLCA3LCAyMSwgNiwgMjIsIDUsIDIxLCAtMSwgLTEsIDYsIDE0LCA2LCAtMywgNSwgLTYsIDMsIC03LCAxLCAtN11dLFxyXG4gICAgXCJrXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE0LCAxNCwgNCwgNCwgLTEsIC0xLCA4LCA4LCAxNSwgMF1dLFxyXG4gICAgXCJsXCI6IFs4LCBbNCwgMjEsIDQsIDBdXSxcclxuICAgIFwibVwiOiBbMzAsIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTAsIDE4LCAxMywgMjAsIDE0LCAyMywgMTQsIDI1LCAxMywgMjYsIDEwLCAyNiwgMF1dLFxyXG4gICAgXCJuXCI6IFsxOSwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXHJcbiAgICBcIm9cIjogWzE5LCBbOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgMywgMTYsIDYsIDE2LCA4LCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNF1dLFxyXG4gICAgXCJwXCI6IFsxOSwgWzQsIDE0LCA0LCAtNywgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcclxuICAgIFwicVwiOiBbMTksIFsxNSwgMTQsIDE1LCAtNywgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXHJcbiAgICBcInJcIjogWzEzLCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgOCwgNSwgMTEsIDcsIDEzLCA5LCAxNCwgMTIsIDE0XV0sXHJcbiAgICBcInNcIjogWzE3LCBbMTQsIDExLCAxMywgMTMsIDEwLCAxNCwgNywgMTQsIDQsIDEzLCAzLCAxMSwgNCwgOSwgNiwgOCwgMTEsIDcsIDEzLCA2LCAxNCwgNCwgMTQsIDMsIDEzLCAxLCAxMCwgMCwgNywgMCwgNCwgMSwgMywgM11dLFxyXG4gICAgXCJ0XCI6IFsxMiwgWzUsIDIxLCA1LCA0LCA2LCAxLCA4LCAwLCAxMCwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcclxuICAgIFwidVwiOiBbMTksIFs0LCAxNCwgNCwgNCwgNSwgMSwgNywgMCwgMTAsIDAsIDEyLCAxLCAxNSwgNCwgLTEsIC0xLCAxNSwgMTQsIDE1LCAwXV0sXHJcbiAgICBcInZcIjogWzE2LCBbMiwgMTQsIDgsIDAsIC0xLCAtMSwgMTQsIDE0LCA4LCAwXV0sXHJcbiAgICBcIndcIjogWzIyLCBbMywgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgMTUsIDAsIC0xLCAtMSwgMTksIDE0LCAxNSwgMF1dLFxyXG4gICAgXCJ4XCI6IFsxNywgWzMsIDE0LCAxNCwgMCwgLTEsIC0xLCAxNCwgMTQsIDMsIDBdXSxcclxuICAgIFwieVwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDAsIDYsIC00LCA0LCAtNiwgMiwgLTcsIDEsIC03XV0sXHJcbiAgICBcInpcIjogWzE3LCBbMTQsIDE0LCAzLCAwLCAtMSwgLTEsIDMsIDE0LCAxNCwgMTQsIC0xLCAtMSwgMywgMCwgMTQsIDBdXSxcclxuICAgIFwie1wiOiBbMTQsIFs5LCAyNSwgNywgMjQsIDYsIDIzLCA1LCAyMSwgNSwgMTksIDYsIDE3LCA3LCAxNiwgOCwgMTQsIDgsIDEyLCA2LCAxMCwgLTEsIC0xLCA3LCAyNCwgNiwgMjIsIDYsIDIwLCA3LCAxOCwgOCwgMTcsIDksIDE1LCA5LCAxMywgOCwgMTEsIDQsIDksIDgsIDcsIDksIDUsIDksIDMsIDgsIDEsIDcsIDAsIDYsIC0yLCA2LCAtNCwgNywgLTYsIC0xLCAtMSwgNiwgOCwgOCwgNiwgOCwgNCwgNywgMiwgNiwgMSwgNSwgLTEsIDUsIC0zLCA2LCAtNSwgNywgLTYsIDksIC03XV0sXHJcbiAgICBcInxcIjogWzgsIFs0LCAyNSwgNCwgLTddXSxcclxuICAgIFwifVwiOiBbMTQsIFs1LCAyNSwgNywgMjQsIDgsIDIzLCA5LCAyMSwgOSwgMTksIDgsIDE3LCA3LCAxNiwgNiwgMTQsIDYsIDEyLCA4LCAxMCwgLTEsIC0xLCA3LCAyNCwgOCwgMjIsIDgsIDIwLCA3LCAxOCwgNiwgMTcsIDUsIDE1LCA1LCAxMywgNiwgMTEsIDEwLCA5LCA2LCA3LCA1LCA1LCA1LCAzLCA2LCAxLCA3LCAwLCA4LCAtMiwgOCwgLTQsIDcsIC02LCAtMSwgLTEsIDgsIDgsIDYsIDYsIDYsIDQsIDcsIDIsIDgsIDEsIDksIC0xLCA5LCAtMywgOCwgLTUsIDcsIC02LCA1LCAtN11dLFxyXG4gICAgXCJ+XCI6IFsyNCwgWzMsIDYsIDMsIDgsIDQsIDExLCA2LCAxMiwgOCwgMTIsIDEwLCAxMSwgMTQsIDgsIDE2LCA3LCAxOCwgNywgMjAsIDgsIDIxLCAxMCwgLTEsIC0xLCAzLCA4LCA0LCAxMCwgNiwgMTEsIDgsIDExLCAxMCwgMTAsIDE0LCA3LCAxNiwgNiwgMTgsIDYsIDIwLCA3LCAyMSwgMTAsIDIxLCAxMl1dLFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XHJcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblxyXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcclxuICAgICAgICBpLCBsZW4sIGosIGxlbjIsIGdseXBoLCBkYXRhLCB4LCB5LCBwcmV2O1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBnbHlwaCA9IHNpbXBsZXhfZm9udFt0ZXh0W2ldXTtcclxuICAgICAgICBpZiAoIWdseXBoKSBjb250aW51ZTtcclxuICAgICAgICBwcmV2ID0gbnVsbDtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMiA9IGdseXBoWzFdLmxlbmd0aDsgaiA8IGxlbjI7IGogKz0gMikge1xyXG4gICAgICAgICAgICBpZiAoZ2x5cGhbMV1bal0gPT09IC0xICYmIGdseXBoWzFdW2ogKyAxXSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHkgPSBiYXNlbGluZSAtIGdseXBoWzFdW2ogKyAxXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJldiA9IHt4OiB4LCB5OiB5fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZWZ0ICs9IGdseXBoWzBdICogc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cm9rZXM7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xyXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcclxuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcclxuICogQHZlcnNpb24gMi4yLjBcclxuICovXHJcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xyXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXHJcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cclxuKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3ZhciB0PXt9O3R5cGVvZiBleHBvcnRzPT1cInVuZGVmaW5lZFwiP3R5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGRlZmluZS5hbWQ9PVwib2JqZWN0XCImJmRlZmluZS5hbWQ/KHQuZXhwb3J0cz17fSxkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gdC5leHBvcnRzfSkpOnQuZXhwb3J0cz10eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiP3dpbmRvdzplOnQuZXhwb3J0cz1leHBvcnRzLGZ1bmN0aW9uKGUpe2lmKCF0KXZhciB0PTFlLTY7aWYoIW4pdmFyIG49dHlwZW9mIEZsb2F0MzJBcnJheSE9XCJ1bmRlZmluZWRcIj9GbG9hdDMyQXJyYXk6QXJyYXk7aWYoIXIpdmFyIHI9TWF0aC5yYW5kb207dmFyIGk9e307aS5zZXRNYXRyaXhBcnJheVR5cGU9ZnVuY3Rpb24oZSl7bj1lfSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUuZ2xNYXRyaXg9aSk7dmFyIHM9e307cy5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbigyKTtyZXR1cm4gZVswXT0wLGVbMV09MCxlfSxzLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDIpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHR9LHMuZnJvbVZhbHVlcz1mdW5jdGlvbihlLHQpe3ZhciByPW5ldyBuKDIpO3JldHVybiByWzBdPWUsclsxXT10LHJ9LHMuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGV9LHMuc2V0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10LGVbMV09bixlfSxzLmFkZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXStuWzBdLGVbMV09dFsxXStuWzFdLGV9LHMuc3VidHJhY3Q9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0tblswXSxlWzFdPXRbMV0tblsxXSxlfSxzLnN1Yj1zLnN1YnRyYWN0LHMubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qblswXSxlWzFdPXRbMV0qblsxXSxlfSxzLm11bD1zLm11bHRpcGx5LHMuZGl2aWRlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdL25bMF0sZVsxXT10WzFdL25bMV0sZX0scy5kaXY9cy5kaXZpZGUscy5taW49ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWluKHRbMF0sblswXSksZVsxXT1NYXRoLm1pbih0WzFdLG5bMV0pLGV9LHMubWF4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1heCh0WzBdLG5bMF0pLGVbMV09TWF0aC5tYXgodFsxXSxuWzFdKSxlfSxzLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm4sZVsxXT10WzFdKm4sZX0scy5zY2FsZUFuZEFkZD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZVswXT10WzBdK25bMF0qcixlWzFdPXRbMV0rblsxXSpyLGV9LHMuZGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV07cmV0dXJuIE1hdGguc3FydChuKm4rcipyKX0scy5kaXN0PXMuZGlzdGFuY2Uscy5zcXVhcmVkRGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV07cmV0dXJuIG4qbityKnJ9LHMuc3FyRGlzdD1zLnNxdWFyZWREaXN0YW5jZSxzLmxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtuKm4pfSxzLmxlbj1zLmxlbmd0aCxzLnNxdWFyZWRMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV07cmV0dXJuIHQqdCtuKm59LHMuc3FyTGVuPXMuc3F1YXJlZExlbmd0aCxzLm5lZ2F0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPS10WzBdLGVbMV09LXRbMV0sZX0scy5ub3JtYWxpemU9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPW4qbityKnI7cmV0dXJuIGk+MCYmKGk9MS9NYXRoLnNxcnQoaSksZVswXT10WzBdKmksZVsxXT10WzFdKmkpLGV9LHMuZG90PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF0qdFswXStlWzFdKnRbMV19LHMuY3Jvc3M9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0qblsxXS10WzFdKm5bMF07cmV0dXJuIGVbMF09ZVsxXT0wLGVbMl09cixlfSxzLmxlcnA9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9dFswXSxzPXRbMV07cmV0dXJuIGVbMF09aStyKihuWzBdLWkpLGVbMV09cytyKihuWzFdLXMpLGV9LHMucmFuZG9tPWZ1bmN0aW9uKGUsdCl7dD10fHwxO3ZhciBuPXIoKSoyKk1hdGguUEk7cmV0dXJuIGVbMF09TWF0aC5jb3MobikqdCxlWzFdPU1hdGguc2luKG4pKnQsZX0scy50cmFuc2Zvcm1NYXQyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXTtyZXR1cm4gZVswXT1uWzBdKnIrblsyXSppLGVbMV09blsxXSpyK25bM10qaSxlfSxzLnRyYW5zZm9ybU1hdDJkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXTtyZXR1cm4gZVswXT1uWzBdKnIrblsyXSppK25bNF0sZVsxXT1uWzFdKnIrblszXSppK25bNV0sZX0scy50cmFuc2Zvcm1NYXQzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXTtyZXR1cm4gZVswXT1uWzBdKnIrblszXSppK25bNl0sZVsxXT1uWzFdKnIrbls0XSppK25bN10sZX0scy50cmFuc2Zvcm1NYXQ0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXTtyZXR1cm4gZVswXT1uWzBdKnIrbls0XSppK25bMTJdLGVbMV09blsxXSpyK25bNV0qaStuWzEzXSxlfSxzLmZvckVhY2g9ZnVuY3Rpb24oKXt2YXIgZT1zLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbih0LG4scixpLHMsbyl7dmFyIHUsYTtufHwobj0yKSxyfHwocj0wKSxpP2E9TWF0aC5taW4oaSpuK3IsdC5sZW5ndGgpOmE9dC5sZW5ndGg7Zm9yKHU9cjt1PGE7dSs9billWzBdPXRbdV0sZVsxXT10W3UrMV0scyhlLGUsbyksdFt1XT1lWzBdLHRbdSsxXT1lWzFdO3JldHVybiB0fX0oKSxzLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cInZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLnZlYzI9cyk7dmFyIG89e307by5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbigzKTtyZXR1cm4gZVswXT0wLGVbMV09MCxlWzJdPTAsZX0sby5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbigzKTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdH0sby5mcm9tVmFsdWVzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1uZXcgbigzKTtyZXR1cm4gaVswXT1lLGlbMV09dCxpWzJdPXIsaX0sby5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGV9LG8uc2V0PWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBlWzBdPXQsZVsxXT1uLGVbMl09cixlfSxvLmFkZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXStuWzBdLGVbMV09dFsxXStuWzFdLGVbMl09dFsyXStuWzJdLGV9LG8uc3VidHJhY3Q9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0tblswXSxlWzFdPXRbMV0tblsxXSxlWzJdPXRbMl0tblsyXSxlfSxvLnN1Yj1vLnN1YnRyYWN0LG8ubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qblswXSxlWzFdPXRbMV0qblsxXSxlWzJdPXRbMl0qblsyXSxlfSxvLm11bD1vLm11bHRpcGx5LG8uZGl2aWRlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdL25bMF0sZVsxXT10WzFdL25bMV0sZVsyXT10WzJdL25bMl0sZX0sby5kaXY9by5kaXZpZGUsby5taW49ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWluKHRbMF0sblswXSksZVsxXT1NYXRoLm1pbih0WzFdLG5bMV0pLGVbMl09TWF0aC5taW4odFsyXSxuWzJdKSxlfSxvLm1heD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5tYXgodFswXSxuWzBdKSxlWzFdPU1hdGgubWF4KHRbMV0sblsxXSksZVsyXT1NYXRoLm1heCh0WzJdLG5bMl0pLGV9LG8uc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qbixlWzFdPXRbMV0qbixlWzJdPXRbMl0qbixlfSxvLnNjYWxlQW5kQWRkPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBlWzBdPXRbMF0rblswXSpyLGVbMV09dFsxXStuWzFdKnIsZVsyXT10WzJdK25bMl0qcixlfSxvLmRpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdLGk9dFsyXS1lWzJdO3JldHVybiBNYXRoLnNxcnQobipuK3IqcitpKmkpfSxvLmRpc3Q9by5kaXN0YW5jZSxvLnNxdWFyZWREaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXSxpPXRbMl0tZVsyXTtyZXR1cm4gbipuK3IqcitpKml9LG8uc3FyRGlzdD1vLnNxdWFyZWREaXN0YW5jZSxvLmxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl07cmV0dXJuIE1hdGguc3FydCh0KnQrbipuK3Iqcil9LG8ubGVuPW8ubGVuZ3RoLG8uc3F1YXJlZExlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl07cmV0dXJuIHQqdCtuKm4rcipyfSxvLnNxckxlbj1vLnNxdWFyZWRMZW5ndGgsby5uZWdhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT0tdFswXSxlWzFdPS10WzFdLGVbMl09LXRbMl0sZX0sby5ub3JtYWxpemU9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz1uKm4rcipyK2kqaTtyZXR1cm4gcz4wJiYocz0xL01hdGguc3FydChzKSxlWzBdPXRbMF0qcyxlWzFdPXRbMV0qcyxlWzJdPXRbMl0qcyksZX0sby5kb3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXSp0WzBdK2VbMV0qdFsxXStlWzJdKnRbMl19LG8uY3Jvc3M9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPW5bMF0sdT1uWzFdLGE9blsyXTtyZXR1cm4gZVswXT1pKmEtcyp1LGVbMV09cypvLXIqYSxlWzJdPXIqdS1pKm8sZX0sby5sZXJwPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXRbMF0scz10WzFdLG89dFsyXTtyZXR1cm4gZVswXT1pK3IqKG5bMF0taSksZVsxXT1zK3IqKG5bMV0tcyksZVsyXT1vK3IqKG5bMl0tbyksZX0sby5yYW5kb209ZnVuY3Rpb24oZSx0KXt0PXR8fDE7dmFyIG49cigpKjIqTWF0aC5QSSxpPXIoKSoyLTEscz1NYXRoLnNxcnQoMS1pKmkpKnQ7cmV0dXJuIGVbMF09TWF0aC5jb3MobikqcyxlWzFdPU1hdGguc2luKG4pKnMsZVsyXT1pKnQsZX0sby50cmFuc2Zvcm1NYXQ0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl07cmV0dXJuIGVbMF09blswXSpyK25bNF0qaStuWzhdKnMrblsxMl0sZVsxXT1uWzFdKnIrbls1XSppK25bOV0qcytuWzEzXSxlWzJdPW5bMl0qcituWzZdKmkrblsxMF0qcytuWzE0XSxlfSxvLnRyYW5zZm9ybU1hdDM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXTtyZXR1cm4gZVswXT1yKm5bMF0raSpuWzNdK3Mqbls2XSxlWzFdPXIqblsxXStpKm5bNF0rcypuWzddLGVbMl09cipuWzJdK2kqbls1XStzKm5bOF0sZX0sby50cmFuc2Zvcm1RdWF0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz1uWzBdLHU9blsxXSxhPW5bMl0sZj1uWzNdLGw9ZipyK3Uqcy1hKmksYz1mKmkrYSpyLW8qcyxoPWYqcytvKmktdSpyLHA9LW8qci11KmktYSpzO3JldHVybiBlWzBdPWwqZitwKi1vK2MqLWEtaCotdSxlWzFdPWMqZitwKi11K2gqLW8tbCotYSxlWzJdPWgqZitwKi1hK2wqLXUtYyotbyxlfSxvLmZvckVhY2g9ZnVuY3Rpb24oKXt2YXIgZT1vLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbih0LG4scixpLHMsbyl7dmFyIHUsYTtufHwobj0zKSxyfHwocj0wKSxpP2E9TWF0aC5taW4oaSpuK3IsdC5sZW5ndGgpOmE9dC5sZW5ndGg7Zm9yKHU9cjt1PGE7dSs9billWzBdPXRbdV0sZVsxXT10W3UrMV0sZVsyXT10W3UrMl0scyhlLGUsbyksdFt1XT1lWzBdLHRbdSsxXT1lWzFdLHRbdSsyXT1lWzJdO3JldHVybiB0fX0oKSxvLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cInZlYzMoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLnZlYzM9byk7dmFyIHU9e307dS5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbig0KTtyZXR1cm4gZVswXT0wLGVbMV09MCxlWzJdPTAsZVszXT0wLGV9LHUuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oNCk7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHRbM109ZVszXSx0fSx1LmZyb21WYWx1ZXM9ZnVuY3Rpb24oZSx0LHIsaSl7dmFyIHM9bmV3IG4oNCk7cmV0dXJuIHNbMF09ZSxzWzFdPXQsc1syXT1yLHNbM109aSxzfSx1LmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGV9LHUuc2V0PWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIGVbMF09dCxlWzFdPW4sZVsyXT1yLGVbM109aSxlfSx1LmFkZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXStuWzBdLGVbMV09dFsxXStuWzFdLGVbMl09dFsyXStuWzJdLGVbM109dFszXStuWzNdLGV9LHUuc3VidHJhY3Q9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0tblswXSxlWzFdPXRbMV0tblsxXSxlWzJdPXRbMl0tblsyXSxlWzNdPXRbM10tblszXSxlfSx1LnN1Yj11LnN1YnRyYWN0LHUubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qblswXSxlWzFdPXRbMV0qblsxXSxlWzJdPXRbMl0qblsyXSxlWzNdPXRbM10qblszXSxlfSx1Lm11bD11Lm11bHRpcGx5LHUuZGl2aWRlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdL25bMF0sZVsxXT10WzFdL25bMV0sZVsyXT10WzJdL25bMl0sZVszXT10WzNdL25bM10sZX0sdS5kaXY9dS5kaXZpZGUsdS5taW49ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWluKHRbMF0sblswXSksZVsxXT1NYXRoLm1pbih0WzFdLG5bMV0pLGVbMl09TWF0aC5taW4odFsyXSxuWzJdKSxlWzNdPU1hdGgubWluKHRbM10sblszXSksZX0sdS5tYXg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWF4KHRbMF0sblswXSksZVsxXT1NYXRoLm1heCh0WzFdLG5bMV0pLGVbMl09TWF0aC5tYXgodFsyXSxuWzJdKSxlWzNdPU1hdGgubWF4KHRbM10sblszXSksZX0sdS5zY2FsZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuLGVbMV09dFsxXSpuLGVbMl09dFsyXSpuLGVbM109dFszXSpuLGV9LHUuc2NhbGVBbmRBZGQ9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGVbMF09dFswXStuWzBdKnIsZVsxXT10WzFdK25bMV0qcixlWzJdPXRbMl0rblsyXSpyLGVbM109dFszXStuWzNdKnIsZX0sdS5kaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXSxpPXRbMl0tZVsyXSxzPXRbM10tZVszXTtyZXR1cm4gTWF0aC5zcXJ0KG4qbityKnIraSppK3Mqcyl9LHUuZGlzdD11LmRpc3RhbmNlLHUuc3F1YXJlZERpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdLGk9dFsyXS1lWzJdLHM9dFszXS1lWzNdO3JldHVybiBuKm4rcipyK2kqaStzKnN9LHUuc3FyRGlzdD11LnNxdWFyZWREaXN0YW5jZSx1Lmxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0saT1lWzNdO3JldHVybiBNYXRoLnNxcnQodCp0K24qbityKnIraSppKX0sdS5sZW49dS5sZW5ndGgsdS5zcXVhcmVkTGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxpPWVbM107cmV0dXJuIHQqdCtuKm4rcipyK2kqaX0sdS5zcXJMZW49dS5zcXVhcmVkTGVuZ3RoLHUubmVnYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09LXRbMF0sZVsxXT0tdFsxXSxlWzJdPS10WzJdLGVbM109LXRbM10sZX0sdS5ub3JtYWxpemU9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89bipuK3IqcitpKmkrcypzO3JldHVybiBvPjAmJihvPTEvTWF0aC5zcXJ0KG8pLGVbMF09dFswXSpvLGVbMV09dFsxXSpvLGVbMl09dFsyXSpvLGVbM109dFszXSpvKSxlfSx1LmRvdD1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdKnRbMF0rZVsxXSp0WzFdK2VbMl0qdFsyXStlWzNdKnRbM119LHUubGVycD1mdW5jdGlvbihlLHQsbixyKXt2YXIgaT10WzBdLHM9dFsxXSxvPXRbMl0sdT10WzNdO3JldHVybiBlWzBdPWkrciooblswXS1pKSxlWzFdPXMrciooblsxXS1zKSxlWzJdPW8rciooblsyXS1vKSxlWzNdPXUrciooblszXS11KSxlfSx1LnJhbmRvbT1mdW5jdGlvbihlLHQpe3JldHVybiB0PXR8fDEsZVswXT1yKCksZVsxXT1yKCksZVsyXT1yKCksZVszXT1yKCksdS5ub3JtYWxpemUoZSxlKSx1LnNjYWxlKGUsZSx0KSxlfSx1LnRyYW5zZm9ybU1hdDQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM107cmV0dXJuIGVbMF09blswXSpyK25bNF0qaStuWzhdKnMrblsxMl0qbyxlWzFdPW5bMV0qcituWzVdKmkrbls5XSpzK25bMTNdKm8sZVsyXT1uWzJdKnIrbls2XSppK25bMTBdKnMrblsxNF0qbyxlWzNdPW5bM10qcituWzddKmkrblsxMV0qcytuWzE1XSpvLGV9LHUudHJhbnNmb3JtUXVhdD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89blswXSx1PW5bMV0sYT1uWzJdLGY9blszXSxsPWYqcit1KnMtYSppLGM9ZippK2Eqci1vKnMsaD1mKnMrbyppLXUqcixwPS1vKnItdSppLWEqcztyZXR1cm4gZVswXT1sKmYrcCotbytjKi1hLWgqLXUsZVsxXT1jKmYrcCotdStoKi1vLWwqLWEsZVsyXT1oKmYrcCotYStsKi11LWMqLW8sZX0sdS5mb3JFYWNoPWZ1bmN0aW9uKCl7dmFyIGU9dS5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24odCxuLHIsaSxzLG8pe3ZhciB1LGE7bnx8KG49NCkscnx8KHI9MCksaT9hPU1hdGgubWluKGkqbityLHQubGVuZ3RoKTphPXQubGVuZ3RoO2Zvcih1PXI7dTxhO3UrPW4pZVswXT10W3VdLGVbMV09dFt1KzFdLGVbMl09dFt1KzJdLGVbM109dFt1KzNdLHMoZSxlLG8pLHRbdV09ZVswXSx0W3UrMV09ZVsxXSx0W3UrMl09ZVsyXSx0W3UrM109ZVszXTtyZXR1cm4gdH19KCksdS5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ2ZWM0KFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS52ZWM0PXUpO3ZhciBhPXt9O2EuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oNCk7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MSxlfSxhLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDQpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0WzNdPWVbM10sdH0sYS5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlfSxhLmlkZW50aXR5PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTEsZX0sYS50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXtpZihlPT09dCl7dmFyIG49dFsxXTtlWzFdPXRbMl0sZVsyXT1ufWVsc2UgZVswXT10WzBdLGVbMV09dFsyXSxlWzJdPXRbMV0sZVszXT10WzNdO3JldHVybiBlfSxhLmludmVydD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz1uKnMtaSpyO3JldHVybiBvPyhvPTEvbyxlWzBdPXMqbyxlWzFdPS1yKm8sZVsyXT0taSpvLGVbM109bipvLGUpOm51bGx9LGEuYWRqb2ludD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF07cmV0dXJuIGVbMF09dFszXSxlWzFdPS10WzFdLGVbMl09LXRbMl0sZVszXT1uLGV9LGEuZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF0qZVszXS1lWzJdKmVbMV19LGEubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1uWzBdLGE9blsxXSxmPW5bMl0sbD1uWzNdO3JldHVybiBlWzBdPXIqdStpKmYsZVsxXT1yKmEraSpsLGVbMl09cyp1K28qZixlWzNdPXMqYStvKmwsZX0sYS5tdWw9YS5tdWx0aXBseSxhLnJvdGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09ciphK2kqdSxlWzFdPXIqLXUraSphLGVbMl09cyphK28qdSxlWzNdPXMqLXUrbyphLGV9LGEuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1uWzBdLGE9blsxXTtyZXR1cm4gZVswXT1yKnUsZVsxXT1pKmEsZVsyXT1zKnUsZVszXT1vKmEsZX0sYS5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYXQyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5tYXQyPWEpO3ZhciBmPXt9O2YuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oNik7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MSxlWzRdPTAsZVs1XT0wLGV9LGYuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oNik7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHRbM109ZVszXSx0WzRdPWVbNF0sdFs1XT1lWzVdLHR9LGYuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZVs0XT10WzRdLGVbNV09dFs1XSxlfSxmLmlkZW50aXR5PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTEsZVs0XT0wLGVbNV09MCxlfSxmLmludmVydD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPW4qcy1yKmk7cmV0dXJuIGE/KGE9MS9hLGVbMF09cyphLGVbMV09LXIqYSxlWzJdPS1pKmEsZVszXT1uKmEsZVs0XT0oaSp1LXMqbykqYSxlWzVdPShyKm8tbip1KSphLGUpOm51bGx9LGYuZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF0qZVszXS1lWzFdKmVbMl19LGYubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPW5bMF0sbD1uWzFdLGM9blsyXSxoPW5bM10scD1uWzRdLGQ9bls1XTtyZXR1cm4gZVswXT1yKmYraSpjLGVbMV09cipsK2kqaCxlWzJdPXMqZitvKmMsZVszXT1zKmwrbypoLGVbNF09Zip1K2MqYStwLGVbNV09bCp1K2gqYStkLGV9LGYubXVsPWYubXVsdGlwbHksZi5yb3RhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPU1hdGguc2luKG4pLGw9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09cipsK2kqZixlWzFdPS1yKmYraSpsLGVbMl09cypsK28qZixlWzNdPS1zKmYrbCpvLGVbNF09bCp1K2YqYSxlWzVdPWwqYS1mKnUsZX0sZi5zY2FsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9blswXSxpPW5bMV07cmV0dXJuIGVbMF09dFswXSpyLGVbMV09dFsxXSppLGVbMl09dFsyXSpyLGVbM109dFszXSppLGVbNF09dFs0XSpyLGVbNV09dFs1XSppLGV9LGYudHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGVbNF09dFs0XStuWzBdLGVbNV09dFs1XStuWzFdLGV9LGYuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwibWF0MmQoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIiwgXCIrZVs0XStcIiwgXCIrZVs1XStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLm1hdDJkPWYpO3ZhciBsPXt9O2wuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oOSk7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTEsZVs1XT0wLGVbNl09MCxlWzddPTAsZVs4XT0xLGV9LGwuZnJvbU1hdDQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzRdLGVbNF09dFs1XSxlWzVdPXRbNl0sZVs2XT10WzhdLGVbN109dFs5XSxlWzhdPXRbMTBdLGV9LGwuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oOSk7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHRbM109ZVszXSx0WzRdPWVbNF0sdFs1XT1lWzVdLHRbNl09ZVs2XSx0WzddPWVbN10sdFs4XT1lWzhdLHR9LGwuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZVs0XT10WzRdLGVbNV09dFs1XSxlWzZdPXRbNl0sZVs3XT10WzddLGVbOF09dFs4XSxlfSxsLmlkZW50aXR5PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0xLGVbNV09MCxlWzZdPTAsZVs3XT0wLGVbOF09MSxlfSxsLnRyYW5zcG9zZT1mdW5jdGlvbihlLHQpe2lmKGU9PT10KXt2YXIgbj10WzFdLHI9dFsyXSxpPXRbNV07ZVsxXT10WzNdLGVbMl09dFs2XSxlWzNdPW4sZVs1XT10WzddLGVbNl09cixlWzddPWl9ZWxzZSBlWzBdPXRbMF0sZVsxXT10WzNdLGVbMl09dFs2XSxlWzNdPXRbMV0sZVs0XT10WzRdLGVbNV09dFs3XSxlWzZdPXRbMl0sZVs3XT10WzVdLGVbOF09dFs4XTtyZXR1cm4gZX0sbC5pbnZlcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT10WzZdLGY9dFs3XSxsPXRbOF0sYz1sKm8tdSpmLGg9LWwqcyt1KmEscD1mKnMtbyphLGQ9bipjK3IqaCtpKnA7cmV0dXJuIGQ/KGQ9MS9kLGVbMF09YypkLGVbMV09KC1sKnIraSpmKSpkLGVbMl09KHUqci1pKm8pKmQsZVszXT1oKmQsZVs0XT0obCpuLWkqYSkqZCxlWzVdPSgtdSpuK2kqcykqZCxlWzZdPXAqZCxlWzddPSgtZipuK3IqYSkqZCxlWzhdPShvKm4tcipzKSpkLGUpOm51bGx9LGwuYWRqb2ludD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPXRbNl0sZj10WzddLGw9dFs4XTtyZXR1cm4gZVswXT1vKmwtdSpmLGVbMV09aSpmLXIqbCxlWzJdPXIqdS1pKm8sZVszXT11KmEtcypsLGVbNF09bipsLWkqYSxlWzVdPWkqcy1uKnUsZVs2XT1zKmYtbyphLGVbN109ciphLW4qZixlWzhdPW4qby1yKnMsZX0sbC5kZXRlcm1pbmFudD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0saT1lWzNdLHM9ZVs0XSxvPWVbNV0sdT1lWzZdLGE9ZVs3XSxmPWVbOF07cmV0dXJuIHQqKGYqcy1vKmEpK24qKC1mKmkrbyp1KStyKihhKmktcyp1KX0sbC5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9dFs2XSxsPXRbN10sYz10WzhdLGg9blswXSxwPW5bMV0sZD1uWzJdLHY9blszXSxtPW5bNF0sZz1uWzVdLHk9bls2XSxiPW5bN10sdz1uWzhdO3JldHVybiBlWzBdPWgqcitwKm8rZCpmLGVbMV09aCppK3AqdStkKmwsZVsyXT1oKnMrcCphK2QqYyxlWzNdPXYqcittKm8rZypmLGVbNF09dippK20qdStnKmwsZVs1XT12KnMrbSphK2cqYyxlWzZdPXkqcitiKm8rdypmLGVbN109eSppK2IqdSt3KmwsZVs4XT15KnMrYiphK3cqYyxlfSxsLm11bD1sLm11bHRpcGx5LGwudHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj10WzZdLGw9dFs3XSxjPXRbOF0saD1uWzBdLHA9blsxXTtyZXR1cm4gZVswXT1yLGVbMV09aSxlWzJdPXMsZVszXT1vLGVbNF09dSxlWzVdPWEsZVs2XT1oKnIrcCpvK2YsZVs3XT1oKmkrcCp1K2wsZVs4XT1oKnMrcCphK2MsZX0sbC5yb3RhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPXRbNl0sbD10WzddLGM9dFs4XSxoPU1hdGguc2luKG4pLHA9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09cCpyK2gqbyxlWzFdPXAqaStoKnUsZVsyXT1wKnMraCphLGVbM109cCpvLWgqcixlWzRdPXAqdS1oKmksZVs1XT1wKmEtaCpzLGVbNl09ZixlWzddPWwsZVs4XT1jLGV9LGwuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5bMF0saT1uWzFdO3JldHVybiBlWzBdPXIqdFswXSxlWzFdPXIqdFsxXSxlWzJdPXIqdFsyXSxlWzNdPWkqdFszXSxlWzRdPWkqdFs0XSxlWzVdPWkqdFs1XSxlWzZdPXRbNl0sZVs3XT10WzddLGVbOF09dFs4XSxlfSxsLmZyb21NYXQyZD1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09MCxlWzNdPXRbMl0sZVs0XT10WzNdLGVbNV09MCxlWzZdPXRbNF0sZVs3XT10WzVdLGVbOF09MSxlfSxsLmZyb21RdWF0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPW4rbix1PXIrcixhPWkraSxmPW4qbyxsPW4qdSxjPW4qYSxoPXIqdSxwPXIqYSxkPWkqYSx2PXMqbyxtPXMqdSxnPXMqYTtyZXR1cm4gZVswXT0xLShoK2QpLGVbM109bCtnLGVbNl09Yy1tLGVbMV09bC1nLGVbNF09MS0oZitkKSxlWzddPXArdixlWzJdPWMrbSxlWzVdPXAtdixlWzhdPTEtKGYraCksZX0sbC5ub3JtYWxGcm9tTWF0ND1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPXRbNl0sZj10WzddLGw9dFs4XSxjPXRbOV0saD10WzEwXSxwPXRbMTFdLGQ9dFsxMl0sdj10WzEzXSxtPXRbMTRdLGc9dFsxNV0seT1uKnUtcipvLGI9biphLWkqbyx3PW4qZi1zKm8sRT1yKmEtaSp1LFM9cipmLXMqdSx4PWkqZi1zKmEsVD1sKnYtYypkLE49bCptLWgqZCxDPWwqZy1wKmQsaz1jKm0taCp2LEw9YypnLXAqdixBPWgqZy1wKm0sTz15KkEtYipMK3cqaytFKkMtUypOK3gqVDtyZXR1cm4gTz8oTz0xL08sZVswXT0odSpBLWEqTCtmKmspKk8sZVsxXT0oYSpDLW8qQS1mKk4pKk8sZVsyXT0obypMLXUqQytmKlQpKk8sZVszXT0oaSpMLXIqQS1zKmspKk8sZVs0XT0obipBLWkqQytzKk4pKk8sZVs1XT0ocipDLW4qTC1zKlQpKk8sZVs2XT0odip4LW0qUytnKkUpKk8sZVs3XT0obSp3LWQqeC1nKmIpKk8sZVs4XT0oZCpTLXYqdytnKnkpKk8sZSk6bnVsbH0sbC5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYXQzKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIsIFwiK2VbNF0rXCIsIFwiK2VbNV0rXCIsIFwiK2VbNl0rXCIsIFwiK2VbN10rXCIsIFwiK2VbOF0rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5tYXQzPWwpO3ZhciBjPXt9O2MuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oMTYpO3JldHVybiBlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09MSxlWzZdPTAsZVs3XT0wLGVbOF09MCxlWzldPTAsZVsxMF09MSxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsZX0sYy5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbigxNik7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHRbM109ZVszXSx0WzRdPWVbNF0sdFs1XT1lWzVdLHRbNl09ZVs2XSx0WzddPWVbN10sdFs4XT1lWzhdLHRbOV09ZVs5XSx0WzEwXT1lWzEwXSx0WzExXT1lWzExXSx0WzEyXT1lWzEyXSx0WzEzXT1lWzEzXSx0WzE0XT1lWzE0XSx0WzE1XT1lWzE1XSx0fSxjLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGVbNF09dFs0XSxlWzVdPXRbNV0sZVs2XT10WzZdLGVbN109dFs3XSxlWzhdPXRbOF0sZVs5XT10WzldLGVbMTBdPXRbMTBdLGVbMTFdPXRbMTFdLGVbMTJdPXRbMTJdLGVbMTNdPXRbMTNdLGVbMTRdPXRbMTRdLGVbMTVdPXRbMTVdLGV9LGMuaWRlbnRpdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT0xLGVbNl09MCxlWzddPTAsZVs4XT0wLGVbOV09MCxlWzEwXT0xLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSxlfSxjLnRyYW5zcG9zZT1mdW5jdGlvbihlLHQpe2lmKGU9PT10KXt2YXIgbj10WzFdLHI9dFsyXSxpPXRbM10scz10WzZdLG89dFs3XSx1PXRbMTFdO2VbMV09dFs0XSxlWzJdPXRbOF0sZVszXT10WzEyXSxlWzRdPW4sZVs2XT10WzldLGVbN109dFsxM10sZVs4XT1yLGVbOV09cyxlWzExXT10WzE0XSxlWzEyXT1pLGVbMTNdPW8sZVsxNF09dX1lbHNlIGVbMF09dFswXSxlWzFdPXRbNF0sZVsyXT10WzhdLGVbM109dFsxMl0sZVs0XT10WzFdLGVbNV09dFs1XSxlWzZdPXRbOV0sZVs3XT10WzEzXSxlWzhdPXRbMl0sZVs5XT10WzZdLGVbMTBdPXRbMTBdLGVbMTFdPXRbMTRdLGVbMTJdPXRbM10sZVsxM109dFs3XSxlWzE0XT10WzExXSxlWzE1XT10WzE1XTtyZXR1cm4gZX0sYy5pbnZlcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89dFs0XSx1PXRbNV0sYT10WzZdLGY9dFs3XSxsPXRbOF0sYz10WzldLGg9dFsxMF0scD10WzExXSxkPXRbMTJdLHY9dFsxM10sbT10WzE0XSxnPXRbMTVdLHk9bip1LXIqbyxiPW4qYS1pKm8sdz1uKmYtcypvLEU9ciphLWkqdSxTPXIqZi1zKnUseD1pKmYtcyphLFQ9bCp2LWMqZCxOPWwqbS1oKmQsQz1sKmctcCpkLGs9YyptLWgqdixMPWMqZy1wKnYsQT1oKmctcCptLE89eSpBLWIqTCt3KmsrRSpDLVMqTit4KlQ7cmV0dXJuIE8/KE89MS9PLGVbMF09KHUqQS1hKkwrZiprKSpPLGVbMV09KGkqTC1yKkEtcyprKSpPLGVbMl09KHYqeC1tKlMrZypFKSpPLGVbM109KGgqUy1jKngtcCpFKSpPLGVbNF09KGEqQy1vKkEtZipOKSpPLGVbNV09KG4qQS1pKkMrcypOKSpPLGVbNl09KG0qdy1kKngtZypiKSpPLGVbN109KGwqeC1oKncrcCpiKSpPLGVbOF09KG8qTC11KkMrZipUKSpPLGVbOV09KHIqQy1uKkwtcypUKSpPLGVbMTBdPShkKlMtdip3K2cqeSkqTyxlWzExXT0oYyp3LWwqUy1wKnkpKk8sZVsxMl09KHUqTi1vKmstYSpUKSpPLGVbMTNdPShuKmstcipOK2kqVCkqTyxlWzE0XT0odipiLWQqRS1tKnkpKk8sZVsxNV09KGwqRS1jKmIraCp5KSpPLGUpOm51bGx9LGMuYWRqb2ludD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPXRbNl0sZj10WzddLGw9dFs4XSxjPXRbOV0saD10WzEwXSxwPXRbMTFdLGQ9dFsxMl0sdj10WzEzXSxtPXRbMTRdLGc9dFsxNV07cmV0dXJuIGVbMF09dSooaCpnLXAqbSktYyooYSpnLWYqbSkrdiooYSpwLWYqaCksZVsxXT0tKHIqKGgqZy1wKm0pLWMqKGkqZy1zKm0pK3YqKGkqcC1zKmgpKSxlWzJdPXIqKGEqZy1mKm0pLXUqKGkqZy1zKm0pK3YqKGkqZi1zKmEpLGVbM109LShyKihhKnAtZipoKS11KihpKnAtcypoKStjKihpKmYtcyphKSksZVs0XT0tKG8qKGgqZy1wKm0pLWwqKGEqZy1mKm0pK2QqKGEqcC1mKmgpKSxlWzVdPW4qKGgqZy1wKm0pLWwqKGkqZy1zKm0pK2QqKGkqcC1zKmgpLGVbNl09LShuKihhKmctZiptKS1vKihpKmctcyptKStkKihpKmYtcyphKSksZVs3XT1uKihhKnAtZipoKS1vKihpKnAtcypoKStsKihpKmYtcyphKSxlWzhdPW8qKGMqZy1wKnYpLWwqKHUqZy1mKnYpK2QqKHUqcC1mKmMpLGVbOV09LShuKihjKmctcCp2KS1sKihyKmctcyp2KStkKihyKnAtcypjKSksZVsxMF09bioodSpnLWYqdiktbyoocipnLXMqdikrZCoocipmLXMqdSksZVsxMV09LShuKih1KnAtZipjKS1vKihyKnAtcypjKStsKihyKmYtcyp1KSksZVsxMl09LShvKihjKm0taCp2KS1sKih1Km0tYSp2KStkKih1KmgtYSpjKSksZVsxM109biooYyptLWgqdiktbCoociptLWkqdikrZCoocipoLWkqYyksZVsxNF09LShuKih1Km0tYSp2KS1vKihyKm0taSp2KStkKihyKmEtaSp1KSksZVsxNV09bioodSpoLWEqYyktbyoocipoLWkqYykrbCoociphLWkqdSksZX0sYy5kZXRlcm1pbmFudD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0saT1lWzNdLHM9ZVs0XSxvPWVbNV0sdT1lWzZdLGE9ZVs3XSxmPWVbOF0sbD1lWzldLGM9ZVsxMF0saD1lWzExXSxwPWVbMTJdLGQ9ZVsxM10sdj1lWzE0XSxtPWVbMTVdLGc9dCpvLW4qcyx5PXQqdS1yKnMsYj10KmEtaSpzLHc9bip1LXIqbyxFPW4qYS1pKm8sUz1yKmEtaSp1LHg9ZipkLWwqcCxUPWYqdi1jKnAsTj1mKm0taCpwLEM9bCp2LWMqZCxrPWwqbS1oKmQsTD1jKm0taCp2O3JldHVybiBnKkwteSprK2IqQyt3Kk4tRSpUK1MqeH0sYy5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9dFs2XSxsPXRbN10sYz10WzhdLGg9dFs5XSxwPXRbMTBdLGQ9dFsxMV0sdj10WzEyXSxtPXRbMTNdLGc9dFsxNF0seT10WzE1XSxiPW5bMF0sdz1uWzFdLEU9blsyXSxTPW5bM107cmV0dXJuIGVbMF09YipyK3cqdStFKmMrUyp2LGVbMV09YippK3cqYStFKmgrUyptLGVbMl09YipzK3cqZitFKnArUypnLGVbM109YipvK3cqbCtFKmQrUyp5LGI9bls0XSx3PW5bNV0sRT1uWzZdLFM9bls3XSxlWzRdPWIqcit3KnUrRSpjK1MqdixlWzVdPWIqaSt3KmErRSpoK1MqbSxlWzZdPWIqcyt3KmYrRSpwK1MqZyxlWzddPWIqbyt3KmwrRSpkK1MqeSxiPW5bOF0sdz1uWzldLEU9blsxMF0sUz1uWzExXSxlWzhdPWIqcit3KnUrRSpjK1MqdixlWzldPWIqaSt3KmErRSpoK1MqbSxlWzEwXT1iKnMrdypmK0UqcCtTKmcsZVsxMV09YipvK3cqbCtFKmQrUyp5LGI9blsxMl0sdz1uWzEzXSxFPW5bMTRdLFM9blsxNV0sZVsxMl09YipyK3cqdStFKmMrUyp2LGVbMTNdPWIqaSt3KmErRSpoK1MqbSxlWzE0XT1iKnMrdypmK0UqcCtTKmcsZVsxNV09YipvK3cqbCtFKmQrUyp5LGV9LGMubXVsPWMubXVsdGlwbHksYy50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5bMF0saT1uWzFdLHM9blsyXSxvLHUsYSxmLGwsYyxoLHAsZCx2LG0sZztyZXR1cm4gdD09PWU/KGVbMTJdPXRbMF0qcit0WzRdKmkrdFs4XSpzK3RbMTJdLGVbMTNdPXRbMV0qcit0WzVdKmkrdFs5XSpzK3RbMTNdLGVbMTRdPXRbMl0qcit0WzZdKmkrdFsxMF0qcyt0WzE0XSxlWzE1XT10WzNdKnIrdFs3XSppK3RbMTFdKnMrdFsxNV0pOihvPXRbMF0sdT10WzFdLGE9dFsyXSxmPXRbM10sbD10WzRdLGM9dFs1XSxoPXRbNl0scD10WzddLGQ9dFs4XSx2PXRbOV0sbT10WzEwXSxnPXRbMTFdLGVbMF09byxlWzFdPXUsZVsyXT1hLGVbM109ZixlWzRdPWwsZVs1XT1jLGVbNl09aCxlWzddPXAsZVs4XT1kLGVbOV09dixlWzEwXT1tLGVbMTFdPWcsZVsxMl09bypyK2wqaStkKnMrdFsxMl0sZVsxM109dSpyK2MqaSt2KnMrdFsxM10sZVsxNF09YSpyK2gqaSttKnMrdFsxNF0sZVsxNV09ZipyK3AqaStnKnMrdFsxNV0pLGV9LGMuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5bMF0saT1uWzFdLHM9blsyXTtyZXR1cm4gZVswXT10WzBdKnIsZVsxXT10WzFdKnIsZVsyXT10WzJdKnIsZVszXT10WzNdKnIsZVs0XT10WzRdKmksZVs1XT10WzVdKmksZVs2XT10WzZdKmksZVs3XT10WzddKmksZVs4XT10WzhdKnMsZVs5XT10WzldKnMsZVsxMF09dFsxMF0qcyxlWzExXT10WzExXSpzLGVbMTJdPXRbMTJdLGVbMTNdPXRbMTNdLGVbMTRdPXRbMTRdLGVbMTVdPXRbMTVdLGV9LGMucm90YXRlPWZ1bmN0aW9uKGUsbixyLGkpe3ZhciBzPWlbMF0sbz1pWzFdLHU9aVsyXSxhPU1hdGguc3FydChzKnMrbypvK3UqdSksZixsLGMsaCxwLGQsdixtLGcseSxiLHcsRSxTLHgsVCxOLEMsayxMLEEsTyxNLF87cmV0dXJuIE1hdGguYWJzKGEpPHQ/bnVsbDooYT0xL2Escyo9YSxvKj1hLHUqPWEsZj1NYXRoLnNpbihyKSxsPU1hdGguY29zKHIpLGM9MS1sLGg9blswXSxwPW5bMV0sZD1uWzJdLHY9blszXSxtPW5bNF0sZz1uWzVdLHk9bls2XSxiPW5bN10sdz1uWzhdLEU9bls5XSxTPW5bMTBdLHg9blsxMV0sVD1zKnMqYytsLE49bypzKmMrdSpmLEM9dSpzKmMtbypmLGs9cypvKmMtdSpmLEw9bypvKmMrbCxBPXUqbypjK3MqZixPPXMqdSpjK28qZixNPW8qdSpjLXMqZixfPXUqdSpjK2wsZVswXT1oKlQrbSpOK3cqQyxlWzFdPXAqVCtnKk4rRSpDLGVbMl09ZCpUK3kqTitTKkMsZVszXT12KlQrYipOK3gqQyxlWzRdPWgqayttKkwrdypBLGVbNV09cCprK2cqTCtFKkEsZVs2XT1kKmsreSpMK1MqQSxlWzddPXYqaytiKkwreCpBLGVbOF09aCpPK20qTSt3Kl8sZVs5XT1wKk8rZypNK0UqXyxlWzEwXT1kKk8reSpNK1MqXyxlWzExXT12Kk8rYipNK3gqXyxuIT09ZSYmKGVbMTJdPW5bMTJdLGVbMTNdPW5bMTNdLGVbMTRdPW5bMTRdLGVbMTVdPW5bMTVdKSxlKX0sYy5yb3RhdGVYPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1NYXRoLnNpbihuKSxpPU1hdGguY29zKG4pLHM9dFs0XSxvPXRbNV0sdT10WzZdLGE9dFs3XSxmPXRbOF0sbD10WzldLGM9dFsxMF0saD10WzExXTtyZXR1cm4gdCE9PWUmJihlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZVsxMl09dFsxMl0sZVsxM109dFsxM10sZVsxNF09dFsxNF0sZVsxNV09dFsxNV0pLGVbNF09cyppK2YqcixlWzVdPW8qaStsKnIsZVs2XT11KmkrYypyLGVbN109YSppK2gqcixlWzhdPWYqaS1zKnIsZVs5XT1sKmktbypyLGVbMTBdPWMqaS11KnIsZVsxMV09aCppLWEqcixlfSxjLnJvdGF0ZVk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPU1hdGguc2luKG4pLGk9TWF0aC5jb3Mobikscz10WzBdLG89dFsxXSx1PXRbMl0sYT10WzNdLGY9dFs4XSxsPXRbOV0sYz10WzEwXSxoPXRbMTFdO3JldHVybiB0IT09ZSYmKGVbNF09dFs0XSxlWzVdPXRbNV0sZVs2XT10WzZdLGVbN109dFs3XSxlWzEyXT10WzEyXSxlWzEzXT10WzEzXSxlWzE0XT10WzE0XSxlWzE1XT10WzE1XSksZVswXT1zKmktZipyLGVbMV09byppLWwqcixlWzJdPXUqaS1jKnIsZVszXT1hKmktaCpyLGVbOF09cypyK2YqaSxlWzldPW8qcitsKmksZVsxMF09dSpyK2MqaSxlWzExXT1hKnIraCppLGV9LGMucm90YXRlWj1mdW5jdGlvbihlLHQsbil7dmFyIHI9TWF0aC5zaW4obiksaT1NYXRoLmNvcyhuKSxzPXRbMF0sbz10WzFdLHU9dFsyXSxhPXRbM10sZj10WzRdLGw9dFs1XSxjPXRbNl0saD10WzddO3JldHVybiB0IT09ZSYmKGVbOF09dFs4XSxlWzldPXRbOV0sZVsxMF09dFsxMF0sZVsxMV09dFsxMV0sZVsxMl09dFsxMl0sZVsxM109dFsxM10sZVsxNF09dFsxNF0sZVsxNV09dFsxNV0pLGVbMF09cyppK2YqcixlWzFdPW8qaStsKnIsZVsyXT11KmkrYypyLGVbM109YSppK2gqcixlWzRdPWYqaS1zKnIsZVs1XT1sKmktbypyLGVbNl09YyppLXUqcixlWzddPWgqaS1hKnIsZX0sYy5mcm9tUm90YXRpb25UcmFuc2xhdGlvbj1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXIrcixhPWkraSxmPXMrcyxsPXIqdSxjPXIqYSxoPXIqZixwPWkqYSxkPWkqZix2PXMqZixtPW8qdSxnPW8qYSx5PW8qZjtyZXR1cm4gZVswXT0xLShwK3YpLGVbMV09Yyt5LGVbMl09aC1nLGVbM109MCxlWzRdPWMteSxlWzVdPTEtKGwrdiksZVs2XT1kK20sZVs3XT0wLGVbOF09aCtnLGVbOV09ZC1tLGVbMTBdPTEtKGwrcCksZVsxMV09MCxlWzEyXT1uWzBdLGVbMTNdPW5bMV0sZVsxNF09blsyXSxlWzE1XT0xLGV9LGMuZnJvbVF1YXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89bituLHU9cityLGE9aStpLGY9bipvLGw9bip1LGM9biphLGg9cip1LHA9ciphLGQ9aSphLHY9cypvLG09cyp1LGc9cyphO3JldHVybiBlWzBdPTEtKGgrZCksZVsxXT1sK2csZVsyXT1jLW0sZVszXT0wLGVbNF09bC1nLGVbNV09MS0oZitkKSxlWzZdPXArdixlWzddPTAsZVs4XT1jK20sZVs5XT1wLXYsZVsxMF09MS0oZitoKSxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsZX0sYy5mcnVzdHVtPWZ1bmN0aW9uKGUsdCxuLHIsaSxzLG8pe3ZhciB1PTEvKG4tdCksYT0xLyhpLXIpLGY9MS8ocy1vKTtyZXR1cm4gZVswXT1zKjIqdSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT1zKjIqYSxlWzZdPTAsZVs3XT0wLGVbOF09KG4rdCkqdSxlWzldPShpK3IpKmEsZVsxMF09KG8rcykqZixlWzExXT0tMSxlWzEyXT0wLGVbMTNdPTAsZVsxNF09bypzKjIqZixlWzE1XT0wLGV9LGMucGVyc3BlY3RpdmU9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgcz0xL01hdGgudGFuKHQvMiksbz0xLyhyLWkpO3JldHVybiBlWzBdPXMvbixlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT1zLGVbNl09MCxlWzddPTAsZVs4XT0wLGVbOV09MCxlWzEwXT0oaStyKSpvLGVbMTFdPS0xLGVbMTJdPTAsZVsxM109MCxlWzE0XT0yKmkqcipvLGVbMTVdPTAsZX0sYy5vcnRobz1mdW5jdGlvbihlLHQsbixyLGkscyxvKXt2YXIgdT0xLyh0LW4pLGE9MS8oci1pKSxmPTEvKHMtbyk7cmV0dXJuIGVbMF09LTIqdSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT0tMiphLGVbNl09MCxlWzddPTAsZVs4XT0wLGVbOV09MCxlWzEwXT0yKmYsZVsxMV09MCxlWzEyXT0odCtuKSp1LGVbMTNdPShpK3IpKmEsZVsxNF09KG8rcykqZixlWzE1XT0xLGV9LGMubG9va0F0PWZ1bmN0aW9uKGUsbixyLGkpe3ZhciBzLG8sdSxhLGYsbCxoLHAsZCx2LG09blswXSxnPW5bMV0seT1uWzJdLGI9aVswXSx3PWlbMV0sRT1pWzJdLFM9clswXSx4PXJbMV0sVD1yWzJdO3JldHVybiBNYXRoLmFicyhtLVMpPHQmJk1hdGguYWJzKGcteCk8dCYmTWF0aC5hYnMoeS1UKTx0P2MuaWRlbnRpdHkoZSk6KGg9bS1TLHA9Zy14LGQ9eS1ULHY9MS9NYXRoLnNxcnQoaCpoK3AqcCtkKmQpLGgqPXYscCo9dixkKj12LHM9dypkLUUqcCxvPUUqaC1iKmQsdT1iKnAtdypoLHY9TWF0aC5zcXJ0KHMqcytvKm8rdSp1KSx2Pyh2PTEvdixzKj12LG8qPXYsdSo9dik6KHM9MCxvPTAsdT0wKSxhPXAqdS1kKm8sZj1kKnMtaCp1LGw9aCpvLXAqcyx2PU1hdGguc3FydChhKmErZipmK2wqbCksdj8odj0xL3YsYSo9dixmKj12LGwqPXYpOihhPTAsZj0wLGw9MCksZVswXT1zLGVbMV09YSxlWzJdPWgsZVszXT0wLGVbNF09byxlWzVdPWYsZVs2XT1wLGVbN109MCxlWzhdPXUsZVs5XT1sLGVbMTBdPWQsZVsxMV09MCxlWzEyXT0tKHMqbStvKmcrdSp5KSxlWzEzXT0tKGEqbStmKmcrbCp5KSxlWzE0XT0tKGgqbStwKmcrZCp5KSxlWzE1XT0xLGUpfSxjLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cIm1hdDQoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIiwgXCIrZVs0XStcIiwgXCIrZVs1XStcIiwgXCIrZVs2XStcIiwgXCIrZVs3XStcIiwgXCIrZVs4XStcIiwgXCIrZVs5XStcIiwgXCIrZVsxMF0rXCIsIFwiK2VbMTFdK1wiLCBcIitlWzEyXStcIiwgXCIrZVsxM10rXCIsIFwiK2VbMTRdK1wiLCBcIitlWzE1XStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLm1hdDQ9Yyk7dmFyIGg9e307aC5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbig0KTtyZXR1cm4gZVswXT0wLGVbMV09MCxlWzJdPTAsZVszXT0xLGV9LGgucm90YXRpb25Ubz1mdW5jdGlvbigpe3ZhciBlPW8uY3JlYXRlKCksdD1vLmZyb21WYWx1ZXMoMSwwLDApLG49by5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24ocixpLHMpe3ZhciB1PW8uZG90KGkscyk7cmV0dXJuIHU8LTAuOTk5OTk5PyhvLmNyb3NzKGUsdCxpKSxvLmxlbmd0aChlKTwxZS02JiZvLmNyb3NzKGUsbixpKSxvLm5vcm1hbGl6ZShlLGUpLGguc2V0QXhpc0FuZ2xlKHIsZSxNYXRoLlBJKSxyKTp1Pi45OTk5OTk/KHJbMF09MCxyWzFdPTAsclsyXT0wLHJbM109MSxyKTooby5jcm9zcyhlLGkscyksclswXT1lWzBdLHJbMV09ZVsxXSxyWzJdPWVbMl0sclszXT0xK3UsaC5ub3JtYWxpemUocixyKSl9fSgpLGguc2V0QXhlcz1mdW5jdGlvbigpe3ZhciBlPWwuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKHQsbixyLGkpe3JldHVybiBlWzBdPXJbMF0sZVszXT1yWzFdLGVbNl09clsyXSxlWzFdPWlbMF0sZVs0XT1pWzFdLGVbN109aVsyXSxlWzJdPW5bMF0sZVs1XT1uWzFdLGVbOF09blsyXSxoLm5vcm1hbGl6ZSh0LGguZnJvbU1hdDModCxlKSl9fSgpLGguY2xvbmU9dS5jbG9uZSxoLmZyb21WYWx1ZXM9dS5mcm9tVmFsdWVzLGguY29weT11LmNvcHksaC5zZXQ9dS5zZXQsaC5pZGVudGl0eT1mdW5jdGlvbihlKXtyZXR1cm4gZVswXT0wLGVbMV09MCxlWzJdPTAsZVszXT0xLGV9LGguc2V0QXhpc0FuZ2xlPWZ1bmN0aW9uKGUsdCxuKXtuKj0uNTt2YXIgcj1NYXRoLnNpbihuKTtyZXR1cm4gZVswXT1yKnRbMF0sZVsxXT1yKnRbMV0sZVsyXT1yKnRbMl0sZVszXT1NYXRoLmNvcyhuKSxlfSxoLmFkZD11LmFkZCxoLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9blswXSxhPW5bMV0sZj1uWzJdLGw9blszXTtyZXR1cm4gZVswXT1yKmwrbyp1K2kqZi1zKmEsZVsxXT1pKmwrbyphK3MqdS1yKmYsZVsyXT1zKmwrbypmK3IqYS1pKnUsZVszXT1vKmwtcip1LWkqYS1zKmYsZX0saC5tdWw9aC5tdWx0aXBseSxoLnNjYWxlPXUuc2NhbGUsaC5yb3RhdGVYPWZ1bmN0aW9uKGUsdCxuKXtuKj0uNTt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1yKmErbyp1LGVbMV09aSphK3MqdSxlWzJdPXMqYS1pKnUsZVszXT1vKmEtcip1LGV9LGgucm90YXRlWT1mdW5jdGlvbihlLHQsbil7bio9LjU7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09ciphLXMqdSxlWzFdPWkqYStvKnUsZVsyXT1zKmErcip1LGVbM109byphLWkqdSxlfSxoLnJvdGF0ZVo9ZnVuY3Rpb24oZSx0LG4pe24qPS41O3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXIqYStpKnUsZVsxXT1pKmEtcip1LGVbMl09cyphK28qdSxlWzNdPW8qYS1zKnUsZX0saC5jYWxjdWxhdGVXPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdO3JldHVybiBlWzBdPW4sZVsxXT1yLGVbMl09aSxlWzNdPS1NYXRoLnNxcnQoTWF0aC5hYnMoMS1uKm4tcipyLWkqaSkpLGV9LGguZG90PXUuZG90LGgubGVycD11LmxlcnAsaC5zbGVycD1mdW5jdGlvbihlLHQsbixyKXt2YXIgaT10WzBdLHM9dFsxXSxvPXRbMl0sdT10WzNdLGE9blswXSxmPW5bMV0sbD1uWzJdLGM9blszXSxoLHAsZCx2LG07cmV0dXJuIHA9aSphK3MqZitvKmwrdSpjLHA8MCYmKHA9LXAsYT0tYSxmPS1mLGw9LWwsYz0tYyksMS1wPjFlLTY/KGg9TWF0aC5hY29zKHApLGQ9TWF0aC5zaW4oaCksdj1NYXRoLnNpbigoMS1yKSpoKS9kLG09TWF0aC5zaW4ocipoKS9kKToodj0xLXIsbT1yKSxlWzBdPXYqaSttKmEsZVsxXT12KnMrbSpmLGVbMl09dipvK20qbCxlWzNdPXYqdSttKmMsZX0saC5pbnZlcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89bipuK3IqcitpKmkrcypzLHU9bz8xL286MDtyZXR1cm4gZVswXT0tbip1LGVbMV09LXIqdSxlWzJdPS1pKnUsZVszXT1zKnUsZX0saC5jb25qdWdhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT0tdFswXSxlWzFdPS10WzFdLGVbMl09LXRbMl0sZVszXT10WzNdLGV9LGgubGVuZ3RoPXUubGVuZ3RoLGgubGVuPWgubGVuZ3RoLGguc3F1YXJlZExlbmd0aD11LnNxdWFyZWRMZW5ndGgsaC5zcXJMZW49aC5zcXVhcmVkTGVuZ3RoLGgubm9ybWFsaXplPXUubm9ybWFsaXplLGguZnJvbU1hdDM9ZnVuY3Rpb24oKXt2YXIgZT10eXBlb2YgSW50OEFycmF5IT1cInVuZGVmaW5lZFwiP25ldyBJbnQ4QXJyYXkoWzEsMiwwXSk6WzEsMiwwXTtyZXR1cm4gZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdK25bNF0rbls4XSxpO2lmKHI+MClpPU1hdGguc3FydChyKzEpLHRbM109LjUqaSxpPS41L2ksdFswXT0obls3XS1uWzVdKSppLHRbMV09KG5bMl0tbls2XSkqaSx0WzJdPShuWzNdLW5bMV0pKmk7ZWxzZXt2YXIgcz0wO25bNF0+blswXSYmKHM9MSksbls4XT5uW3MqMytzXSYmKHM9Mik7dmFyIG89ZVtzXSx1PWVbb107aT1NYXRoLnNxcnQobltzKjMrc10tbltvKjMrb10tblt1KjMrdV0rMSksdFtzXT0uNSppLGk9LjUvaSx0WzNdPShuW3UqMytvXS1uW28qMyt1XSkqaSx0W29dPShuW28qMytzXStuW3MqMytvXSkqaSx0W3VdPShuW3UqMytzXStuW3MqMyt1XSkqaX1yZXR1cm4gdH19KCksaC5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJxdWF0KFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIsIFwiK2VbMl0rXCIsIFwiK2VbM10rXCIpXCJ9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5xdWF0PWgpfSh0LmV4cG9ydHMpfSkodGhpcyk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgbmV3IChyZXF1aXJlKCcuL3NvdXJjZS93b3JrZXIuanMnKSkoc2VsZik7XHJcbn0gZWxzZSB7XHJcbiAgICAvLyBqc2hpbnQgLVcwNzlcclxuICAgIHZhciBtYXBib3hnbCA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93Lm1hcGJveGdsID0ge307XHJcblxyXG4gICAgbWFwYm94Z2wuTWFwID0gcmVxdWlyZSgnLi91aS9tYXAuanMnKTtcclxuICAgIG1hcGJveGdsLk5hdmlnYXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvbmF2aWdhdGlvbi5qcycpO1xyXG4gICAgbWFwYm94Z2wuQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMnKTtcclxuXHJcbiAgICBtYXBib3hnbC5Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9zb3VyY2UnKTtcclxuICAgIG1hcGJveGdsLkdlb0pTT05Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9nZW9qc29uc291cmNlJyk7XHJcbiAgICBtYXBib3hnbC5WaWRlb1NvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL3ZpZGVvc291cmNlJyk7XHJcblxyXG4gICAgbWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlLmpzJyk7XHJcblxyXG4gICAgbWFwYm94Z2wuTGF0TG5nID0gcmVxdWlyZSgnLi9nZW8vbGF0bG5nLmpzJyk7XHJcbiAgICBtYXBib3hnbC5MYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuL2dlby9sYXRsbmdib3VuZHMuanMnKTtcclxuICAgIG1hcGJveGdsLlBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcclxuXHJcbiAgICBtYXBib3hnbC5FdmVudGVkID0gcmVxdWlyZSgnLi91dGlsL2V2ZW50ZWQuanMnKTtcclxuICAgIG1hcGJveGdsLnV0aWwgPSByZXF1aXJlKCcuL3V0aWwvdXRpbC5qcycpO1xyXG5cclxuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi91dGlsL2Jyb3dzZXIuanMnKTtcclxuICAgIG1hcGJveGdsLnV0aWwuc3VwcG9ydGVkID0gYnJvd3Nlci5zdXBwb3J0ZWQ7XHJcblxyXG4gICAgdmFyIGFqYXggPSByZXF1aXJlKCcuL3V0aWwvYWpheC5qcycpO1xyXG4gICAgbWFwYm94Z2wudXRpbC5nZXRKU09OID0gYWpheC5nZXRKU09OO1xyXG4gICAgbWFwYm94Z2wudXRpbC5nZXRBcnJheUJ1ZmZlciA9IGFqYXguZ2V0QXJyYXlCdWZmZXI7XHJcblxyXG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vdXRpbC9jb25maWcuanMnKTtcclxuICAgIG1hcGJveGdsLmNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwYm94Z2wsICdhY2Nlc3NUb2tlbicsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29uZmlnLkFDQ0VTU19UT0tFTjsgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRva2VuKSB7IGNvbmZpZy5BQ0NFU1NfVE9LRU4gPSB0b2tlbjsgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1hdDMgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkcmF3QmFja2dyb3VuZDtcclxuXHJcbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xyXG4gICAgdmFyIGNvbG9yID0gbGF5ZXJTdHlsZVsnYmFja2dyb3VuZC1jb2xvciddO1xyXG4gICAgdmFyIGltYWdlID0gbGF5ZXJTdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddO1xyXG4gICAgdmFyIG9wYWNpdHkgPSBsYXllclN0eWxlWydiYWNrZ3JvdW5kLW9wYWNpdHknXTtcclxuICAgIHZhciBzaGFkZXI7XHJcblxyXG4gICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcclxuICAgICAgICB2YXIgaW1hZ2VQb3MgPSBpbWFnZVNwcml0ZS5nZXRQb3NpdGlvbihpbWFnZSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKCFpbWFnZVBvcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnBhdHRlcm5TaGFkZXI7XHJcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcclxuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bCwgaW1hZ2VQb3MudGwpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9iciwgaW1hZ2VQb3MuYnIpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIHBhaW50ZXIudHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHksIG9wYWNpdHkpO1xyXG5cclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gcGFpbnRlci50cmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIHNpemUgPSBpbWFnZVBvcy5zaXplO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKHRyYW5zZm9ybS5jZW50ZXIpO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IDEgLyBNYXRoLnBvdygyLCB0cmFuc2Zvcm0uem9vbUZyYWN0aW9uKTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gbWF0My5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgbWF0My5zY2FsZShtYXRyaXgsIG1hdHJpeCwgWzEgLyBzaXplWzBdLCAxIC8gc2l6ZVsxXSwgMV0pO1xyXG4gICAgICAgIG1hdDMudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbXHJcbiAgICAgICAgICAgIChjZW50ZXIuY29sdW1uICogdHJhbnNmb3JtLnRpbGVTaXplKSAlIHNpemVbMF0sXHJcbiAgICAgICAgICAgIChjZW50ZXIucm93ICAgICogdHJhbnNmb3JtLnRpbGVTaXplKSAlIHNpemVbMV0sXHJcbiAgICAgICAgICAgIDBcclxuICAgICAgICBdKTtcclxuICAgICAgICBtYXQzLnJvdGF0ZShtYXRyaXgsIG1hdHJpeCwgLXRyYW5zZm9ybS5hbmdsZSk7XHJcbiAgICAgICAgbWF0My5zY2FsZShtYXRyaXgsIG1hdHJpeCwgW1xyXG4gICAgICAgICAgICBzY2FsZSAqIHRyYW5zZm9ybS53aWR0aCAgLyAyLFxyXG4gICAgICAgICAgIC1zY2FsZSAqIHRyYW5zZm9ybS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAxXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVfcGF0dGVybm1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XHJcblxyXG4gICAgICAgIGltYWdlU3ByaXRlLmJpbmQoZ2wsIHRydWUpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRHJhdyBmaWxsaW5nIHJlY3RhbmdsZS5cclxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmZpbGxTaGFkZXI7XHJcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFyYW1zLnBhZGRlZCB8fCBwb3NNYXRyaXgpO1xyXG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5iYWNrZ3JvdW5kQnVmZmVyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XHJcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbUNvdW50KTtcclxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG5cclxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDApO1xyXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB0ZXh0VmVydGljZXMgPSByZXF1aXJlKCcuLi9saWIvZGVidWd0ZXh0LmpzJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdEZWJ1ZztcclxuXHJcbmZ1bmN0aW9uIGRyYXdEZWJ1ZyhnbCwgcGFpbnRlciwgdGlsZSwgcGFyYW1zKSB7XHJcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cclxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRlYnVnU2hhZGVyLCBwYWludGVyLnRpbGUucG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xyXG5cclxuICAgIC8vIGRyYXcgYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5kZWJ1Z0J1ZmZlcik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZGVidWdTaGFkZXIuYV9wb3MsIHBhaW50ZXIuZGVidWdCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XHJcbiAgICBnbC51bmlmb3JtNGYocGFpbnRlci5kZWJ1Z1NoYWRlci51X2NvbG9yLCAxLCAwLCAwLCAxKTtcclxuICAgIGdsLmxpbmVXaWR0aCg0KTtcclxuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORV9TVFJJUCwgMCwgcGFpbnRlci5kZWJ1Z0J1ZmZlci5pdGVtQ291bnQpO1xyXG5cclxuICAgIC8vIGRyYXcgdGlsZSBjb29yZGluYXRlXHJcbiAgICB2YXIgY29vcmQgPSBwYXJhbXMueiArICcvJyArIHBhcmFtcy54ICsgJy8nICsgcGFyYW1zLnk7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gdGV4dFZlcnRpY2VzKGNvb3JkLCA1MCwgMjAwLCA1KTtcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KHZlcnRpY2VzKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRlYnVnU2hhZGVyLmFfcG9zLCBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcclxuICAgIGdsLmxpbmVXaWR0aCg4ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcclxuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgdmVydGljZXMubGVuZ3RoIC8gcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUpO1xyXG4gICAgZ2wubGluZVdpZHRoKDIgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgZ2wudW5pZm9ybTRmKHBhaW50ZXIuZGVidWdTaGFkZXIudV9jb2xvciwgMCwgMCwgMCwgMSk7XHJcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCAwLCB2ZXJ0aWNlcy5sZW5ndGggLyBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSk7XHJcblxyXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXHJcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xyXG52YXIgbWF0MyA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdGaWxsO1xyXG5cclxuZnVuY3Rpb24gZHJhd0ZpbGwoZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlKSB7XHJcblxyXG4gICAgdmFyIHRyYW5zbGF0ZWRQb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHBhcmFtcy56LCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZSddLCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gbGF5ZXJTdHlsZVsnZmlsbC1jb2xvciddO1xyXG5cclxuICAgIHZhciB2ZXJ0ZXgsIGVsZW1lbnRzLCBncm91cCwgY291bnQ7XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgc3RlbmNpbCBtYXNrLlxyXG5cclxuICAgIC8vIFdlJ3JlIG9ubHkgZHJhd2luZyB0byB0aGUgZmlyc3Qgc2V2ZW4gYml0cyAoPT0gc3VwcG9ydCBhIG1heGltdW0gb2ZcclxuICAgIC8vIDEyNyBvdmVybGFwcGluZyBwb2x5Z29ucyBpbiBvbmUgcGxhY2UgYmVmb3JlIHdlIGdldCByZW5kZXJpbmcgZXJyb3JzKS5cclxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4M0YpO1xyXG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAvLyBEcmF3IGZyb250IGZhY2luZyB0cmlhbmdsZXMuIFdoZXJldmVyIHRoZSAweDgwIGJpdCBpcyAxLCB3ZSBhcmVcclxuICAgIC8vIGluY3JlYXNpbmcgdGhlIGxvd2VyIDcgYml0cyBieSBvbmUgaWYgdGhlIHRyaWFuZ2xlIGlzIGEgZnJvbnQtZmFjaW5nXHJcbiAgICAvLyB0cmlhbmdsZS4gVGhpcyBtZWFucyB0aGF0IGFsbCB2aXNpYmxlIHBvbHlnb25zIHNob3VsZCBiZSBpbiBDQ1dcclxuICAgIC8vIG9yaWVudGF0aW9uLCB3aGlsZSBhbGwgaG9sZXMgKHNlZSBiZWxvdykgYXJlIGluIENXIG9yaWVudGF0aW9uLlxyXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuTk9URVFVQUwsIDB4ODAsIDB4ODApO1xyXG5cclxuICAgIC8vIFdoZW4gd2UgZG8gYSBub256ZXJvIGZpbGwsIHdlIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYSBwaXhlbCBpc1xyXG4gICAgLy8gY292ZXJlZCBieSBhIGNvdW50ZXJjbG9ja3dpc2UgcG9seWdvbiwgYW5kIHN1YnRyYWN0IHRoZSBudW1iZXIgb2ZcclxuICAgIC8vIHRpbWVzIGl0IGlzIFwidW5jb3ZlcmVkXCIgYnkgYSBjbG9ja3dpc2UgcG9seWdvbi5cclxuICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkZST05ULCBnbC5JTkNSX1dSQVAsIGdsLktFRVAsIGdsLktFRVApO1xyXG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuQkFDSywgZ2wuREVDUl9XUkFQLCBnbC5LRUVQLCBnbC5LRUVQKTtcclxuXHJcbiAgICAvLyBXaGVuIGRyYXdpbmcgYSBzaGFwZSwgd2UgZmlyc3QgZHJhdyBhbGwgc2hhcGVzIHRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxyXG4gICAgLy8gYW5kIGluY3JlbWVudGluZyBhbGwgYXJlYXMgd2hlcmUgcG9seWdvbnMgYXJlXHJcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCB0cmlhbmdsZSBmYW4gaW50byB0aGUgc3RlbmNpbCBidWZmZXIuXHJcbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5maWxsU2hhZGVyLCB0cmFuc2xhdGVkUG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xyXG5cclxuICAgIC8vIERyYXcgYWxsIGJ1ZmZlcnNcclxuICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmZpbGxWZXJ0ZXg7XHJcbiAgICB2ZXJ0ZXguYmluZChnbCk7XHJcbiAgICBlbGVtZW50cyA9IGJ1Y2tldC5idWZmZXJzLmZpbGxFbGVtZW50O1xyXG4gICAgZWxlbWVudHMuYmluZChnbCk7XHJcblxyXG4gICAgdmFyIG9mZnNldCwgZWxlbWVudE9mZnNldDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZ3JvdXAgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XHJcbiAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZmlsbFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA0LCBvZmZzZXQgKyAwKTtcclxuXHJcbiAgICAgICAgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcclxuICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIHN0ZW5jaWwgbWFzayBpbiB0aGUgc3RlbmNpbCBidWZmZXIsIHdlIGNhbiBzdGFydFxyXG4gICAgLy8gd3JpdGluZyB0byB0aGUgY29sb3IgYnVmZmVyLlxyXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xyXG5cclxuICAgIC8vIEZyb20gbm93IG9uLCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgYW55bW9yZS5cclxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcclxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MCk7XHJcblxyXG4gICAgdmFyIHN0cm9rZUNvbG9yID0gbGF5ZXJTdHlsZVsnZmlsbC1vdXRsaW5lLWNvbG9yJ107XHJcblxyXG4gICAgLy8gQmVjYXVzZSB3ZSdyZSBkcmF3aW5nIHRvcC10by1ib3R0b20sIGFuZCB3ZSB1cGRhdGUgdGhlIHN0ZW5jaWwgbWFza1xyXG4gICAgLy8gYmVsb3csIHdlIGhhdmUgdG8gZHJhdyB0aGUgb3V0bGluZSBmaXJzdCAoISlcclxuICAgIGlmIChsYXllclN0eWxlWydmaWxsLWFudGlhbGlhcyddID09PSB0cnVlICYmIHBhcmFtcy5hbnRpYWxpYXNpbmcgJiYgIShsYXllclN0eWxlWydmaWxsLWltYWdlJ10gJiYgIXN0cm9rZUNvbG9yKSkge1xyXG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLm91dGxpbmVTaGFkZXIsIHRyYW5zbGF0ZWRQb3NNYXRyaXgsIHBhaW50ZXIudGlsZS5leE1hdHJpeCk7XHJcbiAgICAgICAgZ2wubGluZVdpZHRoKDIgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xyXG5cclxuICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZGVmaW5lZCBhIGRpZmZlcmVudCBjb2xvciBmb3IgdGhlIGZpbGwgb3V0bGluZSwgd2UgYXJlXHJcbiAgICAgICAgICAgIC8vIGdvaW5nIHRvIGlnbm9yZSB0aGUgYml0cyBpbiAweDNGIGFuZCBqdXN0IGNhcmUgYWJvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBtYXNrLlxyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBvbmx5IHdhbnQgdG8gZHJhdyB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcclxuICAgICAgICAgICAgLy8gKm91dHNpZGUqIHRoZSBjdXJyZW50IHNoYXBlLiBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBmaWxsXHJcbiAgICAgICAgICAgIC8vIG9yIHN0cm9rZSBjb2xvciBpcyB0cmFuc2x1Y2VudC4gSWYgd2Ugd291bGRuJ3QgY2xpcCB0byBvdXRzaWRlXHJcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXHJcbiAgICAgICAgICAgIC8vIHRoZSAobm9uLWFudGlhbGlhc2VkKSBmaWxsLlxyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHhCRik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC51bmlmb3JtMmYocGFpbnRlci5vdXRsaW5lU2hhZGVyLnVfd29ybGQsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwYWludGVyLm91dGxpbmVTaGFkZXIudV9jb2xvciwgc3Ryb2tlQ29sb3IgPyBzdHJva2VDb2xvciA6IGNvbG9yKTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xyXG4gICAgICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmZpbGxWZXJ0ZXg7XHJcbiAgICAgICAgZWxlbWVudHMgPSBidWNrZXQuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcclxuICAgICAgICBlbGVtZW50cy5iaW5kKGdsKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHNba107XHJcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5vdXRsaW5lU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDQsIG9mZnNldCArIDApO1xyXG5cclxuICAgICAgICAgICAgY291bnQgPSBncm91cC5zZWNvbmRFbGVtZW50TGVuZ3RoICogMjtcclxuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XHJcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5MSU5FUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGltYWdlID0gbGF5ZXJTdHlsZVsnZmlsbC1pbWFnZSddO1xyXG4gICAgdmFyIG9wYWNpdHkgPSBsYXllclN0eWxlWydmaWxsLW9wYWNpdHknXSB8fCAxO1xyXG4gICAgdmFyIHNoYWRlcjtcclxuXHJcbiAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAvLyBEcmF3IHRleHR1cmUgZmlsbFxyXG4gICAgICAgIHZhciBpbWFnZVBvcyA9IGltYWdlU3ByaXRlLmdldFBvc2l0aW9uKGltYWdlLCB0cnVlKTtcclxuICAgICAgICBpZiAoIWltYWdlUG9zKSByZXR1cm47XHJcblxyXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIucGF0dGVyblNoYWRlcjtcclxuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsLCBpbWFnZVBvcy50bCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyLCBpbWFnZVBvcy5icik7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21peCwgcGFpbnRlci50cmFuc2Zvcm0uem9vbUZyYWN0aW9uKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XHJcblxyXG4gICAgICAgIHZhciBmYWN0b3IgPSA4IC8gTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gLSBwYXJhbXMueik7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4LCBtYXRyaXgsIFtcclxuICAgICAgICAgICAgMSAvIChpbWFnZVBvcy5zaXplWzBdICogZmFjdG9yKSxcclxuICAgICAgICAgICAgMSAvIChpbWFnZVBvcy5zaXplWzFdICogZmFjdG9yKSxcclxuICAgICAgICAgICAgMSwgMVxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51X3BhdHRlcm5tYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xyXG5cclxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXHJcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5maWxsU2hhZGVyO1xyXG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBhcmFtcy5wYWRkZWQgfHwgcG9zTWF0cml4KTtcclxuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBkcmF3IHJlZ2lvbnMgdGhhdCB3ZSBtYXJrZWRcclxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLk5PVEVRVUFMLCAweDAsIDB4M0YpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XHJcblxyXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XHJcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhd0xpbmUoZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlKSB7XHJcbiAgICAvLyBkb24ndCBkcmF3IHplcm8td2lkdGggbGluZXNcclxuICAgIGlmIChsYXllclN0eWxlWydsaW5lLXdpZHRoJ10gPD0gMCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciBhbnRpYWxpYXNpbmcgPSAxIC8gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgdmFyIHdpZHRoID0gbGF5ZXJTdHlsZVsnbGluZS13aWR0aCddO1xyXG4gICAgdmFyIG9mZnNldCA9IGxheWVyU3R5bGVbJ2xpbmUtb2Zmc2V0J10gLyAyO1xyXG4gICAgdmFyIGJsdXIgPSBsYXllclN0eWxlWydsaW5lLWJsdXInXSArIGFudGlhbGlhc2luZztcclxuXHJcbiAgICB2YXIgaW5zZXQgPSBNYXRoLm1heCgtMSwgb2Zmc2V0IC0gd2lkdGggLyAyIC0gYW50aWFsaWFzaW5nIC8gMikgKyAxO1xyXG4gICAgdmFyIG91dHNldCA9IG9mZnNldCArIHdpZHRoIC8gMiArIGFudGlhbGlhc2luZyAvIDI7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gbGF5ZXJTdHlsZVsnbGluZS1jb2xvciddO1xyXG4gICAgdmFyIHJhdGlvID0gcGFpbnRlci50cmFuc2Zvcm0uc2NhbGUgLyAoMSA8PCBwYXJhbXMueikgLyA4O1xyXG4gICAgdmFyIHZ0eE1hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlTWF0cml4KHBvc01hdHJpeCwgcGFyYW1zLnosIGxheWVyU3R5bGVbJ2xpbmUtdHJhbnNsYXRlJ10sIGxheWVyU3R5bGVbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddKTtcclxuXHJcbiAgICB2YXIgc2hhZGVyO1xyXG5cclxuICAgIHZhciBpbWFnZVBvcyA9IGxheWVyU3R5bGVbJ2xpbmUtaW1hZ2UnXSAmJiBpbWFnZVNwcml0ZS5nZXRQb3NpdGlvbihsYXllclN0eWxlWydsaW5lLWltYWdlJ10pO1xyXG4gICAgaWYgKGltYWdlUG9zKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvciA9IDggLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHBhcmFtcy56KTtcclxuXHJcbiAgICAgICAgaW1hZ2VTcHJpdGUuYmluZChnbCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZXBhdHRlcm5TaGFkZXI7XHJcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgdnR4TWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X2xpbmV3aWR0aCwgWyBvdXRzZXQsIGluc2V0IF0pO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9yYXRpbywgcmF0aW8pO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3NpemUsIFtpbWFnZVBvcy5zaXplWzBdICogZmFjdG9yLCBpbWFnZVBvcy5zaXplWzFdIF0pO1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bCwgaW1hZ2VQb3MudGwpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9iciwgaW1hZ2VQb3MuYnIpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlLCBwYWludGVyLnRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5saW5lU2hhZGVyO1xyXG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHZ0eE1hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYmx1ciwgYmx1cik7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcclxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X2Rhc2hhcnJheSwgbGF5ZXJTdHlsZVsnbGluZS1kYXNoYXJyYXknXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVWZXJ0ZXg7XHJcbiAgICB2ZXJ0ZXguYmluZChnbCk7XHJcbiAgICB2YXIgZWxlbWVudCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVFbGVtZW50O1xyXG4gICAgZWxlbWVudC5iaW5kKGdsKTtcclxuXHJcbiAgICB2YXIgZ3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XHJcbiAgICAgICAgdmFyIHZ0eE9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIDQsIGdsLlNIT1JULCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgMCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9leHRydWRlLCAyLCBnbC5CWVRFLCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgNik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9saW5lc29mYXIsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgNCk7XHJcblxyXG4gICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xyXG4gICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50Lml0ZW1TaXplO1xyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi4vc291cmNlL3RpbGVjb29yZC5qcycpO1xyXG52YXIgUHJlcmVuZGVyZWRUZXh0dXJlID0gcmVxdWlyZSgnLi9wcmVyZW5kZXJlZC5qcycpO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdSYXN0ZXI7XHJcblxyXG5mdW5jdGlvbiBkcmF3UmFzdGVyKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBhcmFtcywgc3R5bGUsIGxheWVyLCB0aWxlKSB7XHJcblxyXG4gICAgaWYgKGxheWVyICYmIGxheWVyLmxheWVycykge1xyXG5cclxuICAgICAgICBpZiAoIWJ1Y2tldC5wcmVyZW5kZXJlZCkge1xyXG4gICAgICAgICAgICBidWNrZXQucHJlcmVuZGVyZWQgPSBuZXcgUHJlcmVuZGVyZWRUZXh0dXJlKGdsLCBidWNrZXQuaW5mbywgcGFpbnRlcik7XHJcbiAgICAgICAgICAgIGJ1Y2tldC5wcmVyZW5kZXJlZC5iaW5kRnJhbWVidWZmZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmNsZWFyU3RlbmNpbCgweDgwKTtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbE1hc2soMHhGRik7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcclxuXHJcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGJ1Y2tldC5wcmVyZW5kZXJlZC5zaXplLCBidWNrZXQucHJlcmVuZGVyZWQuc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVja2V0LnByZXJlbmRlcmVkLmJ1ZmZlciAqIDQwOTY7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICAgICAgbWF0NC5vcnRobyhtYXRyaXgsIC1idWZmZXIsIDQwOTYgKyBidWZmZXIsIC00MDk2IC0gYnVmZmVyLCBidWZmZXIsIDAsIDEpO1xyXG4gICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWzAsIC00MDk2LCAwXSk7XHJcblxyXG4gICAgICAgICAgICBwYXJhbXMucGFkZGVkID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICAgICAgbWF0NC5vcnRobyhwYXJhbXMucGFkZGVkLCAwLCA0MDk2LCAtNDA5NiwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIG1hdDQudHJhbnNsYXRlKHBhcmFtcy5wYWRkZWQsIHBhcmFtcy5wYWRkZWQsIFswLCAtNDA5NiwgMF0pO1xyXG5cclxuICAgICAgICAgICAgcGFpbnRlci5kcmF3KHRpbGUsIHN0eWxlLCBsYXllci5sYXllcnMsIHBhcmFtcywgbWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMucGFkZGVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJ1Y2tldC5pbmZvWydyYXN0ZXItYmx1ciddID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYnVja2V0LnByZXJlbmRlcmVkLmJsdXIocGFpbnRlciwgYnVja2V0LmluZm9bJ3Jhc3Rlci1ibHVyJ10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBidWNrZXQucHJlcmVuZGVyZWQudW5iaW5kRnJhbWVidWZmZXIoKTtcclxuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgcGFpbnRlci53aWR0aCwgcGFpbnRlci5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRleHR1cmUgPSBidWNrZXQudGlsZSA/IGJ1Y2tldC50aWxlIDogYnVja2V0LnByZXJlbmRlcmVkO1xyXG5cclxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcclxuXHJcbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5yYXN0ZXJTaGFkZXI7XHJcbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwYWludGVyLnRpbGUucG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xyXG5cclxuICAgIC8vIGNvbG9yIHBhcmFtZXRlcnNcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2xvdywgbGF5ZXJTdHlsZVsncmFzdGVyLWJyaWdodG5lc3MnXVswXSk7XHJcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19oaWdoLCBsYXllclN0eWxlWydyYXN0ZXItYnJpZ2h0bmVzcyddWzFdKTtcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllclN0eWxlWydyYXN0ZXItc2F0dXJhdGlvbiddKSk7XHJcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfY29udHJhc3RfZmFjdG9yLCBjb250cmFzdEZhY3RvcihsYXllclN0eWxlWydyYXN0ZXItY29udHJhc3QnXSkpO1xyXG4gICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudV9zcGluX3dlaWdodHMsIHNwaW5XZWlnaHRzKGxheWVyU3R5bGVbJ3Jhc3Rlci1odWUtcm90YXRlJ10pKTtcclxuXHJcblxyXG4gICAgdmFyIHBhcmVudFRpbGUsIG9wYWNpdGllcztcclxuICAgIGlmIChsYXllciAmJiBsYXllci5sYXllcnMpIHtcclxuICAgICAgICBwYXJlbnRUaWxlID0gbnVsbDtcclxuICAgICAgICBvcGFjaXRpZXMgPSBbbGF5ZXJTdHlsZVsncmFzdGVyLW9wYWNpdHknXSwgMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcmVudFRpbGUgPSBmaW5kUGFyZW50KHRleHR1cmUpO1xyXG4gICAgICAgIG9wYWNpdGllcyA9IGdldE9wYWNpdGllcyh0ZXh0dXJlLCBwYXJlbnRUaWxlKTtcclxuICAgIH1cclxuICAgIHZhciBwYXJlbnRTY2FsZUJ5LCBwYXJlbnRUTDtcclxuXHJcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgIHRleHR1cmUuYmluZChnbCk7XHJcblxyXG4gICAgaWYgKHBhcmVudFRpbGUpIHtcclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcclxuICAgICAgICBwYXJlbnRUaWxlLmJpbmQoZ2wpO1xyXG5cclxuICAgICAgICB2YXIgdGlsZVBvcyA9IFRpbGVDb29yZC5mcm9tSUQodGV4dHVyZS5pZCk7XHJcbiAgICAgICAgdmFyIHBhcmVudFBvcyA9IHBhcmVudFRpbGUgJiYgVGlsZUNvb3JkLmZyb21JRChwYXJlbnRUaWxlLmlkKTtcclxuICAgICAgICBwYXJlbnRTY2FsZUJ5ID0gTWF0aC5wb3coMiwgcGFyZW50UG9zLnogLSB0aWxlUG9zLnopO1xyXG4gICAgICAgIHBhcmVudFRMID0gW3RpbGVQb3MueCAqIHBhcmVudFNjYWxlQnkgJSAxLCB0aWxlUG9zLnkgKiBwYXJlbnRTY2FsZUJ5ICUgMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9wYWNpdGllc1sxXSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJ1ZmZlclNjYWxlID0gYnVja2V0LnByZXJlbmRlcmVkID8gKDQwOTYgKiAoMSArIDIgKiBidWNrZXQucHJlcmVuZGVyZWQuYnVmZmVyKSkgLyA0MDk2IDogMTtcclxuXHJcbiAgICAvLyBjcm9zcy1mYWRlIHBhcmFtZXRlcnNcclxuICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfdGxfcGFyZW50LCBwYXJlbnRUTCB8fCBbMCwgMF0pO1xyXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NjYWxlX3BhcmVudCwgcGFyZW50U2NhbGVCeSB8fCAxKTtcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXJfc2NhbGUsIGJ1ZmZlclNjYWxlKTtcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5MCwgb3BhY2l0aWVzWzBdKTtcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5MSwgb3BhY2l0aWVzWzFdKTtcclxuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTAsIDApO1xyXG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlMSwgMSk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleHR1cmUuYm91bmRzQnVmZmVyIHx8IHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XHJcblxyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsICAgICAgICAgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfdGV4dHVyZV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgNCk7XHJcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHJcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFBhcmVudCh0aWxlKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGlsZS5zb3VyY2U7XHJcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xyXG4gICAgdmFyIHBhcmVudFRpbGVzID0ge307XHJcbiAgICBzb3VyY2UuX2ZpbmRMb2FkZWRQYXJlbnQodGlsZS5pZCwgc291cmNlLm9wdGlvbnMubWluWm9vbSwgcGFyZW50VGlsZXMpO1xyXG4gICAgcmV0dXJuIHNvdXJjZS50aWxlc1tPYmplY3Qua2V5cyhwYXJlbnRUaWxlcylbMF1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFtcChuLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBuKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwaW5XZWlnaHRzKGFuZ2xlKSB7XHJcbiAgICBhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgKDIgKiBjICsgMSkgLyAzLFxyXG4gICAgICAgICgtTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDMsXHJcbiAgICAgICAgKE1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzXHJcbiAgICBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250cmFzdEZhY3Rvcihjb250cmFzdCkge1xyXG4gICAgcmV0dXJuIGNvbnRyYXN0ID4gMCA/XHJcbiAgICAgICAgMSAvICgxIC0gY29udHJhc3QpIDpcclxuICAgICAgICAxICsgY29udHJhc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNhdHVyYXRpb25GYWN0b3Ioc2F0dXJhdGlvbikge1xyXG4gICAgcmV0dXJuIHNhdHVyYXRpb24gPiAwID9cclxuICAgICAgICAxIC0gMSAvICgxLjAwMSAtIHNhdHVyYXRpb24pIDpcclxuICAgICAgICAtc2F0dXJhdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUpIHtcclxuICAgIGlmICghdGlsZS5zb3VyY2UpIHJldHVybiBbMSwgMF07XHJcblxyXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgdmFyIGZhZGVEdXJhdGlvbiA9IHRpbGUuc291cmNlLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb247XHJcblxyXG4gICAgdmFyIHNpbmNlVGlsZSA9IChub3cgLSB0aWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb247XHJcbiAgICB2YXIgc2luY2VQYXJlbnQgPSBwYXJlbnRUaWxlID8gKG5vdyAtIHBhcmVudFRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbiA6IC0xO1xyXG5cclxuICAgIHZhciB0aWxlUG9zID0gVGlsZUNvb3JkLmZyb21JRCh0aWxlLmlkKTtcclxuICAgIHZhciBwYXJlbnRQb3MgPSBwYXJlbnRUaWxlICYmIFRpbGVDb29yZC5mcm9tSUQocGFyZW50VGlsZS5pZCk7XHJcblxyXG4gICAgdmFyIGlkZWFsWiA9IHRpbGUuc291cmNlLl9jb3ZlcmluZ1pvb21MZXZlbCh0aWxlLnNvdXJjZS5fZ2V0Wm9vbSgpKTtcclxuICAgIHZhciBwYXJlbnRGdXJ0aGVyID0gcGFyZW50VGlsZSA/IE1hdGguYWJzKHBhcmVudFBvcy56IC0gaWRlYWxaKSA+IE1hdGguYWJzKHRpbGVQb3MueiAtIGlkZWFsWikgOiBmYWxzZTtcclxuXHJcbiAgICB2YXIgb3BhY2l0eSA9IFtdO1xyXG4gICAgaWYgKCFwYXJlbnRUaWxlIHx8IHBhcmVudEZ1cnRoZXIpIHtcclxuICAgICAgICAvLyBpZiBubyBwYXJlbnQgb3IgcGFyZW50IGlzIG9sZGVyXHJcbiAgICAgICAgb3BhY2l0eVswXSA9IGNsYW1wKHNpbmNlVGlsZSwgMCwgMSk7XHJcbiAgICAgICAgb3BhY2l0eVsxXSA9IDEgLSBvcGFjaXR5WzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBwYXJlbnQgaXMgeW91bmdlciwgem9vbWluZyBvdXRcclxuICAgICAgICBvcGFjaXR5WzBdID0gY2xhbXAoMSAtIHNpbmNlUGFyZW50LCAwLCAxKTtcclxuICAgICAgICBvcGFjaXR5WzFdID0gMSAtIG9wYWNpdHlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9wYWNpdHk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKTtcclxudmFyIG1hdDQgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQ0O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkcmF3U3ltYm9scztcclxuXHJcbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xyXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG4gICAgaWYgKGJ1Y2tldC5lbGVtZW50R3JvdXBzLnRleHQuZ3JvdXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGRyYXdTeW1ib2woZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlLCAndGV4dCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJ1Y2tldC5lbGVtZW50R3JvdXBzLmljb24uZ3JvdXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGRyYXdTeW1ib2woZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlLCAnaWNvbicpO1xyXG4gICAgfVxyXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0U2l6ZXMgPSB7XHJcbiAgICBpY29uOiAxLFxyXG4gICAgdGV4dDogMjRcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRyYXdTeW1ib2woZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlLCBwcmVmaXgpIHtcclxuXHJcbiAgICBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHBhcmFtcy56LCBsYXllclN0eWxlW3ByZWZpeCArICctdHJhbnNsYXRlJ10sIGxheWVyU3R5bGVbcHJlZml4ICsgJy10cmFuc2xhdGUtYW5jaG9yJ10pO1xyXG5cclxuICAgIHZhciBpbmZvID0gYnVja2V0LmluZm87XHJcblxyXG4gICAgdmFyIGV4TWF0cml4ID0gbWF0NC5jbG9uZShwYWludGVyLnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgdmFyIGFsaWduZWRXaXRoTWFwID0gaW5mb1twcmVmaXggKyAnLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJztcclxuICAgIHZhciBhbmdsZU9mZnNldCA9IChhbGlnbmVkV2l0aE1hcCA/IHBhaW50ZXIudHJhbnNmb3JtLmFuZ2xlIDogMCk7XHJcblxyXG4gICAgaWYgKGFuZ2xlT2Zmc2V0KSB7XHJcbiAgICAgICAgbWF0NC5yb3RhdGVaKGV4TWF0cml4LCBleE1hdHJpeCwgYW5nbGVPZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGxheWVyU3R5bGUuc2l6ZSA+IGluZm9bcHJlZml4ICsgJy1tYXgtc2l6ZSddIHRoZW4gbGFiZWxzIG1heSBjb2xsaWRlXHJcbiAgICB2YXIgZm9udFNpemUgPSBsYXllclN0eWxlW3ByZWZpeCArICctc2l6ZSddIHx8IGluZm9bcHJlZml4ICsgJy1tYXgtc2l6ZSddO1xyXG4gICAgdmFyIGZvbnRTY2FsZSA9IGZvbnRTaXplIC8gZGVmYXVsdFNpemVzW3ByZWZpeF07XHJcbiAgICBtYXQ0LnNjYWxlKGV4TWF0cml4LCBleE1hdHJpeCwgWyBmb250U2NhbGUsIGZvbnRTY2FsZSwgMSBdKTtcclxuXHJcbiAgICB2YXIgdGV4dCA9IHByZWZpeCA9PT0gJ3RleHQnO1xyXG4gICAgdmFyIHNkZiA9IHRleHQgfHwgYnVja2V0LmVsZW1lbnRHcm91cHMuc2RmSWNvbnM7XHJcbiAgICB2YXIgc2hhZGVyLCBidWZmZXIsIHRleHNpemU7XHJcblxyXG4gICAgaWYgKCF0ZXh0ICYmICFpbWFnZVNwcml0ZS5sb2FkZWQoKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcblxyXG4gICAgaWYgKHNkZikge1xyXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuc2RmU2hhZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmljb25TaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRleHQpIHtcclxuICAgICAgICBwYWludGVyLmdseXBoQXRsYXMudXBkYXRlVGV4dHVyZShnbCk7XHJcbiAgICAgICAgYnVmZmVyID0gYnVja2V0LmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXg7XHJcbiAgICAgICAgdGV4c2l6ZSA9IFtwYWludGVyLmdseXBoQXRsYXMud2lkdGggLyA0LCBwYWludGVyLmdseXBoQXRsYXMuaGVpZ2h0IC8gNF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGltYWdlU3ByaXRlLmJpbmQoZ2wsIGFsaWduZWRXaXRoTWFwIHx8IHBhcmFtcy5yb3RhdGluZyB8fCBwYXJhbXMuem9vbWluZyB8fCBmb250U2NhbGUgIT0gMSB8fCBzZGYpO1xyXG4gICAgICAgIGJ1ZmZlciA9IGJ1Y2tldC5idWZmZXJzLmljb25WZXJ0ZXg7XHJcbiAgICAgICAgdGV4c2l6ZSA9IFtpbWFnZVNwcml0ZS5pbWcud2lkdGgsIGltYWdlU3ByaXRlLmltZy5oZWlnaHRdO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpO1xyXG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X3RleHR1cmUsIDApO1xyXG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV90ZXhzaXplLCB0ZXhzaXplKTtcclxuXHJcbiAgICBidWZmZXIuYmluZChnbCk7XHJcblxyXG4gICAgdmFyIHVieXRlID0gZ2wuVU5TSUdORURfQllURTtcclxuXHJcbiAgICB2YXIgc3RyaWRlID0gdGV4dCA/IDE2IDogMjA7XHJcblxyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsICAgICAgICAgIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCAwKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfb2Zmc2V0LCAgICAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgNCk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2xhYmVsbWluem9vbSwgMSwgdWJ5dGUsICAgIGZhbHNlLCBzdHJpZGUsIDgpO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9taW56b29tLCAgICAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCA5KTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfbWF4em9vbSwgICAgICAxLCB1Ynl0ZSwgICAgZmFsc2UsIHN0cmlkZSwgMTApO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9hbmdsZSwgICAgICAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCAxMSk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3JhbmdlZW5kLCAgICAgMSwgdWJ5dGUsICAgIGZhbHNlLCBzdHJpZGUsIDEyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcmFuZ2VzdGFydCwgICAxLCB1Ynl0ZSwgICAgZmFsc2UsIHN0cmlkZSwgMTMpO1xyXG5cclxuICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV90ZXgsICAgICAgICAgIDIsIHVieXRlLCAgICAgZmFsc2UsIHN0cmlkZSwgMTQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3RleCwgICAgICAgICAgMiwgZ2wuU0hPUlQsICBmYWxzZSwgc3RyaWRlLCAxNik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgLXBpLi5waSB0byBhbiBpbnQ4IHJhbmdlLlxyXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5yb3VuZCgocGFpbnRlci50cmFuc2Zvcm0uYW5nbGUpIC8gTWF0aC5QSSAqIDEyOCk7XHJcblxyXG4gICAgLy8gYWRqdXN0IG1pbi9tYXggem9vbXMgZm9yIHZhcmlhYmxlIGZvbnQgc2llc1xyXG4gICAgdmFyIHpvb21BZGp1c3QgPSBNYXRoLmxvZyhmb250U2l6ZSAvIGluZm9bcHJlZml4ICsgJy1tYXgtc2l6ZSddKSAvIE1hdGguTE4yIHx8IDA7XHJcblxyXG4gICAgdmFyIGZsaXAgPSBhbGlnbmVkV2l0aE1hcCAmJiBpbmZvW3ByZWZpeCArICcta2VlcC11cHJpZ2h0J107XHJcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmxpcCwgZmxpcCA/IDEgOiAwKTtcclxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9hbmdsZSwgKGFuZ2xlICsgMjU2KSAlIDI1Nik7XHJcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfem9vbSwgKHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSB6b29tQWRqdXN0KSAqIDEwKTsgLy8gY3VycmVudCB6b29tIGxldmVsXHJcblxyXG4gICAgdmFyIGYgPSBwYWludGVyLmZyYW1lSGlzdG9yeS5nZXRGYWRlUHJvcGVydGllcygzMDApO1xyXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGVkaXN0LCBmLmZhZGVkaXN0ICogMTApO1xyXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21pbmZhZGV6b29tLCBNYXRoLmZsb29yKGYubWluZmFkZXpvb20gKiAxMCkpO1xyXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heGZhZGV6b29tLCBNYXRoLmZsb29yKGYubWF4ZmFkZXpvb20gKiAxMCkpO1xyXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGV6b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSArIGYuYnVtcCkgKiAxMCk7XHJcblxyXG4gICAgaWYgKCFzZGYpIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllclN0eWxlWydpY29uLW9wYWNpdHknXSk7XHJcblxyXG4gICAgdmFyIHNkZkZvbnRTaXplID0gdGV4dCA/IDI0IDogMTtcclxuICAgIHZhciBzZGZQeCA9IDg7XHJcbiAgICB2YXIgYmx1ck9mZnNldCA9IDEuMTk7XHJcbiAgICB2YXIgaGFsb09mZnNldCA9IDY7XHJcblxyXG4gICAgaWYgKHNkZikge1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIDAuMTA1ICogc2RmRm9udFNpemUgLyBmb250U2l6ZSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgbGF5ZXJTdHlsZVtwcmVmaXggKyAnLWNvbG9yJ10pO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsICgyNTYgLSA2NCkgLyAyNTYpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiZWdpbiA9IGJ1Y2tldC5lbGVtZW50R3JvdXBzW3ByZWZpeF0uZ3JvdXBzWzBdLnZlcnRleFN0YXJ0SW5kZXgsXHJcbiAgICAgICAgbGVuID0gYnVja2V0LmVsZW1lbnRHcm91cHNbcHJlZml4XS5ncm91cHNbMF0udmVydGV4TGVuZ3RoO1xyXG5cclxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCBiZWdpbiwgbGVuKTtcclxuXHJcbiAgICBpZiAoc2RmICYmIGxheWVyU3R5bGVbcHJlZml4ICsgJy1oYWxvLWNvbG9yJ10pIHtcclxuICAgICAgICAvLyBEcmF3IGhhbG8gdW5kZXJuZWF0aCB0aGUgdGV4dC5cclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIChsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1ibHVyJ10gKiBibHVyT2Zmc2V0IC8gKGZvbnRTaXplIC8gc2RmRm9udFNpemUpIC8gc2RmUHgpICsgKDAuMTA1ICogc2RmRm9udFNpemUgLyBmb250U2l6ZSkgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGxheWVyU3R5bGVbcHJlZml4ICsgJy1oYWxvLWNvbG9yJ10pO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsIChoYWxvT2Zmc2V0IC0gbGF5ZXJTdHlsZVtwcmVmaXggKyAnLWhhbG8td2lkdGgnXSAvIChmb250U2l6ZSAvIHNkZkZvbnRTaXplKSkgLyBzZGZQeCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCBiZWdpbiwgbGVuKTtcclxuICAgIH1cclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdWZXJ0aWNlcztcclxuXHJcbmZ1bmN0aW9uIGRyYXdWZXJ0aWNlcyhnbCwgcGFpbnRlciwgYnVja2V0KSB7XHJcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cclxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRvdFNoYWRlciwgcGFpbnRlci50aWxlLnBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcclxuXHJcbiAgICAvLyAvLyBEcmF3IGRlYnVnIHBvaW50cy5cclxuICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X3NpemUsIDQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgZ2wudW5pZm9ybTFmKHBhaW50ZXIuZG90U2hhZGVyLnVfYmx1ciwgMC4yNSk7XHJcbiAgICBnbC51bmlmb3JtNGZ2KHBhaW50ZXIuZG90U2hhZGVyLnVfY29sb3IsIFswLjI1LCAwLCAwLCAwLjI1XSk7XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIHRyaWFuZ2xlIGZhbiBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cclxuXHJcbiAgICB2YXIgdmVydGV4LCBncm91cHMsIGdyb3VwLCBiZWdpbiwgY291bnQ7XHJcblxyXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xyXG4gICAgaWYgKGJ1Y2tldC5pbmZvLmZpbGwpIHtcclxuICAgICAgICB2ZXJ0ZXggPSBidWNrZXQuYnVmZmVycy5maWxsVmVydGV4O1xyXG4gICAgICAgIHZlcnRleC5iaW5kKGdsKTtcclxuICAgICAgICBncm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XHJcbiAgICAgICAgICAgIGJlZ2luID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcclxuICAgICAgICAgICAgY291bnQgPSBncm91cC52ZXJ0ZXhMZW5ndGg7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kb3RTaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCBiZWdpbiwgY291bnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV3UG9zTWF0cml4ID0gbWF0NC5jbG9uZShwYWludGVyLnRpbGUucG9zTWF0cml4KTtcclxuICAgIG1hdDQuc2NhbGUobmV3UG9zTWF0cml4LCBuZXdQb3NNYXRyaXgsIFswLjUsIDAuNSwgMV0pO1xyXG5cclxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRvdFNoYWRlciwgbmV3UG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xyXG5cclxuICAgIC8vIERyYXcgYWxsIGxpbmUgYnVmZmVyc1xyXG4gICAgaWYgKGJ1Y2tldC5pbmZvLmxpbmUpIHtcclxuICAgICAgICB2ZXJ0ZXggPSBidWNrZXQuYnVmZmVycy5saW5lVmVydGV4O1xyXG4gICAgICAgIHZlcnRleC5iaW5kKGdsKTtcclxuICAgICAgICBncm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHM7XHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBncm91cHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNba107XHJcbiAgICAgICAgICAgIGJlZ2luID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcclxuICAgICAgICAgICAgY291bnQgPSBncm91cC52ZXJ0ZXhMZW5ndGg7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kb3RTaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCBiZWdpbiwgY291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXHJcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lSGlzdG9yeTtcclxuXHJcbmZ1bmN0aW9uIEZyYW1lSGlzdG9yeSgpIHtcclxuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gW107XHJcbn1cclxuXHJcbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUuZ2V0RmFkZVByb3BlcnRpZXMgPSBmdW5jdGlvbihkdXJhdGlvbikge1xyXG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIGR1cmF0aW9uID0gMzAwO1xyXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgZnJhbWVzIHVudGlsIG9ubHkgb25lIGlzIG91dHNpZGUgdGhlIGR1cmF0aW9uLCBvciB1bnRpbCB0aGVyZSBhcmUgb25seSB0aHJlZVxyXG4gICAgd2hpbGUgKHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCA+IDMgJiYgdGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcclxuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lICsgZHVyYXRpb24gPCBjdXJyZW50VGltZSkge1xyXG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5WzBdLnogPSB0aGlzLmZyYW1lSGlzdG9yeVsxXS56O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmcmFtZUxlbiA9IHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aDtcclxuICAgIGlmIChmcmFtZUxlbiA8IDMpIGNvbnNvbGUud2FybigndGhlcmUgc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiB0aHJlZSBmcmFtZXMgaW4gdGhlIGhpc3RvcnknKTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSByYW5nZSBvZiB6b29tIGxldmVscyB3ZSB3YW50IHRvIGZhZGUgYmV0d2VlblxyXG4gICAgdmFyIHN0YXJ0aW5nWiA9IHRoaXMuZnJhbWVIaXN0b3J5WzBdLnosXHJcbiAgICAgICAgbGFzdEZyYW1lID0gdGhpcy5mcmFtZUhpc3RvcnlbZnJhbWVMZW4gLSAxXSxcclxuICAgICAgICBlbmRpbmdaID0gbGFzdEZyYW1lLnosXHJcbiAgICAgICAgbG93WiA9IE1hdGgubWluKHN0YXJ0aW5nWiwgZW5kaW5nWiksXHJcbiAgICAgICAgaGlnaFogPSBNYXRoLm1heChzdGFydGluZ1osIGVuZGluZ1opO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3BlZWQgb2Ygem9vbWluZywgYW5kIGhvdyBmYXIgaXQgd291bGQgem9vbSBpbiB0ZXJtcyBvZiB6b29tIGxldmVscyBpbiBvbmUgZHVyYXRpb25cclxuICAgIHZhciB6b29tRGlmZiA9IGxhc3RGcmFtZS56IC0gdGhpcy5mcmFtZUhpc3RvcnlbMV0ueixcclxuICAgICAgICB0aW1lRGlmZiA9IGxhc3RGcmFtZS50aW1lIC0gdGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZTtcclxuICAgIHZhciBmYWRlZGlzdCA9IHpvb21EaWZmIC8gKHRpbWVEaWZmIC8gZHVyYXRpb24pO1xyXG5cclxuICAgIGlmIChpc05hTihmYWRlZGlzdCkpIGNvbnNvbGUud2FybignZmFkZWRpc3Qgc2hvdWxkIG5ldmVyIGJlIE5hTicpO1xyXG5cclxuICAgIC8vIEF0IGVuZCBvZiBhIHpvb20gd2hlbiB0aGUgem9vbSBzdG9wcyBjaGFuZ2luZyBjb250aW51ZSBwcmV0ZW5kaW5nIHRvIHpvb20gYXQgdGhhdCBzcGVlZFxyXG4gICAgLy8gYnVtcCBpcyBob3cgbXVjaCBmYXJ0aGVyIGl0IHdvdWxkIGhhdmUgYmVlbiBpZiBpdCBoYWQgY29udGludWVkIHpvb21pbmcgYXQgdGhlIHNhbWUgcmF0ZVxyXG4gICAgdmFyIGJ1bXAgPSAoY3VycmVudFRpbWUgLSBsYXN0RnJhbWUudGltZSkgLyBkdXJhdGlvbiAqIGZhZGVkaXN0O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmFkZWRpc3Q6IGZhZGVkaXN0LFxyXG4gICAgICAgIG1pbmZhZGV6b29tOiBsb3daLFxyXG4gICAgICAgIG1heGZhZGV6b29tOiBoaWdoWixcclxuICAgICAgICBidW1wOiBidW1wXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gUmVjb3JkIGZyYW1lIGhpc3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGZhZGluZyBwYXJhbXNcclxuRnJhbWVIaXN0b3J5LnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbih6b29tKSB7XHJcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cclxuICAgIC8vIGZpcnN0IGZyYW1lIGV2ZXJcclxuICAgIGlmICghdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnkucHVzaCh7dGltZTogMCwgejogem9vbSB9LCB7dGltZTogMCwgejogem9vbSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoID09PSAyIHx8IHRoaXMuZnJhbWVIaXN0b3J5W3RoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCAtIDFdLnogIT09IHpvb20pIHtcclxuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5wdXNoKHtcclxuICAgICAgICAgICAgdGltZTogY3VycmVudFRpbWUsXHJcbiAgICAgICAgICAgIHo6IHpvb21cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNoYWRlcnMgPSByZXF1aXJlKCcuL3NoYWRlcnMuanMnKTtcclxuXHJcbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgY29udGV4dC5nZXRTaGFkZXIgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGtpbmQgPSB0eXBlID09IHRoaXMuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnO1xyXG4gICAgICAgIGlmICghc2hhZGVyc1tuYW1lXSB8fCAhc2hhZGVyc1tuYW1lXVtraW5kXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBzaGFkZXIgXCIgKyBuYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuICAgICAgICB0aGlzLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlcnNbbmFtZV1ba2luZF0pO1xyXG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgIGlmICghdGhpcy5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb250ZXh0LmluaXRpYWxpemVTaGFkZXIgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB1bmlmb3Jtcykge1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB7XHJcbiAgICAgICAgICAgIHByb2dyYW06IHRoaXMuY3JlYXRlUHJvZ3JhbSgpLFxyXG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5nZXRTaGFkZXIobmFtZSwgdGhpcy5GUkFHTUVOVF9TSEFERVIpLFxyXG4gICAgICAgICAgICB2ZXJ0ZXg6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuVkVSVEVYX1NIQURFUiksXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgc2hhZGVyLnZlcnRleCk7XHJcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIHNoYWRlci5mcmFnbWVudCk7XHJcbiAgICAgICAgdGhpcy5saW5rUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5wcm9ncmFtLCB0aGlzLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyLnByb2dyYW0pKTtcclxuICAgICAgICAgICAgYWxlcnQoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIgXCIgKyBuYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyLmF0dHJpYnV0ZXMucHVzaChzaGFkZXJbYXR0cmlidXRlc1tpXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlclt1bmlmb3Jtc1trXV0gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXIucHJvZ3JhbSwgdW5pZm9ybXNba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBzaGFkZXIgcHJvZ3JhbS5cclxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XHJcbiAgICAgICAgaWYgKCFwb3NNYXRyaXgpIHtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgncG9zTWF0cml4IGRvZXMgbm90IGhhdmUgcmVxdWlyZWQgYXJndW1lbnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaGFkZXIgIT09IHNoYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWJsZSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBleGlzdGluZyBzaGFkZXIgdGhhdCBhcmVuJ3QgdXNlZCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHNoYWRlci4gTm90ZTogYXR0cmlidXRlIGluZGljZXMgYXJlICpub3QqIHByb2dyYW0gc3BlY2lmaWMhXHJcbiAgICAgICAgICAgIHZhciBlbmFibGVkID0gdGhpcy5jdXJyZW50U2hhZGVyID8gdGhpcy5jdXJyZW50U2hhZGVyLmF0dHJpYnV0ZXMgOiBbXTtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkID0gc2hhZGVyLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuYWJsZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZC5pbmRleE9mKGVuYWJsZWRbaV0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGVuYWJsZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbmFibGUgYWxsIGF0dHJpYnV0ZXMgZm9yIHRoZSBuZXcgc2hhZGVyLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcXVpcmVkLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZC5pbmRleE9mKHJlcXVpcmVkW2pdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHJlcXVpcmVkW2pdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnkuIE5vdGU6IFRoaXMgcmVsaWVzIG9uIG9iamVjdCBpZGVudGl0eSFcclxuICAgICAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XHJcbiAgICAgICAgLy8gd2lsbCBGQUlMIHRvIHVwZGF0ZSB0aGUgbWF0cml4IHByb3Blcmx5LlxyXG4gICAgICAgIGlmIChzaGFkZXIucG9zTWF0cml4ICE9PSBwb3NNYXRyaXgpIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XHJcbiAgICAgICAgICAgIHNoYWRlci5wb3NNYXRyaXggPSBwb3NNYXRyaXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleE1hdHJpeCAmJiBzaGFkZXIuZXhNYXRyaXggIT09IGV4TWF0cml4ICYmIHNoYWRlci51X2V4bWF0cml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybU1hdHJpeDRmdihzaGFkZXIudV9leG1hdHJpeCwgZmFsc2UsIGV4TWF0cml4KTtcclxuICAgICAgICAgICAgc2hhZGVyLmV4TWF0cml4ID0gZXhNYXRyaXg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdsdXRpbCA9IHJlcXVpcmUoJy4vZ2x1dGlsLmpzJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyk7XHJcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoYXRsYXMuanMnKTtcclxudmFyIGdsbWF0cml4ID0gcmVxdWlyZSgnLi4vbGliL2dsbWF0cml4LmpzJyk7XHJcbnZhciBGcmFtZUhpc3RvcnkgPSByZXF1aXJlKCcuL2ZyYW1laGlzdG9yeS5qcycpO1xyXG5cclxudmFyIG1hdDQgPSBnbG1hdHJpeC5tYXQ0O1xyXG5cclxudmFyIGRyYXdTeW1ib2wgPSByZXF1aXJlKCcuL2RyYXdzeW1ib2wuanMnKTtcclxudmFyIGRyYXdMaW5lID0gcmVxdWlyZSgnLi9kcmF3bGluZS5qcycpO1xyXG52YXIgZHJhd0ZpbGwgPSByZXF1aXJlKCcuL2RyYXdmaWxsLmpzJyk7XHJcbnZhciBkcmF3UmFzdGVyID0gcmVxdWlyZSgnLi9kcmF3cmFzdGVyLmpzJyk7XHJcbnZhciBkcmF3RGVidWcgPSByZXF1aXJlKCcuL2RyYXdkZWJ1Zy5qcycpO1xyXG52YXIgZHJhd0JhY2tncm91bmQgPSByZXF1aXJlKCcuL2RyYXdiYWNrZ3JvdW5kLmpzJyk7XHJcbnZhciBkcmF3VmVydGljZXMgPSByZXF1aXJlKCcuL2RyYXd2ZXJ0aWNlcy5qcycpO1xyXG5cclxuLypcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBwYWludGVyIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtDYW52YXN9IGdsIGFuIGV4cGVyaW1lbnRhbC13ZWJnbCBkcmF3aW5nIGNvbnRleHRcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gR0xQYWludGVyO1xyXG5mdW5jdGlvbiBHTFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xyXG4gICAgdGhpcy5nbCA9IGdsdXRpbC5leHRlbmQoZ2wpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcblxyXG4gICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzID0ge307XHJcbiAgICB0aGlzLnByZUZib3MgPSB7fTtcclxuXHJcbiAgICB0aGlzLnRpbGVFeHRlbnQgPSA0MDk2O1xyXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBuZXcgRnJhbWVIaXN0b3J5KCk7XHJcblxyXG4gICAgdGhpcy5zZXR1cCgpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBVcGRhdGUgdGhlIEdMIHZpZXdwb3J0LCBwcm9qZWN0aW9uIG1hdHJpeCwgYW5kIHRyYW5zZm9ybXMgdG8gY29tcGVuc2F0ZVxyXG4gKiBmb3IgYSBuZXcgd2lkdGggYW5kIGhlaWdodCB2YWx1ZS5cclxuICovXHJcbkdMUGFpbnRlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIC8vIEluaXRpYWxpemUgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICBtYXQ0Lm9ydGhvKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgLTEpO1xyXG5cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxufTtcclxuXHJcblxyXG5HTFBhaW50ZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIGdsLnZlcmJvc2UgPSB0cnVlO1xyXG5cclxuICAgIC8vIFdlIGFyZSBibGVuZGluZyB0aGUgbmV3IHBpeGVscyAqYmVoaW5kKiB0aGUgZXhpc3RpbmcgcGl4ZWxzLiBUaGF0IHdheSB3ZSBjYW5cclxuICAgIC8vIGRyYXcgZnJvbnQtdG8tYmFjayBhbmQgdXNlIHRoZW4gc3RlbmNpbCBidWZmZXIgdG8gY3VsbCBvcGFxdWUgcGl4ZWxzIGVhcmx5LlxyXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xyXG5cclxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG5cclxuICAgIHRoaXMuZ2x5cGhBdGxhcyA9IG5ldyBHbHlwaEF0bGFzKDEwMjQsIDEwMjQpO1xyXG4gICAgLy8gdGhpcy5nbHlwaEF0bGFzLmRlYnVnID0gdHJ1ZTtcclxuICAgIHRoaXMuZ2x5cGhBdGxhcy5iaW5kKGdsKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcclxuICAgIHRoaXMuZGVidWdTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdkZWJ1ZycsXHJcbiAgICAgICAgWydhX3BvcyddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9wb2ludHNpemUnLCAndV9jb2xvciddKTtcclxuXHJcbiAgICB0aGlzLmdhdXNzaWFuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZ2F1c3NpYW4nLFxyXG4gICAgICAgIFsnYV9wb3MnXSxcclxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfaW1hZ2UnLCAndV9vZmZzZXQnXSk7XHJcblxyXG4gICAgdGhpcy5yYXN0ZXJTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdyYXN0ZXInLFxyXG4gICAgICAgIFsnYV9wb3MnLCAnYV90ZXh0dXJlX3BvcyddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9icmlnaHRuZXNzX2xvdycsICd1X2JyaWdodG5lc3NfaGlnaCcsICd1X3NhdHVyYXRpb25fZmFjdG9yJywgJ3Vfc3Bpbl93ZWlnaHRzJywgJ3VfY29udHJhc3RfZmFjdG9yJywgJ3Vfb3BhY2l0eTAnLCAndV9vcGFjaXR5MScsICd1X2ltYWdlMCcsICd1X2ltYWdlMScsICd1X3RsX3BhcmVudCcsICd1X3NjYWxlX3BhcmVudCcsICd1X2J1ZmZlcl9zY2FsZSddKTtcclxuXHJcbiAgICB0aGlzLmxpbmVTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdsaW5lJyxcclxuICAgICAgICBbJ2FfcG9zJywgJ2FfZXh0cnVkZScsICdhX2xpbmVzb2ZhciddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X2xpbmV3aWR0aCcsICd1X2NvbG9yJywgJ3VfcmF0aW8nLCAndV9kYXNoYXJyYXknLCAndV9ibHVyJ10pO1xyXG5cclxuICAgIHRoaXMubGluZXBhdHRlcm5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdsaW5lcGF0dGVybicsXHJcbiAgICAgICAgWydhX3BvcycsICdhX2V4dHJ1ZGUnLCAnYV9saW5lc29mYXInXSxcclxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV9saW5ld2lkdGgnLCAndV9yYXRpbycsICd1X3BhdHRlcm5fc2l6ZScsICd1X3BhdHRlcm5fdGwnLCAndV9wYXR0ZXJuX2JyJywgJ3VfcG9pbnQnLCAndV9ibHVyJywgJ3VfZmFkZSddKTtcclxuXHJcbiAgICB0aGlzLmRvdFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2RvdCcsXHJcbiAgICAgICAgWydhX3BvcyddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9zaXplJywgJ3VfY29sb3InLCAndV9ibHVyJ10pO1xyXG5cclxuICAgIHRoaXMuc2RmU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignc2RmJyxcclxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4JywgJ2Ffb2Zmc2V0JywgJ2FfYW5nbGUnLCAnYV9taW56b29tJywgJ2FfbWF4em9vbScsICdhX3JhbmdlZW5kJywgJ2FfcmFuZ2VzdGFydCcsICdhX2xhYmVsbWluem9vbSddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfY29sb3InLCAndV9nYW1tYScsICd1X2J1ZmZlcicsICd1X2FuZ2xlJywgJ3Vfem9vbScsICd1X2ZsaXAnLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbSddKTtcclxuXHJcbiAgICB0aGlzLmljb25TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdpY29uJyxcclxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4JywgJ2Ffb2Zmc2V0JywgJ2FfYW5nbGUnLCAnYV9taW56b29tJywgJ2FfbWF4em9vbScsICdhX3JhbmdlZW5kJywgJ2FfcmFuZ2VzdGFydCcsICdhX2xhYmVsbWluem9vbSddLFxyXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfYW5nbGUnLCAndV96b29tJywgJ3VfZmxpcCcsICd1X2ZhZGVkaXN0JywgJ3VfbWluZmFkZXpvb20nLCAndV9tYXhmYWRlem9vbScsICd1X2ZhZGV6b29tJywgJ3Vfb3BhY2l0eSddKTtcclxuXHJcbiAgICB0aGlzLm91dGxpbmVTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdvdXRsaW5lJyxcclxuICAgICAgICBbJ2FfcG9zJ10sXHJcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2NvbG9yJywgJ3Vfd29ybGQnXVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnBhdHRlcm5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdwYXR0ZXJuJyxcclxuICAgICAgICBbJ2FfcG9zJ10sXHJcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3BhdHRlcm5fdGwnLCAndV9wYXR0ZXJuX2JyJywgJ3VfbWl4JywgJ3VfcGF0dGVybm1hdHJpeCcsICd1X29wYWNpdHknLCAndV9pbWFnZSddXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuZmlsbFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ZpbGwnLFxyXG4gICAgICAgIFsnYV9wb3MnXSxcclxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfY29sb3InXVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuXHJcbiAgICAvLyBUaGUgYmFja2dyb3VuZEJ1ZmZlciBpcyB1c2VkIHdoZW4gZHJhd2luZyB0byB0aGUgZnVsbCAqY2FudmFzKlxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUgPSAyO1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCA9IDQ7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDFdKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIC8vIFRoZSB0aWxlRXh0ZW50QnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIGEgZnVsbCAqdGlsZSpcclxuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplID0gNDtcclxuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoW1xyXG4gICAgICAgIC8vIHRpbGUgY29vcmQgeCwgdGlsZSBjb29yZCB5LCB0ZXh0dXJlIGNvb3JkIHgsIHRleHR1cmUgY29vcmQgeVxyXG4gICAgICAgICAgICAgICAgICAgICAgMCwgMCwgICAgICAgICAgICAgICAgICAgIDAsIDAsXHJcbiAgICAgICAgdGhpcy50aWxlRXh0ZW50LCAwLCAgICAgICAgICAgICAgICAzMjc2NywgMCxcclxuICAgICAgICAgICAgICAgICAgICAgIDAsIHRoaXMudGlsZUV4dGVudCwgICAgICAwLCAzMjc2NyxcclxuICAgICAgICB0aGlzLnRpbGVFeHRlbnQsIHRoaXMudGlsZUV4dGVudCwgIDMyNzY3LCAzMjc2N1xyXG4gICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAvLyBUaGUgZGVidWdCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgb3V0bGluZXMgZm9yIGRlYnVnZ2luZ1xyXG4gICAgdGhpcy5kZWJ1Z0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSA9IDI7XHJcbiAgICB0aGlzLmRlYnVnQnVmZmVyLml0ZW1Db3VudCA9IDU7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5kZWJ1Z0J1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoWzAsIDAsIDQwOTUsIDAsIDQwOTUsIDQwOTUsIDAsIDQwOTUsIDAsIDBdKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIC8vIFRoZSBkZWJ1Z1RleHRCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgSURzIGZvciBkZWJ1Z2dpbmdcclxuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB0aGlzLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSA9IDI7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBSZXNldCB0aGUgY29sb3IgYnVmZmVycyBvZiB0aGUgZHJhd2luZyBjYW52YXMuXHJcbiAqL1xyXG5HTFBhaW50ZXIucHJvdG90eXBlLmNsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBSZXNldCB0aGUgZHJhd2luZyBjYW52YXMgYnkgY2xlYXJpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRyYXdcclxuICogbmV3IHRpbGVzIGF0IHRoZSBzYW1lIGxvY2F0aW9uLCB3aGlsZSByZXRhaW5pbmcgcHJldmlvdXNseSBkcmF3biBwaXhlbHMuXHJcbiAqL1xyXG5HTFBhaW50ZXIucHJvdG90eXBlLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIGdsLmNsZWFyU3RlbmNpbCgweDApO1xyXG4gICAgZ2wuc3RlbmNpbE1hc2soMHhGRik7XHJcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xyXG59O1xyXG5cclxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3Q2xpcHBpbmdNYXNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHRoaXMuZmlsbFNoYWRlciwgdGhpcy50aWxlLnBvc01hdHJpeCwgdGhpcy50aWxlLmV4TWF0cml4KTtcclxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gQ2xlYXIgdGhlIGVudGlyZSBzdGVuY2lsIGJ1ZmZlciwgZXhjZXB0IGZvciB0aGUgN3RoIGJpdCwgd2hpY2ggc3RvcmVzXHJcbiAgICAvLyB0aGUgZ2xvYmFsIGNsaXBwaW5nIG1hc2sgdGhhdCBhbGxvd3MgdXMgdG8gYXZvaWQgZHJhd2luZyBpbiByZWdpb25zIG9mXHJcbiAgICAvLyB0aWxlcyB3ZSd2ZSBhbHJlYWR5IHBhaW50ZWQgaW4uXHJcbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcclxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4QkYpO1xyXG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAvLyBUaGUgc3RlbmNpbCB0ZXN0IHdpbGwgZmFpbCBhbHdheXMsIG1lYW5pbmcgd2Ugc2V0IGFsbCBwaXhlbHMgY292ZXJlZFxyXG4gICAgLy8gYnkgdGhpcyBnZW9tZXRyeSB0byAweDgwLiBXZSB1c2UgdGhlIGhpZ2hlc3QgYml0IDB4ODAgdG8gbWFyayB0aGUgcmVnaW9uc1xyXG4gICAgLy8gd2Ugd2FudCB0byBkcmF3IGluLiBBbGwgcGl4ZWxzIHRoYXQgaGF2ZSB0aGlzIGJpdCAqbm90KiBzZXQgd2lsbCBuZXZlciBiZVxyXG4gICAgLy8gZHJhd24gaW4uXHJcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhDMCwgMHg0MCk7XHJcbiAgICBnbC5zdGVuY2lsTWFzaygweEMwKTtcclxuICAgIGdsLnN0ZW5jaWxPcChnbC5SRVBMQUNFLCBnbC5LRUVQLCBnbC5LRUVQKTtcclxuXHJcbiAgICAvLyBEcmF3IHRoZSBjbGlwcGluZyBtYXNrXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5maWxsU2hhZGVyLmFfcG9zLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XHJcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcclxuXHJcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XHJcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuUkVQTEFDRSk7XHJcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcclxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxufTtcclxuXHJcbkdMUGFpbnRlci5wcm90b3R5cGUucHJlcGFyZUJ1ZmZlcnMgPSBmdW5jdGlvbigpIHt9OyAvLyBPdmVycmlkZGVuIGJ5IGhlYWRsZXNzIHRlc3RzLlxyXG5cclxuLypcclxuICogRHJhdyBhIG5ldyB0aWxlIHRvIHRoZSBjb250ZXh0LCBhc3N1bWluZyB0aGF0IHRoZSB2aWV3cG9ydCBpc1xyXG4gKiBhbHJlYWR5IGNvcnJlY3RseSBzZXQuXHJcbiAqL1xyXG5HTFBhaW50ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBnbFBhaW50ZXJEcmF3KHRpbGUsIHN0eWxlLCBsYXllcnMsIHBhcmFtcywgbWF0cml4KSB7XHJcbiAgICB0aGlzLnRpbGUgPSB0aWxlO1xyXG5cclxuICAgIC8vIGZhbHNlIHdoZW4gZHJhd2luZyBhIGdyb3VwIG9mIGNvbXBvc2l0ZWQgbGF5ZXJzXHJcbiAgICBpZiAodGlsZSAmJiAhbWF0cml4KSB7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgcm9vdCBjbGlwcGluZyBtYXNrLlxyXG4gICAgICAgIHRoaXMuZHJhd0NsaXBwaW5nTWFzaygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShsYXllcnMpKSBjb25zb2xlLndhcm4oJ0xheWVycyBpcyBub3QgYW4gYXJyYXknKTtcclxuXHJcbiAgICB0aGlzLmZyYW1lSGlzdG9yeS5yZWNvcmQodGhpcy50cmFuc2Zvcm0uem9vbSk7XHJcblxyXG4gICAgLy8gRHJhdyBsYXllcnMgZnJvbnQtdG8tYmFjay5cclxuICAgIC8vIExheWVycyBhcmUgYWxyZWFkeSBpbiByZXZlcnNlIG9yZGVyIGZyb20gc3R5bGUucmVzdHJ1Y3R1cmUoKVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZShsYXllcnNbaV0sIHN0eWxlLCB0aWxlICYmIHRpbGUuYnVja2V0cywgcGFyYW1zLCB0aWxlLCBtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbXMuZGVidWcpIHtcclxuICAgICAgICBkcmF3RGVidWcodGhpcy5nbCwgdGhpcywgdGlsZSwgcGFyYW1zKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdMUGFpbnRlci5wcm90b3R5cGUuYXBwbHlTdHlsZSA9IGZ1bmN0aW9uKGxheWVyLCBzdHlsZSwgYnVja2V0cywgcGFyYW1zLCB0aWxlLCBtYXRyaXgpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgdmFyIGxheWVyU3R5bGUgPSBzdHlsZS5jb21wdXRlZFtsYXllci5pZF07XHJcbiAgICBpZiAoIWxheWVyU3R5bGUgfHwgbGF5ZXJTdHlsZS5oaWRkZW4pIHJldHVybjtcclxuXHJcbiAgICBpZiAobGF5ZXIubGF5ZXJzICYmIGxheWVyLnR5cGUgPT09ICdyYXN0ZXInKSB7XHJcbiAgICAgICAgZHJhd1Jhc3RlcihnbCwgdGhpcywgYnVja2V0c1tsYXllci5idWNrZXRdLCBsYXllclN0eWxlLCBwYXJhbXMsIHN0eWxlLCBsYXllciwgdGlsZSk7XHJcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgZHJhd0JhY2tncm91bmQoZ2wsIHRoaXMsIHVuZGVmaW5lZCwgbGF5ZXJTdHlsZSwgdGhpcy5pZGVudGl0eU1hdHJpeCwgcGFyYW1zLCBzdHlsZS5zcHJpdGUpO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbbGF5ZXIuYnVja2V0XTtcclxuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gdmVydGljZXMgeWV0IGZvciB0aGlzIGxheWVyLlxyXG4gICAgICAgIGlmICghYnVja2V0IHx8IChidWNrZXQuaGFzRGF0YSAmJiAhYnVja2V0Lmhhc0RhdGEoKSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHR5cGUgPSBidWNrZXQudHlwZTtcclxuXHJcbiAgICAgICAgaWYgKGJ1Y2tldC5taW5ab29tICYmIHRoaXMudHJhbnNmb3JtLnpvb20gPCBidWNrZXQubWluWm9vbSkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChidWNrZXQubWF4Wm9vbSAmJiB0aGlzLnRyYW5zZm9ybS56b29tID49IGJ1Y2tldC5tYXhab29tKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBkcmF3ID0gdHlwZSA9PT0gJ3N5bWJvbCcgPyBkcmF3U3ltYm9sIDpcclxuICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdmaWxsJyA/IGRyYXdGaWxsIDpcclxuICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdsaW5lJyA/IGRyYXdMaW5lIDpcclxuICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdyYXN0ZXInID8gZHJhd1Jhc3RlciA6IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChkcmF3KSB7XHJcbiAgICAgICAgICAgIHZhciB1c2VNYXRyaXggPSBtYXRyaXggfHwgdGhpcy50aWxlLnBvc01hdHJpeDtcclxuICAgICAgICAgICAgZHJhdyhnbCwgdGhpcywgYnVja2V0LCBsYXllclN0eWxlLCB1c2VNYXRyaXgsIHBhcmFtcywgc3R5bGUuc3ByaXRlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGJ1Y2tldCB0eXBlIHNwZWNpZmllZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcmFtcy52ZXJ0aWNlcyAmJiAhbGF5ZXIubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGRyYXdWZXJ0aWNlcyhnbCwgdGhpcywgYnVja2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBEcmF3cyBub24tb3BhcXVlIGFyZWFzLiBUaGlzIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbkdMUGFpbnRlci5wcm90b3R5cGUuZHJhd1N0ZW5jaWxCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBnbC5zd2l0Y2hTaGFkZXIodGhpcy5maWxsU2hhZGVyLCB0aGlzLmlkZW50aXR5TWF0cml4KTtcclxuXHJcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cclxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XHJcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XHJcblxyXG4gICAgLy8gRHJ3IHRoZSBmaWxsaW5nIHF1YWQgd2hlcmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzbid0IHNldC5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmZpbGxTaGFkZXIuYV9wb3MsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcclxuICAgIGdsLnVuaWZvcm00ZnYodGhpcy5maWxsU2hhZGVyLnVfY29sb3IsIFswLCAwLCAwLCAwLjVdKTtcclxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtQ291bnQpO1xyXG5cclxuICAgIC8vIFJldmVydCBibGVuZGluZyBtb2RlIHRvIGJsZW5kIHRvIHRoZSBiYWNrLlxyXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XHJcbn07XHJcblxyXG5HTFBhaW50ZXIucHJvdG90eXBlLnRyYW5zbGF0ZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgeiwgdHJhbnNsYXRlLCBhbmNob3IpIHtcclxuICAgIGlmICghdHJhbnNsYXRlWzBdICYmICF0cmFuc2xhdGVbMV0pIHJldHVybiBtYXRyaXg7XHJcblxyXG4gICAgaWYgKGFuY2hvciA9PT0gJ3ZpZXdwb3J0Jykge1xyXG4gICAgICAgIHZhciBzaW5fYSA9IE1hdGguc2luKC10aGlzLnRyYW5zZm9ybS5hbmdsZSk7XHJcbiAgICAgICAgdmFyIGNvc19hID0gTWF0aC5jb3MoLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcclxuICAgICAgICB0cmFuc2xhdGUgPSBbXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIGNvc19hIC0gdHJhbnNsYXRlWzFdICogc2luX2EsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIHNpbl9hICsgdHJhbnNsYXRlWzFdICogY29zX2FcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0aWxlUGl4ZWxSYXRpbyA9IHRoaXMudHJhbnNmb3JtLnNjYWxlIC8gKDEgPDwgeikgLyA4O1xyXG4gICAgdmFyIHRyYW5zbGF0aW9uID0gW1xyXG4gICAgICAgIHRyYW5zbGF0ZVswXSAvIHRpbGVQaXhlbFJhdGlvLFxyXG4gICAgICAgIHRyYW5zbGF0ZVsxXSAvIHRpbGVQaXhlbFJhdGlvLFxyXG4gICAgICAgIDBcclxuICAgIF07XHJcblxyXG4gICAgdmFyIHRyYW5zbGF0ZWRNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zbGF0ZWRNYXRyaXgsIG1hdHJpeCwgdHJhbnNsYXRpb24pO1xyXG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRNYXRyaXg7XHJcbn07XHJcblxyXG5HTFBhaW50ZXIucHJvdG90eXBlLnNhdmVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSkge1xyXG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5yZXVzYWJsZVRleHR1cmVzW3RleHR1cmUuc2l6ZV07XHJcbiAgICBpZiAoIXRleHR1cmVzKSB7XHJcbiAgICAgICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzW3RleHR1cmUuc2l6ZV0gPSBbdGV4dHVyZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuR0xQYWludGVyLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5yZXVzYWJsZVRleHR1cmVzW3NpemVdO1xyXG4gICAgcmV0dXJuIHRleHR1cmVzICYmIHRleHR1cmVzLmxlbmd0aCA+IDAgPyB0ZXh0dXJlcy5wb3AoKSA6IG51bGw7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpO1xyXG52YXIgbWF0NCA9IGdsbWF0cml4Lm1hdDQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZXJlbmRlcmVkVGV4dHVyZTtcclxuXHJcbmZ1bmN0aW9uIFByZXJlbmRlcmVkVGV4dHVyZShnbCwgYnVja2V0LCBwYWludGVyKSB7XHJcbiAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1Y2tldFsncmFzdGVyLWJ1ZmZlciddIHx8ICgxLzMyKTtcclxuICAgIHRoaXMuc2l6ZSA9IChidWNrZXRbJ3Jhc3Rlci1zaXplJ10gfHwgNTEyKSAqICgxICsgMiAqIHRoaXMuYnVmZmVyKTtcclxuICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcclxuICAgIHRoaXMuZmJvID0gbnVsbDtcclxuICAgIHRoaXMuZmJvcyA9IHRoaXMucGFpbnRlci5wcmVGYm9zW3RoaXMuc2l6ZV07XHJcbn1cclxuXHJcblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUuYmluZEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIC8vIHRyeSB0byByZXVzZSBhdmFpbGFibGUgcmFzdGVyIHRleHR1cmVzXHJcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLnBhaW50ZXIuZ2V0VGV4dHVyZSh0aGlzLnNpemUpO1xyXG5cclxuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLnNpemUgPSB0aGlzLnNpemU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmZib3MpIHtcclxuICAgICAgICB0aGlzLmZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgdmFyIHN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XHJcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLlNURU5DSUxfSU5ERVg4LCB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsKTtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5mYm9zLnBvcCgpO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLCAwKTtcclxuICAgIH1cclxufTtcclxuXHJcblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUudW5iaW5kRnJhbWVidWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgaWYgKHRoaXMuZmJvcykgdGhpcy5mYm9zLnB1c2godGhpcy5mYm8pOyBlbHNlIHRoaXMucGFpbnRlci5wcmVGYm9zW3RoaXMuc2l6ZV0gPSBbdGhpcy5mYm9dO1xyXG59O1xyXG5cclxuUHJlcmVuZGVyZWRUZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkgdGhyb3coJ3ByZS1yZW5kZXJlZCB0ZXh0dXJlIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcclxufTtcclxuXHJcblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uKHBhaW50ZXIsIHBhc3Nlcykge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIHZhciBvcmlnaW5hbFRleHR1cmUgPSB0aGlzLnRleHR1cmU7XHJcbiAgICB2YXIgc2Vjb25kYXJ5VGV4dHVyZSA9IHRoaXMucGFpbnRlci5nZXRUZXh0dXJlKHRoaXMuc2l6ZSk7XHJcbiAgICBpZiAoIXNlY29uZGFyeVRleHR1cmUpIHtcclxuICAgICAgICBzZWNvbmRhcnlUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHNlY29uZGFyeVRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy5zaXplLCB0aGlzLnNpemUsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgICAgIHNlY29uZGFyeVRleHR1cmUuc2l6ZSA9IHRoaXMuc2l6ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcclxuXHJcbiAgICB2YXIgbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgIG1hdDQub3J0aG8obWF0cml4LCAwLCA0MDk2LCAtNDA5NiwgMCwgMCwgMSk7XHJcbiAgICBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWzAsIC00MDk2LCAwXSk7XHJcblxyXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIsIG1hdHJpeCk7XHJcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgIGdsLnVuaWZvcm0xaShwYWludGVyLmdhdXNzaWFuU2hhZGVyLnVfaW1hZ2UsIDApO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFzc2VzOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIGhvcml6b250YWxcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHNlY29uZGFyeVRleHR1cmUsIDApO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZnYocGFpbnRlci5nYXVzc2lhblNoYWRlci51X29mZnNldCwgWzEgLyB0aGlzLnNpemUsIDBdKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcmlnaW5hbFRleHR1cmUpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5nYXVzc2lhblNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHJcblxyXG4gICAgICAgIC8vIFJlbmRlciB2ZXJ0aWNhbFxyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3JpZ2luYWxUZXh0dXJlLCAwKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC51bmlmb3JtMmZ2KHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIudV9vZmZzZXQsIFswLCAxIC8gdGhpcy5zaXplXSk7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmdhdXNzaWFuU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFpbnRlci5zYXZlVGV4dHVyZShzZWNvbmRhcnlUZXh0dXJlKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdsaWZ5ID0gdW5kZWZpbmVkO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcImRlYnVnXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBmbG9hdCB1X3BvaW50c2l6ZTtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLncgPSAxLjA7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdG1wdmFyXzEueiA9IGZsb2F0KChhX3Bvcy54ID49IDMyNzY3LjApKTtcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9pbnRTaXplID0gdV9wb2ludHNpemU7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblxcblwifSxcclxuICAgIFwiZG90XCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9pbnRTaXplID0gdV9zaXplO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG52b2lkIG1haW4gKClcXG57XFxuICBtZWRpdW1wIHZlYzIgeF8xO1xcbiAgeF8xID0gKGdsX1BvaW50Q29vcmQgLSAwLjUpO1xcbiAgbWVkaXVtcCBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgoXFxuICAgIHNxcnQoZG90ICh4XzEsIHhfMSkpXFxuICAgLSAwLjUpIC8gKFxcbiAgICAoMC41IC0gdV9ibHVyKVxcbiAgIC0gMC41KSksIDAuMCwgMS4wKTtcXG4gIGdsX0ZyYWdDb2xvciA9ICh1X2NvbG9yICogKHRtcHZhcl8yICogKHRtcHZhcl8yICogXFxuICAgICgzLjAgLSAoMi4wICogdG1wdmFyXzIpKVxcbiAgKSkpO1xcbn1cXG5cXG5cIn0sXHJcbiAgICBcImZpbGxcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb2ludFNpemUgPSAyLjA7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblxcblwifSxcclxuICAgIFwiZ2F1c3NpYW5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcbnZhcnlpbmcgaGlnaHAgdmVjMiBhWzNdO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIHZlYzQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1Bvc2l0aW9uID0gdG1wdmFyXzI7XFxuICBoaWdocCB2ZWMyIHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAoKHRtcHZhcl8yLnh5IC8gMi4wKSArIDAuNSk7XFxuICBhWzBdID0gdG1wdmFyXzM7XFxuICB2ZWMyIGNzZV80O1xcbiAgY3NlXzQgPSAodV9vZmZzZXQgKiAxLjE4MjQzKTtcXG4gIGFbMV0gPSAodG1wdmFyXzMgKyBjc2VfNCk7XFxuICBhWzJdID0gKHRtcHZhcl8zIC0gY3NlXzQpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiBhWzNdO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKCgodGV4dHVyZTJEICh1X2ltYWdlLCBhWzBdKSAqIDAuNDAyNjIpICsgKHRleHR1cmUyRCAodV9pbWFnZSwgYVsxXSkgKiAwLjI5ODY5KSkgKyAodGV4dHVyZTJEICh1X2ltYWdlLCBhWzJdKSAqIDAuMjk4NjkpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8xO1xcbn1cXG5cXG5cIn0sXHJcbiAgICBcImxpbmVcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIGZsb2F0IGFfbGluZXNvZmFyO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWMyIGNfMTtcXG4gIHZlYzIgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh2ZWMyKG1vZCAoYV9wb3MsIDIuMCkpKTtcXG4gIGNfMS54ID0gdG1wdmFyXzIueDtcXG4gIGNfMS55ID0gc2lnbigodG1wdmFyXzIueSAtIDAuNSkpO1xcbiAgYSA9IGNfMTtcXG4gIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMy56dyA9IHZlYzIoMC4wLCAwLjApO1xcbiAgdG1wdmFyXzMueHkgPSAoKHVfbGluZXdpZHRoLnggKiBhX2V4dHJ1ZGUpICogMC4wMTU4NzMpO1xcbiAgdmVjNCB0bXB2YXJfNDtcXG4gIHRtcHZhcl80Lnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfNC54eSA9IGZsb29yKChhX3BvcyAqIDAuNSkpO1xcbiAgZ2xfUG9zaXRpb24gPSAoKHVfbWF0cml4ICogdG1wdmFyXzQpICsgKHVfZXhtYXRyaXggKiB0bXB2YXJfMykpO1xcbiAgYiA9IChhX2xpbmVzb2ZhciAqIHVfcmF0aW8pO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWMyIHVfZGFzaGFycmF5O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKHNxcnQoZG90IChhLCBhKSkgKiB1X2xpbmV3aWR0aC54KTtcXG4gIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAoZmxvYXQobW9kIChiLCAodV9kYXNoYXJyYXkueCArIHVfZGFzaGFycmF5LnkpKSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gKHVfY29sb3IgKiAoY2xhbXAgKFxcbiAgICAobWluICgodG1wdmFyXzEgLSAodV9saW5ld2lkdGgueSAtIHVfYmx1cikpLCAodV9saW5ld2lkdGgueCAtIHRtcHZhcl8xKSkgLyB1X2JsdXIpXFxuICAsIDAuMCwgMS4wKSAqIG1heCAoXFxuICAgIGZsb2F0KCgtKHVfZGFzaGFycmF5LnkpID49IDAuMCkpXFxuICAsIFxcbiAgICBjbGFtcCAobWluICh0bXB2YXJfMiwgKHVfZGFzaGFycmF5LnggLSB0bXB2YXJfMikpLCAwLjAsIDEuMClcXG4gICkpKTtcXG59XFxuXFxuXCJ9LFxyXG4gICAgXCJsaW5lcGF0dGVyblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9saW5lc29mYXI7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgY18xO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHZlYzIobW9kIChhX3BvcywgMi4wKSkpO1xcbiAgY18xLnggPSB0bXB2YXJfMi54O1xcbiAgY18xLnkgPSBzaWduKCh0bXB2YXJfMi55IC0gMC41KSk7XFxuICBhID0gY18xO1xcbiAgdmVjNCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMy54eSA9IGZsb29yKChhX3BvcyAvIDIuMCkpO1xcbiAgdmVjNCB0bXB2YXJfNDtcXG4gIHRtcHZhcl80LncgPSAwLjA7XFxuICB0bXB2YXJfNC54eSA9ICgodV9saW5ld2lkdGgueCAqIChhX2V4dHJ1ZGUgLyA2My4wKSkgKiAoMS4wIC0gdV9wb2ludCkpO1xcbiAgdG1wdmFyXzQueiA9IChmbG9hdCgoYV9wb3MueCA+PSAzMjc2Ny4wKSkgKyAodV9wb2ludCAqIGZsb2F0KFxcbiAgICAoY18xLnkgPj0gMS4wKVxcbiAgKSkpO1xcbiAgZ2xfUG9zaXRpb24gPSAoKHVfbWF0cml4ICogdG1wdmFyXzMpICsgKHVfZXhtYXRyaXggKiB0bXB2YXJfNCkpO1xcbiAgYiA9IGFfbGluZXNvZmFyO1xcbiAgZ2xfUG9pbnRTaXplID0gKCgyLjAgKiB1X2xpbmV3aWR0aC54KSAtIDEuMCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemU7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyO1xcbnVuaWZvcm0gZmxvYXQgdV9wb2ludDtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgal8xO1xcbiAgbWVkaXVtcCB2ZWMyIHhfMjtcXG4gIHhfMiA9ICgoZ2xfUG9pbnRDb29yZCAqIDIuMCkgLSAxLjApO1xcbiAgbWVkaXVtcCBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCgoXFxuICAgIHNxcnQoZG90IChhLCBhKSlcXG4gICAqIFxcbiAgICAoMS4wIC0gdV9wb2ludClcXG4gICkgKyAodV9wb2ludCAqIFxcbiAgICBzcXJ0KGRvdCAoeF8yLCB4XzIpKVxcbiAgKSkgKiB1X2xpbmV3aWR0aC54KTtcXG4gIGZsb2F0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSAoZmxvYXQobW9kICgoYiAvIHVfcGF0dGVybl9zaXplLngpLCAxLjApKSk7XFxuICBmbG9hdCB0bXB2YXJfNTtcXG4gIHRtcHZhcl81ID0gKDAuNSArICgoYS55ICogdV9saW5ld2lkdGgueCkgLyB1X3BhdHRlcm5fc2l6ZS55KSk7XFxuICB2ZWMyIHRtcHZhcl82O1xcbiAgdG1wdmFyXzYueCA9IHRtcHZhcl80O1xcbiAgdG1wdmFyXzYueSA9IHRtcHZhcl81O1xcbiAgdmVjMiB0bXB2YXJfNztcXG4gIHRtcHZhcl83LnggPSAoZmxvYXQobW9kICgodG1wdmFyXzQgKiAyLjApLCAxLjApKSk7XFxuICB0bXB2YXJfNy55ID0gdG1wdmFyXzU7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzg7XFxuICB0bXB2YXJfOCA9ICgodGV4dHVyZTJEICh1X2ltYWdlLCBtaXggKHVfcGF0dGVybl90bCwgdV9wYXR0ZXJuX2JyLCB0bXB2YXJfNikpICogKDEuMCAtIHVfZmFkZSkpICsgKHVfZmFkZSAqIHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGwsIHVfcGF0dGVybl9iciwgdG1wdmFyXzcpKSkpO1xcbiAgal8xLncgPSB0bXB2YXJfOC53O1xcbiAgal8xLnh5eiA9ICh0bXB2YXJfOC54eXogKiB0bXB2YXJfOC53KTtcXG4gIGdsX0ZyYWdDb2xvciA9IChqXzEgKiBjbGFtcCAoKFxcbiAgICBtaW4gKCh0bXB2YXJfMyAtICh1X2xpbmV3aWR0aC55IC0gdV9ibHVyKSksICh1X2xpbmV3aWR0aC54IC0gdG1wdmFyXzMpKVxcbiAgIC8gdV9ibHVyKSwgMC4wLCAxLjApKTtcXG59XFxuXFxuXCJ9LFxyXG4gICAgXCJvdXRsaW5lXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3dvcmxkO1xcbnZhcnlpbmcgaGlnaHAgdmVjMiBhO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIHZlYzQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1Bvc2l0aW9uID0gdG1wdmFyXzI7XFxuICBhID0gKCgodG1wdmFyXzIueHkgKyAxLjApIC8gMi4wKSAqIHVfd29ybGQpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgYTtcXG52b2lkIG1haW4gKClcXG57XFxuICBoaWdocCB2ZWMyIHhfMTtcXG4gIHhfMSA9IChhIC0gZ2xfRnJhZ0Nvb3JkLnh5KTtcXG4gIGhpZ2hwIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSBjbGFtcCAoKChcXG4gICAgc3FydChkb3QgKHhfMSwgeF8xKSlcXG4gICAtIDEuMCkgLyAtMS4wKSwgMC4wLCAxLjApO1xcbiAgaGlnaHAgdmVjNCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKHVfY29sb3IgKiAodG1wdmFyXzIgKiAodG1wdmFyXzIgKiBcXG4gICAgKDMuMCAtICgyLjAgKiB0bXB2YXJfMikpXFxuICApKSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMztcXG59XFxuXFxuXCJ9LFxyXG4gICAgXCJwYXR0ZXJuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1X3BhdHRlcm5tYXRyaXg7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudmFyeWluZyB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICB2ZWMzIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIueiA9IDEuMDtcXG4gIHRtcHZhcl8yLnh5ID0gYV9wb3M7XFxuICBhID0gKHVfcGF0dGVybm1hdHJpeCAqIHRtcHZhcl8yKS54eTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWMyIHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodmVjMihtb2QgKGEsIDEuMCkpKTtcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKG1peCAodGV4dHVyZTJEICh1X2ltYWdlLCBtaXggKHVfcGF0dGVybl90bCwgdV9wYXR0ZXJuX2JyLCB0bXB2YXJfMSkpLCB0ZXh0dXJlMkQgKHVfaW1hZ2UsIG1peCAodV9wYXR0ZXJuX3RsLCB1X3BhdHRlcm5fYnIsIFxcbiAgICAodmVjMihtb2QgKCh0bXB2YXJfMSAqIDIuMCksIDEuMCkpKVxcbiAgKSksIHVfbWl4KSAqIHVfb3BhY2l0eSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMjtcXG59XFxuXFxuXCJ9LFxyXG4gICAgXCJyYXN0ZXJcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfdGxfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9zY2FsZV9wYXJlbnQ7XFxudW5pZm9ybSBmbG9hdCB1X2J1ZmZlcl9zY2FsZTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgdmVjMiBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKCgoXFxuICAgIChhX3RleHR1cmVfcG9zIC8gMzI3NjcuMClcXG4gICAtIDAuNSkgLyB1X2J1ZmZlcl9zY2FsZSkgKyAwLjUpO1xcbiAgYSA9IHRtcHZhcl8yO1xcbiAgYiA9ICgodG1wdmFyXzIgKiB1X3NjYWxlX3BhcmVudCkgKyB1X3RsX3BhcmVudCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTE7XFxudW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7XFxudW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTE7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyB2ZWMyIGI7XFxudW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKCh0ZXh0dXJlMkQgKHVfaW1hZ2UwLCBhKSAqIHVfb3BhY2l0eTApICsgKHRleHR1cmUyRCAodV9pbWFnZTEsIGIpICogdV9vcGFjaXR5MSkpO1xcbiAgbG93cCB2ZWMzIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIueCA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cyk7XFxuICB0bXB2YXJfMi55ID0gZG90ICh0bXB2YXJfMS54eXosIHVfc3Bpbl93ZWlnaHRzLnp4eSk7XFxuICB0bXB2YXJfMi56ID0gZG90ICh0bXB2YXJfMS54eXosIHVfc3Bpbl93ZWlnaHRzLnl6eCk7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMy54eXogPSBtaXggKHZlYzModV9icmlnaHRuZXNzX2xvdyksIHZlYzModV9icmlnaHRuZXNzX2hpZ2gpLCAoKFxcbiAgICAoKHRtcHZhcl8yICsgKChcXG4gICAgICAoKCh0bXB2YXJfMS54ICsgdG1wdmFyXzEueSkgKyB0bXB2YXJfMS56KSAvIDMuMClcXG4gICAgIC0gdG1wdmFyXzIpICogdV9zYXR1cmF0aW9uX2ZhY3RvcikpIC0gMC41KVxcbiAgICogdV9jb250cmFzdF9mYWN0b3IpICsgMC41KSk7XFxuICB0bXB2YXJfMy53ID0gdG1wdmFyXzEudztcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn0sXHJcbiAgICBcImljb25cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9taW56b29tO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX21heHpvb207XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VlbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VzdGFydDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9sYWJlbG1pbnpvb207XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9hbmdsZTtcXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmxpcDtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZWRpc3Q7XFxudW5pZm9ybSBmbG9hdCB1X21pbmZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXhmYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZmxvYXQgZF8xO1xcbiAgZF8xID0gMC4wO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IChmbG9hdChtb2QgKChhX2FuZ2xlICsgdV9hbmdsZSksIDI1Ni4wKSkpO1xcbiAgaWYgKCgoKHVfZmxpcCA+IDAuMCkgJiYgKHRtcHZhcl8yID49IDY0LjApKSAmJiAodG1wdmFyXzIgPCAxOTIuMCkpKSB7XFxuICAgIGRfMSA9IDEuMDtcXG4gIH07XFxuICBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCgoMi4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9taW56b29tKSlcXG4gICkgLSAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9tYXh6b29tKSlcXG4gICkpICsgZF8xKTtcXG4gIGZsb2F0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSBjbGFtcCAoKCh1X2ZhZGV6b29tIC0gYV9sYWJlbG1pbnpvb20pIC8gdV9mYWRlZGlzdCksIDAuMCwgMS4wKTtcXG4gIGlmICgodV9mYWRlZGlzdCA+PSAwLjApKSB7XFxuICAgIGIgPSB0bXB2YXJfNDtcXG4gIH0gZWxzZSB7XFxuICAgIGIgPSAoMS4wIC0gdG1wdmFyXzQpO1xcbiAgfTtcXG4gIGlmICgodV9tYXhmYWRlem9vbSA8IGFfbGFiZWxtaW56b29tKSkge1xcbiAgICBiID0gMC4wO1xcbiAgfTtcXG4gIGlmICgodV9taW5mYWRlem9vbSA+PSBhX2xhYmVsbWluem9vbSkpIHtcXG4gICAgYiA9IDEuMDtcXG4gIH07XFxuICB2ZWM0IHRtcHZhcl81O1xcbiAgdG1wdmFyXzUuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl81Lnh5ID0gYV9wb3M7XFxuICB2ZWM0IHRtcHZhcl82O1xcbiAgdG1wdmFyXzYudyA9IDAuMDtcXG4gIHRtcHZhcl82Lnh5ID0gKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICB0bXB2YXJfNi56ID0gKCh0bXB2YXJfMyArIGZsb2F0KFxcbiAgICAoMC4wID49IGIpXFxuICApKSArIChmbG9hdChcXG4gICAgKHVfYW5nbGUgPj0gYV9yYW5nZWVuZClcXG4gICkgKiAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X2FuZ2xlID49IGFfcmFuZ2VzdGFydCkpXFxuICApKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICgodV9tYXRyaXggKiB0bXB2YXJfNSkgKyAodV9leG1hdHJpeCAqIHRtcHZhcl82KSk7XFxuICBhID0gKGFfdGV4IC8gdV90ZXhzaXplKTtcXG4gIGIgPSAoYiAqIHVfb3BhY2l0eSk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodGV4dHVyZTJEICh1X3RleHR1cmUsIGEpICogYik7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMTtcXG59XFxuXFxuXCJ9LFxyXG4gICAgXCJzZGZcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9taW56b29tO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX21heHpvb207XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VlbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VzdGFydDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9sYWJlbG1pbnpvb207XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9hbmdsZTtcXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmxpcDtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZWRpc3Q7XFxudW5pZm9ybSBmbG9hdCB1X21pbmZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXhmYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZXpvb207XFxudW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZmxvYXQgY18xO1xcbiAgY18xID0gMC4wO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IChmbG9hdChtb2QgKChhX2FuZ2xlICsgdV9hbmdsZSksIDI1Ni4wKSkpO1xcbiAgaWYgKCgoKHVfZmxpcCA+IDAuMCkgJiYgKHRtcHZhcl8yID49IDY0LjApKSAmJiAodG1wdmFyXzIgPCAxOTIuMCkpKSB7XFxuICAgIGNfMSA9IDEuMDtcXG4gIH07XFxuICBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCgoMi4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9taW56b29tKSlcXG4gICkgLSAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9tYXh6b29tKSlcXG4gICkpICsgY18xKTtcXG4gIGZsb2F0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSBjbGFtcCAoKCh1X2ZhZGV6b29tIC0gYV9sYWJlbG1pbnpvb20pIC8gdV9mYWRlZGlzdCksIDAuMCwgMS4wKTtcXG4gIGlmICgodV9mYWRlZGlzdCA+PSAwLjApKSB7XFxuICAgIGIgPSB0bXB2YXJfNDtcXG4gIH0gZWxzZSB7XFxuICAgIGIgPSAoMS4wIC0gdG1wdmFyXzQpO1xcbiAgfTtcXG4gIGlmICgodV9tYXhmYWRlem9vbSA8IGFfbGFiZWxtaW56b29tKSkge1xcbiAgICBiID0gMC4wO1xcbiAgfTtcXG4gIGlmICgodV9taW5mYWRlem9vbSA+PSBhX2xhYmVsbWluem9vbSkpIHtcXG4gICAgYiA9IDEuMDtcXG4gIH07XFxuICB2ZWM0IHRtcHZhcl81O1xcbiAgdG1wdmFyXzUuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl81Lnh5ID0gYV9wb3M7XFxuICB2ZWM0IHRtcHZhcl82O1xcbiAgdG1wdmFyXzYudyA9IDAuMDtcXG4gIHRtcHZhcl82Lnh5ID0gKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICB0bXB2YXJfNi56ID0gKCh0bXB2YXJfMyArIGZsb2F0KFxcbiAgICAoMC4wID49IGIpXFxuICApKSArIChmbG9hdChcXG4gICAgKHVfYW5nbGUgPj0gYV9yYW5nZWVuZClcXG4gICkgKiAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X2FuZ2xlID49IGFfcmFuZ2VzdGFydCkpXFxuICApKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICgodV9tYXRyaXggKiB0bXB2YXJfNSkgKyAodV9leG1hdHJpeCAqIHRtcHZhcl82KSk7XFxuICBhID0gKGFfdGV4IC8gdV90ZXhzaXplKTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXI7XFxudW5pZm9ybSBmbG9hdCB1X2dhbW1hO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCBlZGdlMF8xO1xcbiAgZWRnZTBfMSA9ICh1X2J1ZmZlciAtIHVfZ2FtbWEpO1xcbiAgbG93cCBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgodGV4dHVyZTJEICh1X3RleHR1cmUsIGEpLncgLSBlZGdlMF8xKSAvIChcXG4gICAgKHVfYnVmZmVyICsgdV9nYW1tYSlcXG4gICAtIGVkZ2UwXzEpKSwgMC4wLCAxLjApO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodV9jb2xvciAqICgodG1wdmFyXzIgKiBcXG4gICAgKHRtcHZhcl8yICogKDMuMCAtICgyLjAgKiB0bXB2YXJfMikpKVxcbiAgKSAqIGIpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlLmpzJyk7XHJcbnZhciBHZW9KU09OVGlsZSA9IHJlcXVpcmUoJy4vZ2VvanNvbnRpbGUuanMnKTtcclxuXHJcbnZhciBHZW9KU09OU291cmNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB0aGlzLnRpbGVzID0ge307XHJcbiAgICB0aGlzLmFsbHRpbGVzID0ge307XHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuem9vbXMgPSBbMSwgNSwgOSwgMTNdO1xyXG4gICAgdGhpcy5taW5UaWxlWm9vbSA9IHRoaXMuem9vbXNbMF07XHJcbiAgICB0aGlzLm1heFRpbGVab29tID0gdGhpcy56b29tc1t0aGlzLnpvb21zLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIHRoaXMubG9hZE5ld1RpbGVzID0gdHJ1ZTtcclxuICAgIHRoaXMudGlsZUpTT04gPSB7XHJcbiAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICBtYXhab29tOiAxM1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbn07XHJcblxyXG5HZW9KU09OU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5HZW9KU09OU291cmNlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5fdXBkYXRlRGF0YSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5HZW9KU09OU291cmNlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uKG1hcCkge1xyXG4gICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICB0aGlzLnBhaW50ZXIgPSBtYXAucGFpbnRlcjtcclxuXHJcbiAgICBpZiAodGhpcy5tYXAuc3R5bGUpIHRoaXMuX3VwZGF0ZURhdGEoKTtcclxuICAgIG1hcC5vbignc3R5bGUuY2hhbmdlJywgdGhpcy5fdXBkYXRlRGF0YS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkdlb0pTT05Tb3VyY2UucHJvdG90eXBlLl91cGRhdGVEYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHRoaXMud29ya2VySUQgPSB0aGlzLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ3BhcnNlIGdlb2pzb24nLCB7XHJcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgICAgIHpvb21zOiB0aGlzLnpvb21zLFxyXG4gICAgICAgIHRpbGVTaXplOiA1MTIsXHJcbiAgICAgICAgc291cmNlOiB0aGlzLmlkXHJcbiAgICB9LCBmdW5jdGlvbihlcnIsIHRpbGVzKSB7XHJcbiAgICAgICAgaWYgKGVycikgcmV0dXJuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc291cmNlLmFsbHRpbGVzW3RpbGVzW2ldLmlkXSA9IG5ldyBHZW9KU09OVGlsZSh0aWxlc1tpXS5pZCwgc291cmNlLCB0aWxlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzb3VyY2UubWFwKSBzb3VyY2UubWFwLnVwZGF0ZSgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkdlb0pTT05Tb3VyY2UucHJvdG90eXBlLl9hZGRUaWxlID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHZhciB0aWxlID0gdGhpcy5hbGx0aWxlc1tpZF07XHJcbiAgICBpZiAodGlsZSkge1xyXG4gICAgICAgIHRpbGUuX2xvYWQoKTtcclxuICAgICAgICB0aGlzLnRpbGVzW2lkXSA9IHRpbGU7XHJcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmFkZCcsIHt0aWxlOiB0aWxlfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlsZSB8fCB7fTtcclxufTtcclxuXHJcbkdlb0pTT05Tb3VyY2UucHJvdG90eXBlLl9jb3ZlcmluZ1pvb21MZXZlbCA9IGZ1bmN0aW9uKHpvb20pIHtcclxuICAgIGZvciAodmFyIGkgPSB0aGlzLnpvb21zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuem9vbXNbaV0gPD0gem9vbSkge1xyXG4gICAgICAgICAgICB2YXIgeiA9IHRoaXMuem9vbXNbaV07XHJcbiAgICAgICAgICAgIHJldHVybiB6O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZS5qcycpO1xyXG52YXIgQnVmZmVyU2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzJyk7XHJcbnZhciBjcmVhdGVCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2NyZWF0ZWJ1Y2tldC5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OVGlsZTtcclxuXHJcbmZ1bmN0aW9uIEdlb0pTT05UaWxlKGlkLCBzb3VyY2UsIGRhdGEpIHtcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMud29ya2VySUQgPSBzb3VyY2Uud29ya2VySUQ7XHJcbn1cclxuXHJcbkdlb0pTT05UaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGlsZS5wcm90b3R5cGUpO1xyXG5cclxuR2VvSlNPTlRpbGUucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5sb2FkZWQpIHJldHVybjtcclxuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHRoaXMuYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoZGF0YS5idWZmZXJzKTtcclxuXHJcbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcclxuICAgIGZvciAodmFyIGIgaW4gZGF0YS5lbGVtZW50R3JvdXBzKSB7XHJcbiAgICAgICAgdGhpcy5idWNrZXRzW2JdID0gY3JlYXRlQnVja2V0KHRoaXMuc291cmNlLm1hcC5zdHlsZS5idWNrZXRzW2JdLCB0aGlzLmJ1ZmZlcnMsIHVuZGVmaW5lZCwgZGF0YS5lbGVtZW50R3JvdXBzW2JdKTtcclxuICAgIH1cclxuXHJcblxyXG59O1xyXG5cclxuLy8gbm9vcHNcclxuR2VvSlNPTlRpbGUucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7IH07XHJcbkdlb0pTT05UaWxlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHsgfTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwcGVyO1xyXG5cclxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxyXG5mdW5jdGlvbiBXcmFwcGVyKGZlYXR1cmVzKSB7XHJcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XHJcbiAgICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aDtcclxufVxyXG5cclxuV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSk7XHJcbn07XHJcblxyXG52YXIgbWFwcGluZyA9IHtcclxuICAgICdQb2ludCc6IDEsXHJcbiAgICAnTGluZVN0cmluZyc6IDIsXHJcbiAgICAnUG9seWdvbic6IDNcclxufTtcclxuXHJcbmZ1bmN0aW9uIEZlYXR1cmVXcmFwcGVyKGZlYXR1cmUpIHtcclxuICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XHJcbiAgICB0aGlzLnR5cGUgPSBtYXBwaW5nW2ZlYXR1cmUudHlwZV07XHJcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XHJcbn1cclxuXHJcbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmZlYXR1cmUuY29vcmRzO1xyXG59O1xyXG5cclxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBpZiAodGhpcy50eXBlID09PSBtYXBwaW5nLlBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS54LFxyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuY29vcmRzWzBdWzBdLnksXHJcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5jb29yZHNbMF1bMF0ueCxcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmNvb3Jkc1swXVswXS55XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmluZ3MgPSB0aGlzLmZlYXR1cmUuY29vcmRzO1xyXG5cclxuICAgIHZhciB4MSA9IEluZmluaXR5LFxyXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxyXG4gICAgICAgIHkxID0gSW5maW5pdHksXHJcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSByaW5nW2pdO1xyXG5cclxuICAgICAgICAgICAgeDEgPSBNYXRoLm1pbih4MSwgY29vcmQueCk7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5tYXgoeDIsIGNvb3JkLngpO1xyXG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHkxLCBjb29yZC55KTtcclxuICAgICAgICAgICAgeTIgPSBNYXRoLm1heCh5MiwgY29vcmQueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZS5qcycpO1xyXG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYXN0ZXJUaWxlO1xyXG5cclxuZnVuY3Rpb24gUmFzdGVyVGlsZShpZCwgc291cmNlLCB1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuICAgIHRoaXMuX2xvYWQoKTtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMudXNlcyA9IDE7XHJcblxyXG4gICAgLy8gVG9kbyBmaW5pc2ggZmlndXJpbmcgb3V0IHdoYXQgcmFzdGVyIGJ1Y2tldHMgYXJlXHJcbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcclxuICAgIHRoaXMuaW5mbyA9IHsgcmFzdGVyOiB0cnVlIH07XHJcbiAgICB2YXIgYnVja2V0cyA9IHRoaXMubWFwLnN0eWxlLmJ1Y2tldHM7XHJcbiAgICBmb3IgKHZhciBiIGluIGJ1Y2tldHMpIHtcclxuICAgICAgICB2YXIgYnVja2V0ID0gYnVja2V0c1tiXTtcclxuICAgICAgICB2YXIgc291cmNlaWQgPSBidWNrZXQgJiYgYnVja2V0LnNvdXJjZTtcclxuICAgICAgICBpZiAoc291cmNlLmlkID09PSBzb3VyY2VpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHNbYl0gPSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvOiBidWNrZXQucmVuZGVyLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jhc3RlcicsXHJcbiAgICAgICAgICAgICAgICB0aWxlOiB0aGlzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5SYXN0ZXJUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGlsZS5wcm90b3R5cGUpO1xyXG5cclxuUmFzdGVyVGlsZS5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aWxlID0gdGhpcztcclxuICAgIGFqYXguZ2V0SW1hZ2UodGhpcy51cmwsIGZ1bmN0aW9uKGVyciwgaW1nKSB7XHJcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycy5cclxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XHJcbiAgICAgICAgdGlsZS5pbWcgPSBpbWc7XHJcbiAgICAgICAgaWYgKHRpbGUubWFwKSB0aWxlLm9uVGlsZUxvYWQoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuUmFzdGVyVGlsZS5wcm90b3R5cGUub25UaWxlTG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gc3RhcnQgdGV4dHVyZSB1cGxvYWRcclxuICAgIHRoaXMuYmluZCh0aGlzLm1hcC5wYWludGVyLmdsKTtcclxuXHJcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICB0aGlzLmNhbGxiYWNrKCk7XHJcbn07XHJcblxyXG5SYXN0ZXJUaWxlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcclxuICAgIGlmICh0aGlzLmltZykgdGhpcy5pbWcuc3JjID0gJyc7XHJcbiAgICBkZWxldGUgdGhpcy5pbWc7XHJcbn07XHJcblxyXG5SYXN0ZXJUaWxlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcclxuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGZpbmQgcmV1c2FibGUgdGV4dHVyZVxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMubWFwLnBhaW50ZXIuZ2V0VGV4dHVyZSh0aGlzLmltZy53aWR0aCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xyXG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1nKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLnNpemUgPSB0aGlzLmltZy53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5SYXN0ZXJUaWxlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLnRleHR1cmUpIHRoaXMubWFwLnBhaW50ZXIuc2F2ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcclxuICAgIGRlbGV0ZSB0aGlzLm1hcDtcclxufTtcclxuXHJcblJhc3RlclRpbGUucHJvdG90eXBlLmZlYXR1cmVzQXQgPSBmdW5jdGlvbihwb3MsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgIC8vIG5vb3BcclxuICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcclxuICAgIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKSxcclxuICAgIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94LmpzJykubm9ybWFsaXplU291cmNlVVJMLFxyXG4gICAgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpLFxyXG4gICAgQ2FjaGUgPSByZXF1aXJlKCcuLi91dGlsL21ydWNhY2hlLmpzJyksXHJcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVjb29yZCcpLFxyXG4gICAgVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZScpLFxyXG4gICAgUmFzdGVyVGlsZSA9IHJlcXVpcmUoJy4vcmFzdGVydGlsZS5qcycpLFxyXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2U7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2Uob3B0aW9ucykge1xyXG4gICAgdGhpcy50aWxlcyA9IHt9O1xyXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICBpZiAodGhpcy50eXBlID09PSAndmVjdG9yJyAmJiBvcHRpb25zLnRpbGVTaXplICYmIG9wdGlvbnMudGlsZVNpemUgIT09IDUxMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcclxuICAgIH1cclxuICAgIHRoaXMuVGlsZSA9IHRoaXMudHlwZSA9PT0gJ3ZlY3RvcicgPyBWZWN0b3JUaWxlIDogUmFzdGVyVGlsZTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuaW5oZXJpdCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZSh0aGlzLm9wdGlvbnMuY2FjaGVTaXplLCBmdW5jdGlvbih0aWxlKSB7XHJcbiAgICAgICAgdGlsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHRpbGVKU09OKSB7XHJcbiAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xyXG5cclxuICAgICAgICBpZiAoIXRpbGVKU09OLnRpbGVzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdGlsZXMgcHJvcGVydHknKTtcclxuXHJcbiAgICAgICAgdGhpcy50aWxlSlNPTiA9IHV0aWwuZXh0ZW5kKHsgbWluem9vbTogMCwgbWF4em9vbTogMjIgfSwgdGlsZUpTT04pO1xyXG4gICAgICAgIHRoaXMubG9hZE5ld1RpbGVzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlyZSgnc291cmNlLmFkZCcsIHtzb3VyY2U6IHRoaXN9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy51cmwpIHtcclxuICAgICAgICBhamF4LmdldEpTT04obm9ybWFsaXplVVJMKG9wdGlvbnMudXJsKSwgbG9hZGVkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9hZGVkKG51bGwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVRpbGVzID0gdXRpbC50aHJvdHRsZSh0aGlzLl91cGRhdGVUaWxlcywgNTAsIHRoaXMpO1xyXG59XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgICB0aWxlU2l6ZTogNTEyLFxyXG4gICAgICAgIGNhY2hlU2l6ZTogMjBcclxuICAgIH0sXHJcblxyXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xyXG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgICAgIHRoaXMucGFpbnRlciA9IG1hcC5wYWludGVyO1xyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlc1t0XS5fbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbGVzW3RdLmxvYWRlZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICB0aGlzLl91cGRhdGVUaWxlcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGxheWVycykge1xyXG4gICAgICAgIC8vIEl0ZXJhdGl2ZWx5IHBhaW50IGV2ZXJ5IHRpbGUuXHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICB2YXIgb3JkZXIgPSBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKTtcclxuICAgICAgICBvcmRlci5zb3J0KHRoaXMuX3pfb3JkZXIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gb3JkZXJbaV07XHJcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1tpZF07XHJcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAmJiAhdGhpcy5jb3ZlcmVkVGlsZXNbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUaWxlKHRpbGUsIGlkLCBsYXllcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHBvaW50ID0gUG9pbnQuY29udmVydChwb2ludCk7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbXMubGF5ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5tYXAuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICBsYXllciA9IHN0eWxlLmdldExheWVyKHBhcmFtcy5sYXllcik7XHJcbiAgICAgICAgICAgIHBhcmFtcy5idWNrZXQgPSBzdHlsZS5idWNrZXRzW2xheWVyLnJlZiB8fCBsYXllci5pZF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3JkZXIgPSBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKTtcclxuICAgICAgICBvcmRlci5zb3J0KHRoaXMuX3pfb3JkZXIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gb3JkZXJbaV07XHJcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1tpZF07XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aWxlLnBvc2l0aW9uQXQoaWQsIHBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb3MgJiYgcG9zLnggPj0gMCAmJiBwb3MueCA8IDQwOTYgJiYgcG9zLnkgPj0gMCAmJiBwb3MueSA8IDQwOTYpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjbGljayBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0LiBUaGVyZSBpcyBvbmx5IGV2ZXIgb25lIHRpbGUgaW5cclxuICAgICAgICAgICAgICAgIC8vIGEgbGF5ZXIgdGhhdCBoYXMgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLmZlYXR1cmVzQXQocG9zLCBwYXJhbXMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBnZXQgdGhlIHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIG1hcCBhbmQgc291cmNlIHRpbGVzaXplc1xyXG4gICAgX2dldFpvb206IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB6T2Zmc2V0ID0gTWF0aC5sb2codGhpcy5tYXAudHJhbnNmb3JtLnRpbGVTaXplL3RoaXMub3B0aW9ucy50aWxlU2l6ZSkgLyBNYXRoLkxOMjtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAudHJhbnNmb3JtLnpvb20gKyB6T2Zmc2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBfY292ZXJpbmdab29tTGV2ZWw6IGZ1bmN0aW9uKHpvb20pIHtcclxuICAgICAgICBmb3IgKHZhciB6ID0gdGhpcy50aWxlSlNPTi5tYXh6b29tOyB6ID49IHRoaXMudGlsZUpTT04ubWluem9vbTsgei0tKSB7XHJcbiAgICAgICAgICAgIGlmICh6IDw9IHpvb20pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYXN0ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdW5kZXJzY2FsaW5nIGJ5IHJvdW5kaW5nIHRvIHRoZSBuZWFyZXN0IHpvb20gbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeiA8IHRoaXMudGlsZUpTT04ubWF4em9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6ICs9IE1hdGgucm91bmQoem9vbSAtIHopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2hpbGRab29tTGV2ZWw6IGZ1bmN0aW9uKHpvb20pIHtcclxuICAgICAgICB6b29tID0gTWF0aC5tYXgodGhpcy50aWxlSlNPTi5taW56b29tLCB6b29tICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHpvb20gPD0gdGhpcy50aWxlSlNPTi5tYXh6b29tID8gem9vbSA6IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRDb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbih6b29tKSB7XHJcbiAgICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkgem9vbSA9IHRoaXMuX2dldFpvb20oKTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuX2NvdmVyaW5nWm9vbUxldmVsKHpvb20pLFxyXG4gICAgICAgICAgICB0aWxlcyA9IDEgPDwgeixcclxuICAgICAgICAgICAgdHIgPSB0aGlzLm1hcC50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIHRpbGVDZW50ZXIgPSBUaWxlQ29vcmQuem9vbVRvKHRyLmxvY2F0aW9uQ29vcmRpbmF0ZSh0ci5jZW50ZXIpLCB6KTtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUodGlsZUNlbnRlciwge3g6IDAsIHk6IDB9KSwgeiksXHJcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKHRpbGVDZW50ZXIsIHt4OiB0ci53aWR0aCwgeTogMH0pLCB6KSxcclxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUodGlsZUNlbnRlciwge3g6IHRyLndpZHRoLCB5OiB0ci5oZWlnaHR9KSwgeiksXHJcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKHRpbGVDZW50ZXIsIHt4OiAwLCB5OiB0ci5oZWlnaHR9KSwgeilcclxuICAgICAgICBdLCB0ID0ge307XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSB0aGUgc2NyZWVuIHVwIGluIHR3byB0cmlhbmdsZXMgYW5kIHNjYW4gZWFjaCBvZiB0aGVtOlxyXG4gICAgICAgIC8vICstLS0vXHJcbiAgICAgICAgLy8gfCAvIHxcclxuICAgICAgICAvLyAvLS0tK1xyXG4gICAgICAgIHRoaXMuX3NjYW5UcmlhbmdsZShwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xyXG4gICAgICAgIHRoaXMuX3NjYW5UcmlhbmdsZShwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzBdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModCkuc29ydChmcm9tQ2VudGVyKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZnJvbUNlbnRlcihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBhZCA9IE1hdGguYWJzKGEueCAtIHRpbGVDZW50ZXIuY29sdW1uKSArXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYS55IC0gdGlsZUNlbnRlci5yb3cpLFxyXG4gICAgICAgICAgICAgICAgYmQgPSBNYXRoLmFicyhiLnggLSB0aWxlQ2VudGVyLmNvbHVtbikgK1xyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGIueSAtIHRpbGVDZW50ZXIucm93KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhZCAtIGJkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2NhbkxpbmUoeDAsIHgxLCB5KSB7XHJcbiAgICAgICAgICAgIHZhciB4LCB3eDtcclxuICAgICAgICAgICAgaWYgKHkgPj0gMCAmJiB5IDw9IHRpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB3eCA9ICh4ICsgdGlsZXMpICUgdGlsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdFtUaWxlQ29vcmQudG9JRCh6LCB3eCwgeSwgTWF0aC5mbG9vcih4L3RpbGVzKSldID0ge3g6IHd4LCB5OiB5fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2l2ZW4gYSB0aWxlIG9mIGRhdGEsIGl0cyBpZCwgYW5kIGEgc3R5bGUgbGF5ZXJzLCByZW5kZXIgdGhlIHRpbGUgdG8gdGhlIGNhbnZhc1xyXG4gICAgX3JlbmRlclRpbGU6IGZ1bmN0aW9uKHRpbGUsIGlkLCBsYXllcnMpIHtcclxuICAgICAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XHJcbiAgICAgICAgdmFyIHogPSBwb3MueiwgeCA9IHBvcy54LCB5ID0gcG9zLnksIHcgPSBwb3MudztcclxuICAgICAgICB4ICs9IHcgKiAoMSA8PCB6KTtcclxuXHJcbiAgICAgICAgdGlsZS5jYWxjdWxhdGVNYXRyaWNlcyh6LCB4LCB5LCB0aGlzLm1hcC50cmFuc2Zvcm0sIHRoaXMucGFpbnRlcik7XHJcblxyXG4gICAgICAgIHRoaXMucGFpbnRlci5kcmF3KHRpbGUsIHRoaXMubWFwLnN0eWxlLCBsYXllcnMsIHtcclxuICAgICAgICAgICAgejogeiwgeDogeCwgeTogeSxcclxuICAgICAgICAgICAgZGVidWc6IHRoaXMubWFwLmRlYnVnLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXNpbmc6IHRoaXMubWFwLmFudGlhbGlhc2luZyxcclxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMubWFwLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICByb3RhdGluZzogdGhpcy5tYXAucm90YXRpbmcsXHJcbiAgICAgICAgICAgIHpvb21pbmc6IHRoaXMubWFwLnpvb21pbmdcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVjdXJzaXZlbHkgZmluZCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWF4Q292ZXJpbmdab29tKSB0aGF0IGFyZSBhbHJlYWR5IGxvYWRlZDtcclxuICAgIC8vIGFkZHMgZm91bmQgdGlsZXMgdG8gcmV0YWluIG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIGNoaWxkcmVuIGNvbXBsZXRlbHkgY292ZXIgdGhlIHRpbGVcclxuXHJcbiAgICBfZmluZExvYWRlZENoaWxkcmVuOiBmdW5jdGlvbihpZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pIHtcclxuICAgICAgICB2YXIgY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIHZhciB6ID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcclxuICAgICAgICB2YXIgaWRzID0gVGlsZUNvb3JkLmNoaWxkcmVuKGlkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1tpZHNbaV1dICYmIHRoaXMudGlsZXNbaWRzW2ldXS5sb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldGFpbltpZHNbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoeiA8IG1heENvdmVyaW5nWm9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIGZ1cnRoZXIgZG93biB0aGUgaGllcmFyY2h5IHRvIGZpbmQgbW9yZSB1bmxvYWRlZCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5kTG9hZGVkQ2hpbGRyZW4oaWRzW2ldLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGaW5kIGEgbG9hZGVkIHBhcmVudCBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWluQ292ZXJpbmdab29tKTtcclxuICAgIC8vIGFkZHMgdGhlIGZvdW5kIHRpbGUgdG8gcmV0YWluIG9iamVjdCBhbmQgcmV0dXJucyB0cnVlIGlmIGEgcGFyZW50IHdhcyBmb3VuZFxyXG5cclxuICAgIF9maW5kTG9hZGVkUGFyZW50OiBmdW5jdGlvbihpZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pIHtcclxuICAgICAgICBmb3IgKHZhciB6ID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejsgeiA+PSBtaW5Db3ZlcmluZ1pvb207IHotLSkge1xyXG4gICAgICAgICAgICBpZCA9IFRpbGVDb29yZC5wYXJlbnQoaWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1tpZF0gJiYgdGhpcy50aWxlc1tpZF0ubG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVtb3ZlcyB0aWxlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgYWRkcyBuZXcgdGlsZXMgdGhhdCBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cclxuICAgIF91cGRhdGVUaWxlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hcCB8fCAhdGhpcy5tYXAubG9hZE5ld1RpbGVzIHx8ICF0aGlzLmxvYWROZXdUaWxlcyB8fFxyXG4gICAgICAgICAgICAhdGhpcy5tYXAuc3R5bGUgfHwgIXRoaXMubWFwLnN0eWxlLnNvdXJjZXMgfHwgIXRoaXMubWFwLnN0eWxlLnNvdXJjZXNbdGhpcy5pZF0pIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHpvb20gPSBNYXRoLmZsb29yKHRoaXMuX2dldFpvb20oKSk7XHJcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdGhpcy5fZ2V0Q292ZXJpbmdUaWxlcygpLnNvcnQodGhpcy5fY2VudGVyT3V0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICB2YXIgY29tcGxldGU7XHJcbiAgICAgICAgdmFyIHRpbGU7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgb3Zlcnpvb21pbmcvdW5kZXJ6b29taW5nIGFtb3VudHMuXHJcbiAgICAgICAgdmFyIG1pbkNvdmVyaW5nWm9vbSA9IE1hdGgubWF4KHRoaXMudGlsZUpTT04ubWluem9vbSwgem9vbSAtIDEwKTtcclxuICAgICAgICB2YXIgbWF4Q292ZXJpbmdab29tID0gdGhpcy50aWxlSlNPTi5taW56b29tO1xyXG4gICAgICAgIHdoaWxlIChtYXhDb3ZlcmluZ1pvb20gPCB6b29tICsgMSkge1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9jaGlsZFpvb21MZXZlbChtYXhDb3ZlcmluZ1pvb20pO1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPT09IG51bGwpIGJyZWFrO1xyXG4gICAgICAgICAgICBlbHNlIG1heENvdmVyaW5nWm9vbSA9IGxldmVsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0YWluIGlzIGEgbGlzdCBvZiB0aWxlcyB0aGF0IHdlIHNob3VsZG4ndCBkZWxldGUsIGV2ZW4gaWYgdGhleSBhcmUgbm90XHJcbiAgICAgICAgLy8gdGhlIG1vc3QgaWRlYWwgdGlsZSBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgbWF5IGluY2x1ZGUgdGlsZXMgbGlrZVxyXG4gICAgICAgIC8vIHBhcmVudCBvciBjaGlsZCB0aWxlcyB0aGF0IGFyZSAqYWxyZWFkeSogbG9hZGVkLlxyXG4gICAgICAgIHZhciByZXRhaW4gPSB7fTtcclxuICAgICAgICAvLyBDb3ZlcmVkIGlzIGEgbGlzdCBvZiByZXRhaW5lZCB0aWxlcyB3aG8ncyBhcmVhcyBhcmUgZnVsbCBjb3ZlcmVkIGJ5IG90aGVyLFxyXG4gICAgICAgIC8vIGJldHRlciwgcmV0YWluZWQgdGlsZXMuIFRoZXkgYXJlIG5vdCBkcmF3biBzZXBhcmF0ZWx5LlxyXG4gICAgICAgIHRoaXMuY292ZXJlZFRpbGVzID0ge307XHJcblxyXG4gICAgICAgIHZhciBmdWxseUNvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGV4aXN0aW5nIGNoaWxkL3BhcmVudCB0aWxlcyBpZiB0aGUgYWN0dWFsIHRpbGUgaXMgbm90IHlldCBsb2FkZWRcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWQgPSArcmVxdWlyZWRbaV07XHJcbiAgICAgICAgICAgIHJldGFpbltpZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fYWRkVGlsZShpZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRpbGUubG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGlsZSB3ZSByZXF1aXJlIGlzIG5vdCB5ZXQgbG9hZGVkLiBUcnkgdG8gZmluZCBhIHBhcmVudCBvclxyXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdGlsZSB0aGF0IHdlIGFscmVhZHkgaGF2ZS5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIGZpbmQgZXhpc3RpbmcgY2hpbGQgdGlsZXMgdGhhdCBjb21wbGV0ZWx5IGNvdmVyIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbWlzc2luZyB0aWxlLlxyXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB0aGlzLl9maW5kTG9hZGVkQ2hpbGRyZW4oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVuLCBpZiB0aGVyZSBhcmUgbm8gY29tcGxldGUgY2hpbGQgdGlsZXMsIHRyeSB0byBmaW5kIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgdGlsZXMgdGhhdCBjb21wbGV0ZWx5IGNvdmVyIHRoZSBtaXNzaW5nIHRpbGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSB0aGlzLl9maW5kTG9hZGVkUGFyZW50KGlkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVubG9hZGVkIHRpbGUncyBhcmVhIGlzIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgbG9hZGVkIHRpbGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsbHlDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdmFyIGZhZGVEdXJhdGlvbiA9IHRoaXMudHlwZSA9PT0gJ3Jhc3RlcicgPyB0aGlzLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24gOiAwO1xyXG5cclxuICAgICAgICBmb3IgKGlkIGluIHJldGFpbikge1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF07XHJcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUudGltZUFkZGVkID4gbm93IC0gZmFkZUR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbGUgaXMgc3RpbGwgZmFkaW5nIGluLiBGaW5kIHRpbGVzIHRvIGNyb3NzLWZhZGUgd2l0aCBpdC5cclxuXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHRoaXMuX2ZpbmRMb2FkZWRDaGlsZHJlbihpZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY292ZXJlZFRpbGVzW2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRMb2FkZWRQYXJlbnQoaWQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpZCBpbiB0aGlzLmNvdmVyZWRUaWxlcykgcmV0YWluW2lkXSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdGlsZXMgd2UgZG9uJ3QgbmVlZCBhbnltb3JlLlxyXG4gICAgICAgIHZhciByZW1vdmUgPSB1dGlsLmtleXNEaWZmZXJlbmNlKHRoaXMudGlsZXMsIHJldGFpbik7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZCA9ICtyZW1vdmVbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRpbGUoaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2xvYWRUaWxlOiBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIHZhciBsYXllciA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLFxyXG4gICAgICAgICAgICBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKSxcclxuICAgICAgICAgICAgdGlsZTtcclxuXHJcbiAgICAgICAgaWYgKHBvcy53ID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUudGltZSgnbG9hZGluZyAnICsgcG9zLnogKyAnLycgKyBwb3MueCArICcvJyArIHBvcy55KTtcclxuICAgICAgICAgICAgdmFyIHVybCA9IFRpbGVDb29yZC51cmwoaWQsIHRoaXMudGlsZUpTT04udGlsZXMpO1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0gPSBuZXcgdGhpcy5UaWxlKGlkLCB0aGlzLCB1cmwsIHRpbGVDb21wbGV0ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55LCAwKTtcclxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdID0gdGhpcy50aWxlc1t3cmFwcGVkXSB8fCB0aGlzLl9hZGRUaWxlKHdyYXBwZWQpO1xyXG4gICAgICAgICAgICB0aWxlLnVzZXMrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRpbGVDb21wbGV0ZShlcnIpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS50aW1lRW5kKCdsb2FkaW5nICcgKyBwb3MueiArICcvJyArIHBvcy54ICsgJy8nICsgcG9zLnkpO1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZhaWxlZCB0byBsb2FkIHRpbGUgJWQvJWQvJWQ6ICVzJywgcG9zLnosIHBvcy54LCBwb3MueSwgZXJyLnN0YWNrIHx8IGVycik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xyXG4gICAgICAgICAgICAgICAgbWFwLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQWRkcyBhIHZlY3RvciB0aWxlIHRvIHRoZSBtYXAuIEl0IHdpbGwgdHJpZ2dlciBhIHJlcmVuZGVyIG9mIHRoZSBtYXAgYW5kIHdpbGxcclxuICAgIC8vIGJlIHBhcnQgaW4gYWxsIGZ1dHVyZSByZW5kZXJzIG9mIHRoZSBtYXAuIFRoZSBtYXAgb2JqZWN0IHdpbGwgaGFuZGxlIGNvcHlpbmdcclxuICAgIC8vIHRoZSB0aWxlIGRhdGEgdG8gdGhlIEdQVSBpZiBpdCBpcyByZXF1aXJlZCB0byBwYWludCB0aGUgY3VycmVudCB2aWV3cG9ydC5cclxuICAgIF9hZGRUaWxlOiBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1tpZF07XHJcblxyXG4gICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5jYWNoZS5nZXQoaWQpO1xyXG4gICAgICAgICAgICBpZiAodGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZS51c2VzID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZXNbaWRdID0gdGlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9sb2FkVGlsZShpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5hZGQnLCB7dGlsZTogdGlsZX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQgJiYgIXRpbGUudGltZUFkZGVkKSB7XHJcbiAgICAgICAgICAgIHRpbGUudGltZUFkZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYXN0ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5hbmltYXRpb25Mb29wLnNldCh0aGlzLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgIH0sXHJcblxyXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW2lkXTtcclxuICAgICAgICBpZiAodGlsZSkge1xyXG4gICAgICAgICAgICB0aWxlLnVzZXMtLTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNbaWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRpbGUudXNlcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGlsZS50aW1lQWRkZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUubG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGUucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuYWRkKGlkLCB0aWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUucmVtb3ZlJywge3RpbGU6IHRpbGV9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gVGFrZW4gZnJvbSBwb2x5bWFwcyBzcmMvTGF5ZXIuanNcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1wbGVnZW8vcG9seW1hcHMvYmxvYi9tYXN0ZXIvc3JjL0xheWVyLmpzI0wzMzMtTDM4M1xyXG5cclxuICAgIC8vIHNjYW4tbGluZSBjb252ZXJzaW9uXHJcbiAgICBfc2NhblRyaWFuZ2xlOiBmdW5jdGlvbihhLCBiLCBjLCB5bWluLCB5bWF4LCBzY2FuTGluZSkge1xyXG4gICAgICAgIHZhciBhYiA9IHRoaXMuX2VkZ2UoYSwgYiksXHJcbiAgICAgICAgICAgIGJjID0gdGhpcy5fZWRnZShiLCBjKSxcclxuICAgICAgICAgICAgY2EgPSB0aGlzLl9lZGdlKGMsIGEpO1xyXG5cclxuICAgICAgICB2YXIgdDtcclxuXHJcbiAgICAgICAgLy8gc29ydCBlZGdlcyBieSB5LWxlbmd0aFxyXG4gICAgICAgIGlmIChhYi5keSA+IGJjLmR5KSB7IHQgPSBhYjsgYWIgPSBiYzsgYmMgPSB0OyB9XHJcbiAgICAgICAgaWYgKGFiLmR5ID4gY2EuZHkpIHsgdCA9IGFiOyBhYiA9IGNhOyBjYSA9IHQ7IH1cclxuICAgICAgICBpZiAoYmMuZHkgPiBjYS5keSkgeyB0ID0gYmM7IGJjID0gY2E7IGNhID0gdDsgfVxyXG5cclxuICAgICAgICAvLyBzY2FuIHNwYW4hIHNjYW4gc3BhbiFcclxuICAgICAgICBpZiAoYWIuZHkpIHRoaXMuX3NjYW5TcGFucyhjYSwgYWIsIHltaW4sIHltYXgsIHNjYW5MaW5lKTtcclxuICAgICAgICBpZiAoYmMuZHkpIHRoaXMuX3NjYW5TcGFucyhjYSwgYmMsIHltaW4sIHltYXgsIHNjYW5MaW5lKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gc2Nhbi1saW5lIGNvbnZlcnNpb25cclxuICAgIF9lZGdlOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4MDogYS5jb2x1bW4sXHJcbiAgICAgICAgICAgIHkwOiBhLnJvdyxcclxuICAgICAgICAgICAgeDE6IGIuY29sdW1uLFxyXG4gICAgICAgICAgICB5MTogYi5yb3csXHJcbiAgICAgICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxyXG4gICAgICAgICAgICBkeTogYi5yb3cgLSBhLnJvd1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHNjYW4tbGluZSBjb252ZXJzaW9uXHJcbiAgICBfc2NhblNwYW5zOiBmdW5jdGlvbihlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XHJcbiAgICAgICAgdmFyIHkwID0gTWF0aC5tYXgoeW1pbiwgTWF0aC5mbG9vcihlMS55MCkpLFxyXG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xyXG5cclxuICAgICAgICAvLyBzb3J0IGVkZ2VzIGJ5IHgtY29vcmRpbmF0ZVxyXG4gICAgICAgIGlmICgoZTAueDAgPT0gZTEueDAgJiYgZTAueTAgPT0gZTEueTApID9cclxuICAgICAgICAgICAgKGUwLngwICsgZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDEpIDpcclxuICAgICAgICAgICAgKGUwLngxIC0gZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDApKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gZTA7IGUwID0gZTE7IGUxID0gdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNjYW4gbGluZXMhXHJcbiAgICAgICAgdmFyIG0wID0gZTAuZHggLyBlMC5keSxcclxuICAgICAgICAgICAgbTEgPSBlMS5keCAvIGUxLmR5LFxyXG4gICAgICAgICAgICBkMCA9IGUwLmR4ID4gMCwgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcclxuICAgICAgICAgICAgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IHkwOyB5IDwgeTE7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDAsXHJcbiAgICAgICAgICAgICAgICB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcclxuICAgICAgICAgICAgc2NhbkxpbmUoTWF0aC5mbG9vcih4MSksIE1hdGguY2VpbCh4MCksIHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3pfb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGIgJSAzMikgLSAoYSAlIDMyKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NlbnRlck91dDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHZhciB0ciA9IHRoaXMubWFwLnRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgYVBvcyA9IFRpbGVDb29yZC5mcm9tSUQoYSk7XHJcbiAgICAgICAgdmFyIGJQb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGIpO1xyXG4gICAgICAgIHZhciBjID0gVGlsZUNvb3JkLnpvb21Ubyh0ci5sb2NhdGlvbkNvb3JkaW5hdGUodHIuY2VudGVyKSwgYVBvcy56KTtcclxuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFBvaW50KGMuY29sdW1uIC0gMC41LCBjLnJvdyAtIDAuNSk7XHJcbiAgICAgICAgcmV0dXJuIGNlbnRlci5kaXN0KGFQb3MpIC0gY2VudGVyLmRpc3QoYlBvcyk7XHJcbiAgICB9LFxyXG59KTtcclxuXHJcbnZhciBzb3VyY2VzID0ge1xyXG4gICAgdmVjdG9yOiBTb3VyY2UsXHJcbiAgICByYXN0ZXI6IFNvdXJjZSxcclxuICAgIGdlb2pzb246IHJlcXVpcmUoJy4vZ2VvanNvbnNvdXJjZScpLFxyXG4gICAgdmlkZW86IHJlcXVpcmUoJy4vdmlkZW9zb3VyY2UnKVxyXG59O1xyXG5cclxuU291cmNlLmNyZWF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgcmV0dXJuIG5ldyBzb3VyY2VzW3NvdXJjZS50eXBlXShzb3VyY2UpO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2xtYXRyaXggPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKSxcclxuICAgIG1hdDIgPSBnbG1hdHJpeC5tYXQyLFxyXG4gICAgbWF0NCA9IGdsbWF0cml4Lm1hdDQsXHJcbiAgICB2ZWMyID0gZ2xtYXRyaXgudmVjMjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcclxuXHJcbmZ1bmN0aW9uIFRpbGUoKSB7fVxyXG5cclxuVGlsZS5wcm90b3R5cGUgPSB7XHJcbiAgICAvLyB0b2RvIHVuaGFyZGNvZGVcclxuICAgIHRpbGVFeHRlbnQ6IDQwOTYsXHJcblxyXG4gICAgY2FsY3VsYXRlTWF0cmljZXM6IGZ1bmN0aW9uKHosIHgsIHksIHRyYW5zZm9ybSwgcGFpbnRlcikge1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIG1vZGVsLXZpZXcgbWF0cml4IHRoYXQgY29udmVydHMgZnJvbSB0aGUgdGlsZSBjb29yZGluYXRlc1xyXG4gICAgICAgIC8vIHRvIHNjcmVlbiBjb29yZGluYXRlcy5cclxuICAgICAgICB2YXIgdGlsZVNjYWxlID0gTWF0aC5wb3coMiwgeik7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdHJhbnNmb3JtLndvcmxkU2l6ZSAvIHRpbGVTY2FsZTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG5cclxuICAgICAgICAvLyBUaGUgcG9zaXRpb24gbWF0cml4XHJcbiAgICAgICAgdGhpcy5wb3NNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgW3RyYW5zZm9ybS5jZW50ZXJQb2ludC54LCB0cmFuc2Zvcm0uY2VudGVyUG9pbnQueSwgMF0pO1xyXG4gICAgICAgIG1hdDQucm90YXRlWih0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIHRyYW5zZm9ybS5hbmdsZSk7XHJcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbLXRyYW5zZm9ybS5jZW50ZXJQb2ludC54LCAtdHJhbnNmb3JtLmNlbnRlclBvaW50LnksIDBdKTtcclxuXHJcbiAgICAgICAgdmFyIHBpeGVsWCA9IHRyYW5zZm9ybS53aWR0aCAvIDIgLSB0cmFuc2Zvcm0ueCxcclxuICAgICAgICAgICAgcGl4ZWxZID0gdHJhbnNmb3JtLmhlaWdodCAvIDIgLSB0cmFuc2Zvcm0ueTtcclxuXHJcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbcGl4ZWxYICsgeCAqIHNjYWxlLCBwaXhlbFkgKyB5ICogc2NhbGUsIDFdKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGludmVydGVkIG1hdHJpeCBmb3IgaW50ZXJhY3Rpb25cclxuICAgICAgICB0aGlzLmludlBvc01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgbWF0NC5pbnZlcnQodGhpcy5pbnZQb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4KTtcclxuXHJcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIFsgc2NhbGUgLyB0aGlzLnRpbGVFeHRlbnQsIHNjYWxlIC8gdGhpcy50aWxlRXh0ZW50LCAxIF0pO1xyXG4gICAgICAgIG1hdDQubXVsdGlwbHkodGhpcy5wb3NNYXRyaXgsIHBhaW50ZXIucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wb3NNYXRyaXgpO1xyXG5cclxuICAgICAgICAvLyBUaGUgZXh0cnVzaW9uIG1hdHJpeC5cclxuICAgICAgICB0aGlzLmV4TWF0cml4ID0gbWF0NC5jbG9uZShwYWludGVyLnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgIG1hdDQucm90YXRlWih0aGlzLmV4TWF0cml4LCB0aGlzLmV4TWF0cml4LCB0cmFuc2Zvcm0uYW5nbGUpO1xyXG5cclxuICAgICAgICAvLyAyeDIgbWF0cml4IGZvciByb3RhdGluZyBwb2ludHNcclxuICAgICAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcclxuICAgICAgICBtYXQyLnJvdGF0ZSh0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLnJvdGF0aW9uTWF0cml4LCB0cmFuc2Zvcm0uYW5nbGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwb3NpdGlvbkF0OiBmdW5jdGlvbihpZCwgcG9pbnQpIHtcclxuICAgICAgICAvLyB0aWxlIGhhc24ndCBmaW5pc2hlZCBsb2FkaW5nXHJcbiAgICAgICAgaWYgKCF0aGlzLmludlBvc01hdHJpeCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciBwb3MgPSB2ZWMyLnRyYW5zZm9ybU1hdDQoW10sIFtwb2ludC54LCBwb2ludC55XSwgdGhpcy5pbnZQb3NNYXRyaXgpO1xyXG4gICAgICAgIHZlYzIuc2NhbGUocG9zLCBwb3MsIDQwOTYgLyB0aGlzLnNjYWxlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBwb3NbMF0sXHJcbiAgICAgICAgICAgIHk6IHBvc1sxXSxcclxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihwb3MsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5tYXAuZGlzcGF0Y2hlci5zZW5kKCdxdWVyeSBmZWF0dXJlcycsIHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvcy54LFxyXG4gICAgICAgICAgICB5OiBwb3MueSxcclxuICAgICAgICAgICAgc2NhbGU6IHBvcy5zY2FsZSxcclxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZS5pZCxcclxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgICAgICB9LCBjYWxsYmFjaywgdGhpcy53b3JrZXJJRCk7XHJcbiAgICB9XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqIFRpbGVzIGFyZSBnZW5lcmFsbHkgcmVwcmVzZW50ZWQgYXMgcGFja2VkIGludGVnZXIgaWRzIGNvbnN0cnVjdGVkIGJ5XHJcbiAqIGBUaWxlQ29vcmQudG9JRCh4LCB5LCB6KWBcclxuICovXHJcblxyXG52YXIgVGlsZUNvb3JkID0gZXhwb3J0cztcclxuXHJcblRpbGVDb29yZC50b0lEID0gZnVuY3Rpb24oeiwgeCwgeSwgdykge1xyXG4gICAgdyA9IHcgfHwgMDtcclxuICAgIHcgKj0gMjtcclxuICAgIGlmICh3IDwgMCkgdyA9IHcgKiAtMSAtMTtcclxuICAgIHZhciBkaW0gPSAxIDw8IHo7XHJcbiAgICByZXR1cm4gKChkaW0gKiBkaW0gKiB3ICsgZGltICogeSArIHgpICogMzIpICsgejtcclxufTtcclxuXHJcblRpbGVDb29yZC5hc1N0cmluZyA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XHJcbiAgICByZXR1cm4gcG9zLnogKyBcIi9cIiArIHBvcy54ICsgXCIvXCIgKyBwb3MueTtcclxufTtcclxuXHJcbi8qXHJcbiAqIFBhcnNlIGEgcGFja2VkIGludGVnZXIgaWQgaW50byBhbiBvYmplY3Qgd2l0aCB4LCB5LCBhbmQgeiBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5UaWxlQ29vcmQuZnJvbUlEID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHZhciB6ID0gaWQgJSAzMiwgZGltID0gMSA8PCB6O1xyXG4gICAgdmFyIHh5ID0gKChpZCAtIHopIC8gMzIpO1xyXG4gICAgdmFyIHggPSB4eSAlIGRpbSwgeSA9ICgoeHkgLSB4KSAvIGRpbSkgJSBkaW07XHJcbiAgICB2YXIgdyA9IE1hdGguZmxvb3IoeHkgLyAoZGltICogZGltKSk7XHJcbiAgICBpZiAodyAlIDIgIT09IDApIHcgPSB3ICogLTEgLTE7XHJcbiAgICB3IC89IDI7XHJcbiAgICByZXR1cm4geyB6OiB6LCB4OiB4LCB5OiB5LCB3OiB3IH07XHJcbn07XHJcblxyXG4vKlxyXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gaXRzIHpvb20gbGV2ZWxcclxuICovXHJcblRpbGVDb29yZC56b29tID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiBpZCAlIDMyO1xyXG59O1xyXG5cclxuLy8gR2l2ZW4gYW4gaWQgYW5kIGEgbGlzdCBvZiB1cmxzLCBjaG9vc2UgYSB1cmwgdGVtcGxhdGUgYW5kIHJldHVybiBhIHRpbGUgVVJMXHJcblRpbGVDb29yZC51cmwgPSBmdW5jdGlvbihpZCwgdXJscykge1xyXG4gICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xyXG5cclxuICAgIHJldHVybiB1cmxzWyhwb3MueCArIHBvcy55KSAlIHVybHMubGVuZ3RoXVxyXG4gICAgICAgIC5yZXBsYWNlKCd7aH0nLCAocG9zLnggJSAxNikudG9TdHJpbmcoMTYpICsgKHBvcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcclxuICAgICAgICAucmVwbGFjZSgne3p9JywgcG9zLnopXHJcbiAgICAgICAgLnJlcGxhY2UoJ3t4fScsIHBvcy54KVxyXG4gICAgICAgIC5yZXBsYWNlKCd7eX0nLCBwb3MueSk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gdGhlIGlkIG9mIGl0cyBwYXJlbnQgdGlsZVxyXG4gKi9cclxuVGlsZUNvb3JkLnBhcmVudCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XHJcbiAgICBpZiAocG9zLnogPT09IDApIHJldHVybiBpZDtcclxuICAgIGVsc2UgcmV0dXJuIFRpbGVDb29yZC50b0lEKHBvcy56IC0gMSwgTWF0aC5mbG9vcihwb3MueCAvIDIpLCBNYXRoLmZsb29yKHBvcy55IC8gMikpO1xyXG59O1xyXG5cclxuVGlsZUNvb3JkLnBhcmVudFdpdGhab29tID0gZnVuY3Rpb24oaWQsIHpvb20pIHtcclxuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcclxuICAgIHdoaWxlIChwb3MueiA+IHpvb20pIHtcclxuICAgICAgICBwb3Muei0tO1xyXG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCAvIDIpO1xyXG4gICAgICAgIHBvcy55ID0gTWF0aC5mbG9vcihwb3MueSAvIDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnkpO1xyXG59O1xyXG5cclxuLypcclxuICogR2l2ZW4gYSBwYWNrZWQgaW50ZWdlciBpZCwgcmV0dXJuIGFuIGFycmF5IG9mIGludGVnZXIgaWRzIHJlcHJlc2VudGluZ1xyXG4gKiBpdHMgZm91ciBjaGlsZHJlbi5cclxuICovXHJcblRpbGVDb29yZC5jaGlsZHJlbiA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XHJcbiAgICBwb3MueiArPSAxO1xyXG4gICAgcG9zLnggKj0gMjtcclxuICAgIHBvcy55ICo9IDI7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnksIHBvcy53KSxcclxuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLnggKyAxLCBwb3MueSwgcG9zLncpLFxyXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnkgKyAxLCBwb3MudyksXHJcbiAgICAgICAgVGlsZUNvb3JkLnRvSUQocG9zLnosIHBvcy54ICsgMSwgcG9zLnkgKyAxLCBwb3MudylcclxuICAgIF07XHJcbn07XHJcblxyXG5UaWxlQ29vcmQuem9vbVRvID0gZnVuY3Rpb24oYywgeikge1xyXG4gICAgYy5jb2x1bW4gPSBjLmNvbHVtbiAqIE1hdGgucG93KDIsIHogLSBjLnpvb20pO1xyXG4gICAgYy5yb3cgPSBjLnJvdyAqIE1hdGgucG93KDIsIHogLSBjLnpvb20pO1xyXG4gICAgYy56b29tID0gejtcclxuICAgIHJldHVybiBjO1xyXG59O1xyXG5cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJld2luZCA9IHJlcXVpcmUoJ2dlb2pzb24tcmV3aW5kJyk7XHJcblxyXG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlY29vcmQuanMnKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0uanMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcclxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmcuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdGlsZUdlb0pTT047XHJcblxyXG5mdW5jdGlvbiB0aWxlR2VvSlNPTihnZW9qc29uLCB6b29tKSB7XHJcbiAgICB2YXIgdGlsZXMgPSB7fTtcclxuICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICB0cmFuc2Zvcm0uem9vbSA9IHpvb207XHJcblxyXG4gICAgZ2VvanNvbiA9IHJld2luZChnZW9qc29uKTtcclxuXHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRpbGVGZWF0dXJlKGdlb2pzb24uZmVhdHVyZXNbaV0sIHRyYW5zZm9ybSwgdGlsZXMsIHRpbGVFeHRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcbiAgICAgICAgdGlsZUZlYXR1cmUoZ2VvanNvbiwgdHJhbnNmb3JtLCB0aWxlcywgdGlsZUV4dGVudCk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdygnVW5yZWNvZ25pemVkIGdlb2pzb24gdHlwZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gdGlsZUZlYXR1cmUoZmVhdHVyZSwgdHJhbnNmb3JtLCB0aWxlcywgdGlsZUV4dGVudCkge1xyXG4gICAgdmFyIGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcbiAgICB2YXIgdGlsZWQ7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xyXG4gICAgICAgIHRpbGVkID0gdGlsZUxpbmVTdHJpbmcoW2Nvb3Jkc10sIHRyYW5zZm9ybSwgdGlsZUV4dGVudCk7XHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgICAgdGlsZWQgPSB0aWxlTGluZVN0cmluZyhjb29yZHMsIHRyYW5zZm9ybSwgdGlsZUV4dGVudCk7XHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcclxuICAgICAgICB0aWxlZCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlZF8gPSB0aWxlTGluZVN0cmluZyhjb29yZHNbaV0sIHRyYW5zZm9ybSwgdGlsZUV4dGVudCwgdHlwZSA9PT0gJ1BvbHlnb24nKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdGlsZUlEIGluIHRpbGVkXykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlZFt0aWxlSURdKSB0aWxlZFt0aWxlSURdID0gW107XHJcbiAgICAgICAgICAgICAgICB0aWxlZFt0aWxlSURdID0gKHRpbGVkW3RpbGVJRF0gfHwgW10pLmNvbmNhdCh0aWxlZF9bdGlsZUlEXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xyXG4gICAgICAgIHRocm93KFwidG9kb1wiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3coXCJ1bnJlY29nbml6ZWQgZ2VvbWV0cnkgdHlwZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpZCBpbiB0aWxlZCkge1xyXG4gICAgICAgIHRpbGVzW2lkXSA9IHRpbGVzW2lkXSB8fCBbXTtcclxuICAgICAgICB0aWxlc1tpZF0ucHVzaCh7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUucHJvcGVydGllcyxcclxuICAgICAgICAgICAgY29vcmRzOiB0aWxlZFtpZF0sXHJcbiAgICAgICAgICAgIHR5cGU6IGZlYXR1cmUuZ2VvbWV0cnkudHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0aWxlTGluZVN0cmluZyhjb29yZHMsIHRyYW5zZm9ybSwgdGlsZUV4dGVudCwgcmVqb2luKSB7XHJcblxyXG4gICAgdmFyIHBhZGRpbmcgPSAwLjAxO1xyXG4gICAgdmFyIHBhZGRlZEV4dGVudCA9IHRpbGVFeHRlbnQgKiAoMSArIDIgKiBwYWRkaW5nKTtcclxuICAgIHZhciBjb29yZCA9IHRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUobmV3IExhdExuZyhjb29yZHNbMF1bMV0sIGNvb3Jkc1swXVswXSkpO1xyXG4gICAgdmFyIHByZXZDb29yZDtcclxuXHJcbiAgICB2YXIgdGlsZXMgPSB7fTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByZXZDb29yZCA9IGNvb3JkO1xyXG4gICAgICAgIGNvb3JkID0gdHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShuZXcgTGF0TG5nKGNvb3Jkc1tpXVsxXSwgY29vcmRzW2ldWzBdKSk7XHJcblxyXG4gICAgICAgIHZhciBkeCA9IGNvb3JkLmNvbHVtbiAtIHByZXZDb29yZC5jb2x1bW4gfHwgTnVtYmVyLk1JTl9WQUxVRSxcclxuICAgICAgICAgICAgZHkgPSBjb29yZC5yb3cgLSBwcmV2Q29vcmQucm93IHx8IE51bWJlci5NSU5fVkFMVUUsXHJcbiAgICAgICAgICAgIGRpclggPSBkeCAvIE1hdGguYWJzKGR4KSxcclxuICAgICAgICAgICAgZGlyWSA9IGR5IC8gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3gsIGluIHRpbGVzLCBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgIHZhciBzdGFydFRpbGVYID0gTWF0aC5mbG9vcihwcmV2Q29vcmQuY29sdW1uIC0gZGlyWCAqIHBhZGRpbmcpO1xyXG4gICAgICAgIHZhciBlbmRUaWxlWCA9IE1hdGguZmxvb3IoY29vcmQuY29sdW1uICsgZGlyWCAqIHBhZGRpbmcpO1xyXG4gICAgICAgIHZhciBzdGFydFRpbGVZID0gTWF0aC5mbG9vcihwcmV2Q29vcmQucm93IC0gZGlyWSAqIHBhZGRpbmcpO1xyXG4gICAgICAgIHZhciBlbmRUaWxlWSA9IE1hdGguZmxvb3IoY29vcmQucm93ICsgZGlyWSAqIHBhZGRpbmcpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIHRpbGVzIHRoZSBzZWdtZW50IG1pZ2h0IGludGVyc2VjdFxyXG4gICAgICAgIC8vIGFuZCBzcGxpdCB0aGUgc2VnbWVudCBhY3Jvc3MgdGhvc2UgdGlsZXNcclxuICAgICAgICBmb3IgKHZhciB4ID0gc3RhcnRUaWxlWDsgKHggLSBlbmRUaWxlWCkgKiBkaXJYIDw9IDA7IHggKz0gZGlyWCkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdFggPSAoeCAtIHBhZGRpbmcgLSBwcmV2Q29vcmQuY29sdW1uKSAvIGR4O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gKHggKyAxICsgcGFkZGluZyAtIHByZXZDb29yZC5jb2x1bW4pIC8gZHg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gc3RhcnRUaWxlWTsgKHkgLSBlbmRUaWxlWSkgKiBkaXJZIDw9IDA7IHkgKz0gZGlyWSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcFkgPSAoeSAtIHBhZGRpbmcgLSBwcmV2Q29vcmQucm93KSAvIGR5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbVkgPSAoeSArIDEgKyBwYWRkaW5nIC0gcHJldkNvb3JkLnJvdykgLyBkeTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmcmFjdGlvbiBvZiB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIHNlZ21lbnQgYXQgd2hpY2ggdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIC8vIGVudGVycyBvciBleGl0cyB0aGUgdGlsZVxyXG4gICAgICAgICAgICAgICAgdmFyIGVudGVyID0gTWF0aC5tYXgoTWF0aC5taW4obGVmdFgsIHJpZ2h0WCksIE1hdGgubWluKHRvcFksIGJvdHRvbVkpKTtcclxuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gTWF0aC5taW4oTWF0aC5tYXgobGVmdFgsIHJpZ2h0WCksIE1hdGgubWF4KHRvcFksIGJvdHRvbVkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZUlEID0gVGlsZUNvb3JkLnRvSUQodHJhbnNmb3JtLnRpbGVab29tLCB4LCB5KSxcclxuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZXNbdGlsZUlEXSxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBzdGFydHMgb3V0c2lkZSB0aGUgdGlsZSwgYWRkIGVudHJ5IHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA8PSBlbnRlciAmJiBlbnRlciA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgKChwcmV2Q29vcmQuY29sdW1uICsgZW50ZXIgKiBkeCkgLSB4KSAqIHRpbGVFeHRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJldkNvb3JkLnJvdyArIGVudGVyICogZHkpIC0geSkgKiB0aWxlRXh0ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuY29udGludWVzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlKSB0aWxlc1t0aWxlSURdID0gdGlsZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGUucHVzaChbcG9pbnRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBlbmRzIG91dHNpZGUgdGhlIHRpbGUsIGFkZCBleGl0IHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA8PSBleGl0ICYmIGV4aXQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJldkNvb3JkLmNvbHVtbiArIGV4aXQgKiBkeCkgLSB4KSAqIHRpbGVFeHRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJldkNvb3JkLnJvdyArIGV4aXQgKiBkeSkgLSB5KSAqIHRpbGVFeHRlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludC5jb250aW51ZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aWxlW3RpbGUubGVuZ3RoIC0gMV0ucHVzaChwb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBwb2ludCBpdHNlbGZcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb29yZC5jb2x1bW4gLSB4KSAqIHRpbGVFeHRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb29yZC5yb3cgLSB5KSAqIHRpbGVFeHRlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbGUpIHRpbGVzW3RpbGVJRF0gPSB0aWxlID0gW1twb2ludF1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGlsZVt0aWxlLmxlbmd0aCAtIDFdLnB1c2gocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZWpvaW4pIHtcclxuICAgICAgICAvLyByZWFzc2VtYmxlIHRoZSBkaXNjb25uZWN0ZWQgc2VnbWVudHMgaW50byBhIGxpbmVzdHJpbmdcclxuICAgICAgICAvLyBzZWN0aW9ucyBvZiB0aGUgbGluZXN0cmluZyBvdXRzaWRlIHRoZSB0aWxlIGFyZSByZXBsYWNlZCB3aXRoIHNlZ21lbnRzXHJcbiAgICAgICAgLy8gdGhhdCBmb2xsb3cgdGhlIHRpbGUncyBlZGdlXHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGlsZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHRpbGVzW2lkXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2VnbWVudHNbMF1bMF0uY29udGludWVzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBzZWdtZW50IGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVzdHJpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gam9pbiBpdCB3aXRoIHRoZSBsYXN0IHNvIHRoYXQgYWxsIHNlZ21lbnRzIHN0YXJ0IGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gZW5kIGF0IHRpbGUgYm91bmRhcmllc1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBzZWdtZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KHNlZ21lbnRzWzBdLCBsYXN0LnNsaWNlKDAsIGxhc3QubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBlZGdlRGlzdChzZWdtZW50c1swXVswXSwgdGlsZUV4dGVudCwgcGFkZGluZyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlZ21lbnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIHRpbGUgY29ybmVycyBhbG9uZyB0aGUgcGF0aCBiZXR3ZWVuIHRoZSBjdXJyZW50IHNlZ21lbnQncyBleGl0IHBvaW50XHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIG5leHQgc2VnbWVudCdzIGVudHJ5IHBvaW50XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNFeGl0ID0gZWRnZURpc3Qoc2VnbWVudHNba11bc2VnbWVudHNba10ubGVuZ3RoIC0gMV0sIHBhZGRlZEV4dGVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEVudHJ5ID0gZWRnZURpc3Qoc2VnbWVudHNbKGsgKyAxKSAlIHNlZ21lbnRzLmxlbmd0aF1bMF0sIHBhZGRlZEV4dGVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VG9FeGl0ID0gKHRoaXNFeGl0IC0gc3RhcnQgKyA0KSAlIDQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUb05leHRFbnRyeSA9IChuZXh0RW50cnkgLSBzdGFydCArIDQpICUgNDtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSAodGhpc0V4aXQgPT09IG5leHRFbnRyeSB8fCBzdGFydFRvRXhpdCA8IHN0YXJ0VG9OZXh0RW50cnkpID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdW5kRm4gPSBkaXJlY3Rpb24gPiAwID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gcm91bmRGbih0aGlzRXhpdCkgJSA0OyBjICE9IHJvdW5kRm4obmV4dEVudHJ5KSAlIDQ7IGMgPSAoYyArIGRpcmVjdGlvbiArIDQpICUgNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW2tdLnB1c2gobmV3IFBvaW50KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29ybmVyLnggKyAoY29ybmVyLnggLSAwLjUgPiAwID8gMSA6IC0xKSAqIHBhZGRpbmcpICogdGlsZUV4dGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lci55ICsgKGNvcm5lci55IC0gMC41ID4gMCA/IDEgOiAtMSkgKiBwYWRkaW5nKSAqIHRpbGVFeHRlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSm9pbiBhbGwgc2VnbWVudHNcclxuICAgICAgICAgICAgdGlsZXNbaWRdID0gW0FycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHNlZ21lbnRzKV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aWxlcztcclxuXHJcbn1cclxuXHJcbnZhciBjb3JuZXJzID0gW1xyXG4gICAgbmV3IFBvaW50KDAsIDApLFxyXG4gICAgbmV3IFBvaW50KDEsIDApLFxyXG4gICAgbmV3IFBvaW50KDEsIDEpLFxyXG4gICAgbmV3IFBvaW50KDAsIDEpXTtcclxuXHJcbi8qXHJcbiAqIENvbnZlcnRzIHRvIGEgcG9pbnQgdG8gdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBlZGdlIG9mIHRoZSB0aWxlIChvdXQgb2YgNCkuXHJcbiAqXHJcbiAqICAgICAgICAgMC41XHJcbiAqICAgICAwIF9fX19fX18gMVxyXG4gKiAgICAgIHwgICAgICAgfFxyXG4gKiAgMy41IHwgICAgICAgfCAxLjVcclxuICogICAgICB8ICAgICAgIHxcclxuICogICAgICB8X19fX19fX3xcclxuICogICAgIDMgICAyLjUgICAyXHJcbiAqL1xyXG5mdW5jdGlvbiBlZGdlRGlzdChwb2ludCwgZXh0ZW50KSB7XHJcbiAgICB2YXIgeCA9IHBvaW50LnggLyBleHRlbnQ7XHJcbiAgICB2YXIgeSA9IHBvaW50LnkgLyBleHRlbnQ7XHJcbiAgICB2YXIgZDtcclxuICAgIGlmIChNYXRoLmFicyh5IC0gMC41KSA+PSBNYXRoLmFicyh4IC0gMC41KSkge1xyXG4gICAgICAgIGQgPSBNYXRoLnJvdW5kKHkpICogMiArICh5IDwgMC41ID8geCA6IDEgLSB4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZCA9IE1hdGgucm91bmQoMSAtIHgpICogMiArICh4ID4gMC41ID8geSA6IDEgLSB5KSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGQgJSA0O1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlLmpzJyksXHJcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVjb29yZC5qcycpLFxyXG4gICAgQnVmZmVyU2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWZmZXIvYnVmZmVyc2V0LmpzJyksXHJcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XHJcblxyXG52YXIgY3JlYXRlQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9jcmVhdGVidWNrZXQuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcclxuXHJcbmZ1bmN0aW9uIFZlY3RvclRpbGUoaWQsIHNvdXJjZSwgdXJsLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgdGhpcy56b29tID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcclxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuICAgIHRoaXMub3B0aW9ucyA9IHNvdXJjZS5vcHRpb25zO1xyXG4gICAgdGhpcy5pZCA9IHV0aWwudW5pcXVlSWQoKTtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuICAgIGlmICh0aGlzLnpvb20gPj0gc291cmNlLnRpbGVKU09OLm1heHpvb20pIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5tYXAub3B0aW9ucy5tYXhab29tIC0gdGhpcy56b29tO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gMTtcclxuICAgIH1cclxuICAgIHRoaXMudXNlcyA9IDE7XHJcbiAgICB0aGlzLl9sb2FkKCk7XHJcbn1cclxuXHJcblZlY3RvclRpbGUucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFRpbGUsIHtcclxuXHJcbiAgICBfbG9hZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgdGlsZScsIHtcclxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcclxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5zb3VyY2UudGlsZUpTT04ubWF4em9vbSxcclxuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMub3B0aW9ucy50aWxlU2l6ZSxcclxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZS5pZCxcclxuICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGhcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKCFlcnIgJiYgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZS5vblRpbGVMb2FkKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpbGUuY2FsbGJhY2soZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgb25UaWxlTG9hZDogZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBUaWxlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwXHJcbiAgICAgICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KGRhdGEuYnVmZmVycyk7XHJcblxyXG4gICAgICAgIHRoaXMuYnVja2V0cyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGIgaW4gZGF0YS5lbGVtZW50R3JvdXBzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVja2V0c1tiXSA9IGNyZWF0ZUJ1Y2tldCh0aGlzLm1hcC5zdHlsZS5idWNrZXRzW2JdLCB0aGlzLmJ1ZmZlcnMsIHVuZGVmaW5lZCwgZGF0YS5lbGVtZW50R3JvdXBzW2JdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gcmV1c2UgcHJlcmVuZGVyZWQgdGV4dHVyZXNcclxuICAgICAgICBmb3IgKHZhciBidWNrZXQgaW4gdGhpcy5idWNrZXRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Y2tldHNbYnVja2V0XS5wcmVyZW5kZXJlZCkgdGhpcy5tYXAucGFpbnRlci5zYXZlVGV4dHVyZSh0aGlzLmJ1Y2tldHNbYnVja2V0XS5wcmVyZW5kZXJlZC50ZXh0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWFwLmRpc3BhdGNoZXIuc2VuZCgncmVtb3ZlIHRpbGUnLCB7IGlkOiB0aGlzLmlkLCBzb3VyY2U6IHRoaXMuc291cmNlLmlkIH0sIG51bGwsIHRoaXMud29ya2VySUQpO1xyXG4gICAgICAgIHRoaXMubWFwLnBhaW50ZXIuZ2x5cGhBdGxhcy5yZW1vdmVHbHlwaHModGhpcy5pZCk7XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XHJcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XHJcbiAgICAgICAgaWYgKGJ1ZmZlcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiBpbiBidWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXJzW2JdLmRlc3Ryb3koZ2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hcDtcclxuICAgIH0sXHJcblxyXG4gICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMubWFwLmRpc3BhdGNoZXIuc2VuZCgnYWJvcnQgdGlsZScsIHsgaWQ6IHRoaXMuaWQsIHNvdXJjZTogdGhpcy5zb3VyY2UuaWQgfSwgbnVsbCwgdGhpcy53b3JrZXJJRCk7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZS5qcycpO1xyXG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlY29vcmQuanMnKTtcclxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmcuanMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvU291cmNlO1xyXG5cclxuZnVuY3Rpb24gVmlkZW9Tb3VyY2Uob3B0aW9ucykge1xyXG5cclxuICAgIHRoaXMudmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgdGhpcy52aWRlby5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xyXG4gICAgdGhpcy52aWRlby5sb29wID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgdXJscyA9ICh0eXBlb2Ygb3B0aW9ucy51cmwgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLnVybF0gOiBvcHRpb25zLnVybDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xyXG4gICAgICAgIHMuc3JjID0gdXJsc1tpXTtcclxuICAgICAgICB0aGlzLnZpZGVvLmFwcGVuZENoaWxkKHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBvcHRpb25zLmNvb3JkaW5hdGVzO1xyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgbG9vcElEO1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgLy8gc3RhcnQgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXHJcbiAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBsb29wSUQgPSBzb3VyY2UubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KEluZmluaXR5KTtcclxuICAgICAgICBzb3VyY2UubWFwLl9yZXJlbmRlcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc3RvcCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RvcHNcclxuICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBzb3VyY2UubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3AuY2FuY2VsKGxvb3BJRCk7XHJcbiAgICB9KTtcclxuXHJcbn1cclxuXHJcblZpZGVvU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbihtYXApIHtcclxuICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgdGhpcy52aWRlby5wbGF5KCk7XHJcbiAgICB0aGlzLmNyZWF0ZVRpbGUoKTtcclxufTtcclxuXHJcblZpZGVvU291cmNlLnByb3RvdHlwZS5jcmVhdGVUaWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvKlxyXG4gICAgICogQ2FsY3VsYXRlIHdoaWNoIG1lcmNhdG9yIHRpbGUgaXMgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB0aGUgdmlkZW8gaW5cclxuICAgICAqIGFuZCBjcmVhdGUgYSBidWZmZXIgd2l0aCB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlc1xyXG4gICAgICogbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxyXG4gICAgICovXHJcbiAgICB2YXIgbWFwID0gdGhpcy5tYXA7XHJcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24obGF0bG5nKSB7XHJcbiAgICAgICAgdmFyIGxvYyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XHJcbiAgICAgICAgcmV0dXJuIFRpbGVDb29yZC56b29tVG8obWFwLnRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUobG9jKSwgMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGNvb3Jkc1tpXS5yb3cpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBjb29yZHNbaV0uY29sdW1uKTtcclxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblg7XHJcbiAgICB2YXIgZHkgPSBtYXhZIC0gbWluWTtcclxuICAgIHZhciBkTWF4ID0gTWF0aC5tYXgoZHgsIGR5KTtcclxuICAgIHZhciBjZW50ZXIgPSBUaWxlQ29vcmQuem9vbVRvKHtcclxuICAgICAgICBjb2x1bW46IChtaW5YICsgbWF4WCkgLyAyLFxyXG4gICAgICAgIHJvdzogKG1pblkgKyBtYXhZKSAvIDIsXHJcbiAgICAgICAgem9vbTogMFxyXG4gICAgfSwgTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xyXG5cclxuICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcclxuICAgIHZhciB0aWxlQ29vcmRzID0gY29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xyXG4gICAgICAgIHZhciB6b29tZWRDb29yZCA9IFRpbGVDb29yZC56b29tVG8oY29vcmQsIGNlbnRlci56b29tKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxyXG4gICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXIuY29sdW1uKSAqIHRpbGVFeHRlbnQpLFxyXG4gICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5yb3cgLSBjZW50ZXIucm93KSAqIHRpbGVFeHRlbnQpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBnbCA9IG1hcC5wYWludGVyLmdsO1xyXG4gICAgdmFyIG1heEludDE2ID0gMzI3Njc7XHJcbiAgICB2YXIgYXJyYXkgPSBuZXcgSW50MTZBcnJheShbXHJcbiAgICAgICAgdGlsZUNvb3Jkc1swXS54LCB0aWxlQ29vcmRzWzBdLnksIDAsIDAsXHJcbiAgICAgICAgdGlsZUNvb3Jkc1sxXS54LCB0aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwLFxyXG4gICAgICAgIHRpbGVDb29yZHNbM10ueCwgdGlsZUNvb3Jkc1szXS55LCAwLCBtYXhJbnQxNixcclxuICAgICAgICB0aWxlQ29vcmRzWzJdLngsIHRpbGVDb29yZHNbMl0ueSwgbWF4SW50MTYsIG1heEludDE2XHJcbiAgICBdKTtcclxuICAgIHRoaXMuYm91bmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5ib3VuZHNCdWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgdGhpcy50aWxlID0gbmV3IFRpbGUoKTtcclxuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xyXG59O1xyXG5cclxuVmlkZW9Tb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIG5vb3BcclxufTtcclxuXHJcblZpZGVvU291cmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIG5vb3BcclxufTtcclxuXHJcblZpZGVvU291cmNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihsYXllcnMpIHtcclxuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XHJcbiAgICBpZiAodGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikgcmV0dXJuOyAvLyBub3QgZW5vdWdoIGRhdGEgZm9yIGN1cnJlbnQgcG9zaXRpb25cclxuXHJcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbMF07XHJcblxyXG4gICAgdmFyIGJ1Y2tldCA9IHtcclxuICAgICAgICB0eXBlOiAncmFzdGVyJyxcclxuICAgICAgICB0aWxlOiB0aGlzLFxyXG4gICAgICAgIGJvdW5kc0J1ZmZlcjogdGhpcy5ib3VuZHNCdWZmZXIsXHJcbiAgICAgICAgYmluZDogdGhpcy5iaW5kLmJpbmQodGhpcylcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGJ1Y2tldHMgPSB7fTtcclxuICAgIGJ1Y2tldHNbbGF5ZXIuYnVja2V0XSA9IGJ1Y2tldDtcclxuXHJcbiAgICB2YXIgYyA9IHRoaXMuY2VudGVyO1xyXG4gICAgdGhpcy50aWxlLmNhbGN1bGF0ZU1hdHJpY2VzKGMuem9vbSwgYy5jb2x1bW4sIGMucm93LCB0aGlzLm1hcC50cmFuc2Zvcm0sIHRoaXMubWFwLnBhaW50ZXIpO1xyXG4gICAgdGhpcy5tYXAucGFpbnRlci50aWxlID0gdGhpcy50aWxlO1xyXG4gICAgdGhpcy5tYXAucGFpbnRlci5hcHBseVN0eWxlKGxheWVyLCB0aGlzLm1hcC5zdHlsZSwgYnVja2V0cywge30pO1xyXG59O1xyXG5cclxuVmlkZW9Tb3VyY2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xyXG5cclxuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5cclxuVmlkZW9Tb3VyY2UucHJvdG90eXBlLmZlYXR1cmVzQXQgPSBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xyXG4gICAgLy8gVE9ETyByZXR1cm4gcGl4ZWw/XHJcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL2FjdG9yLmpzJyksXHJcbiAgICBidWNrZXRGaWx0ZXIgPSByZXF1aXJlKCcuLi9zdHlsZS9idWNrZXRmaWx0ZXIuanMnKSxcclxuICAgIFdvcmtlclRpbGUgPSByZXF1aXJlKCcuL3dvcmtlcnRpbGUuanMnKSxcclxuICAgIHRpbGVHZW9KU09OID0gcmVxdWlyZSgnLi90aWxlZ2VvanNvbi5qcycpLFxyXG4gICAgV3JhcHBlciA9IHJlcXVpcmUoJy4vZ2VvanNvbndyYXBwZXIuanMnKSxcclxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcclxuICAgIHF1ZXVlID0gcmVxdWlyZSgncXVldWUtYXN5bmMnKSxcclxuICAgIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV29ya2VyO1xyXG5cclxuZnVuY3Rpb24gV29ya2VyKHNlbGYpIHtcclxuICAgIHRoaXMuc2VsZiA9IHNlbGY7XHJcbiAgICB0aGlzLmFjdG9yID0gbmV3IEFjdG9yKHNlbGYsIHRoaXMpO1xyXG59XHJcblxyXG51dGlsLmV4dGVuZChXb3JrZXIucHJvdG90eXBlLCB7XHJcbiAgICBhbGVydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZWxmLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogJ2FsZXJ0IG1lc3NhZ2UnLFxyXG4gICAgICAgICAgICBkYXRhOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVXBkYXRlcyB0aGUgc3R5bGUgdG8gdXNlIGZvciB0aGlzIG1hcC5cclxuICAgICdzZXQgYnVja2V0cyc6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgYnVja2V0cyA9IFdvcmtlclRpbGUuYnVja2V0cyA9IGRhdGE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2ldO1xyXG4gICAgICAgICAgICBidWNrZXQuY29tcGFyZSA9IGJ1Y2tldEZpbHRlcihidWNrZXQuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdzZXQgZ2x5cGhzJzogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIFdvcmtlclRpbGUucHJvdG90eXBlLmdseXBocyA9IGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBMb2FkIGFuZCBwYXJzZSBhIHRpbGUgYXQgYHVybGAsIGFuZCBjYWxsIGBjYWxsYmFja2Agd2l0aFxyXG4gICAgICogKGVyciwgcmVzcG9uc2UpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgJ2xvYWQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgICAgICBuZXcgV29ya2VyVGlsZShwYXJhbXMudXJsLCB1bmRlZmluZWQsIHBhcmFtcy5pZCwgcGFyYW1zLnpvb20sIHBhcmFtcy5tYXhab29tLCBwYXJhbXMudGlsZVNpemUsIHBhcmFtcy5zb3VyY2UsIHBhcmFtcy5kZXB0aCwgdGhpcy5hY3RvciwgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogQWJvcnQgdGhlIHJlcXVlc3Qga2V5ZWQgdW5kZXIgYHVybGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICAgKi9cclxuICAgICdhYm9ydCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgV29ya2VyVGlsZS5jYW5jZWwocGFyYW1zLmlkLCBwYXJhbXMuc291cmNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ3JlbW92ZSB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIGlkID0gcGFyYW1zLmlkO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlO1xyXG4gICAgICAgIGlmIChXb3JrZXJUaWxlLmxvYWRlZFtzb3VyY2VdICYmIFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV1baWRdKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBXb3JrZXJUaWxlLmxvYWRlZFtzb3VyY2VdW2lkXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdwYXJzZSBnZW9qc29uJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBkYXRhID0gcGFyYW1zLmRhdGEsXHJcbiAgICAgICAgICAgIHpvb21zID0gcGFyYW1zLnpvb21zLFxyXG4gICAgICAgICAgICBsZW4gPSB6b29tcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIG1heFpvb20gPSB6b29tc1tsZW4gLSAxXSxcclxuICAgICAgICAgICAgYWN0b3IgPSB0aGlzLmFjdG9yLFxyXG4gICAgICAgICAgICBxID0gcXVldWUoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd29ya2VyKGlkLCB0aWxlLCB6b29tLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBuZXcgV29ya2VyVGlsZSh1bmRlZmluZWQsIG5ldyBXcmFwcGVyKHRpbGUpLCBpZCwgem9vbSwgbWF4Wm9vbSwgcGFyYW1zLnRpbGVTaXplLCBwYXJhbXMuc291cmNlLCA0LCBhY3RvciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIGRhdGEuaWQgPSBpZDtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRpbGVEYXRhKGVyciwgZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tID0gem9vbXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZXMgPSB0aWxlR2VvSlNPTihkYXRhLCB6b29tKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5kZWZlcih3b3JrZXIsIGlkLCB0aWxlc1tpZF0sIHpvb20pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHEuYXdhaXRBbGwoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgYWpheC5nZXRKU09OKGRhdGEsIHRpbGVEYXRhKTtcclxuICAgICAgICBlbHNlIHRpbGVEYXRhKG51bGwsIGRhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAncXVlcnkgZmVhdHVyZXMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHRpbGUgPSBXb3JrZXJUaWxlLmxvYWRlZFtwYXJhbXMuc291cmNlXSAmJiBXb3JrZXJUaWxlLmxvYWRlZFtwYXJhbXMuc291cmNlXVtwYXJhbXMuaWRdO1xyXG4gICAgICAgIGlmICh0aWxlKSB7XHJcbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZVRyZWUucXVlcnkocGFyYW1zLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBGZWF0dXJlVHJlZSA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZXRyZWUuanMnKTtcclxudmFyIFByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XHJcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XHJcbnZhciBDb2xsaXNpb24gPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uLmpzJyk7XHJcbnZhciBnZXRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpLmdldEFycmF5QnVmZmVyO1xyXG5cclxudmFyIEJ1ZmZlclNldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyL2J1ZmZlcnNldC5qcycpO1xyXG52YXIgY3JlYXRlQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9jcmVhdGVidWNrZXQuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV29ya2VyVGlsZTtcclxuZnVuY3Rpb24gV29ya2VyVGlsZSh1cmwsIGRhdGEsIGlkLCB6b29tLCBtYXhab29tLCB0aWxlU2l6ZSwgc291cmNlLCBkZXB0aCwgYWN0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgdGlsZSA9IHRoaXM7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB0aGlzLnpvb20gPSB6b29tO1xyXG4gICAgdGhpcy5tYXhab29tID0gbWF4Wm9vbTtcclxuICAgIHRoaXMudGlsZVNpemUgPSB0aWxlU2l6ZTtcclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgdGhpcy5idWZmZXJzID0gbmV3IEJ1ZmZlclNldCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRlZChkYXRhKSB7XHJcbiAgICAgICAgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXSA9IFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV0gfHwge307XHJcbiAgICAgICAgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXVtpZF0gPSB0aWxlO1xyXG4gICAgICAgIHRpbGUuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGlsZS5wYXJzZShkYXRhLCBhY3RvciwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cmwpIHtcclxuICAgICAgICBpZiAoV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV0gPT09IHVuZGVmaW5lZCkgV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV0gPSB7fTtcclxuICAgICAgICBXb3JrZXJUaWxlLmxvYWRpbmdbc291cmNlXVtpZF0gPSBnZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xyXG4gICAgICAgICAgICBkZWxldGUgV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV1baWRdO1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkKG5ldyB2dC5WZWN0b3JUaWxlKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsb2FkZWQoZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbldvcmtlclRpbGUuY2FuY2VsID0gZnVuY3Rpb24oaWQsIHNvdXJjZUlEKSB7XHJcbiAgICB2YXIgc291cmNlID0gV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZUlEXTtcclxuICAgIGlmIChzb3VyY2UgJiYgc291cmNlW2lkXSkge1xyXG4gICAgICAgIHNvdXJjZVtpZF0uYWJvcnQoKTtcclxuICAgICAgICBkZWxldGUgc291cmNlW2lkXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFN0b3JlcyB0aWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGluZy5cclxuV29ya2VyVGlsZS5sb2FkaW5nID0ge307XHJcblxyXG4vLyBTdG9yZXMgdGlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZC5cclxuV29ya2VyVGlsZS5sb2FkZWQgPSB7fTtcclxuXHJcbi8vIFN0b3JlcyB0aGUgc3R5bGUgaW5mb3JtYXRpb24uXHJcbldvcmtlclRpbGUuYnVja2V0cyA9IFtdO1xyXG5cclxuLypcclxuICogR2l2ZW4gdGlsZSBkYXRhLCBwYXJzZSByYXcgdmVydGljZXMgYW5kIGRhdGEsIGNyZWF0ZSBhIHZlY3RvclxyXG4gKiB0aWxlIGFuZCBwYXJzZSBpdCBpbnRvIHJlYWR5LXRvLXJlbmRlciB2ZXJ0aWNlcy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzcG9uZFxyXG4gKi9cclxuV29ya2VyVGlsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBhY3RvciwgY2FsbGJhY2spIHtcclxuICAgIHZhciB0aWxlID0gdGhpcztcclxuICAgIHZhciBidWNrZXRJbmZvID0gV29ya2VyVGlsZS5idWNrZXRzO1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcclxuICAgIHRoaXMuY29sbGlzaW9uID0gbmV3IENvbGxpc2lvbih0aGlzLnpvb20sIHRpbGVFeHRlbnQsIHRoaXMudGlsZVNpemUsIHRoaXMuZGVwdGgpO1xyXG4gICAgdGhpcy5mZWF0dXJlVHJlZSA9IG5ldyBGZWF0dXJlVHJlZShnZXRHZW9tZXRyeSwgZ2V0VHlwZSk7XHJcblxyXG4gICAgdmFyIGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHMgPSBzb3J0VGlsZUludG9CdWNrZXRzKHRoaXMsIGRhdGEsIGJ1Y2tldEluZm8pO1xyXG5cclxuICAgIHZhciBrZXksIGJ1Y2tldDtcclxuICAgIHZhciBwcmV2UGxhY2VtZW50QnVja2V0O1xyXG5cclxuICAgIHZhciByZW1haW5pbmcgPSBXb3JrZXJUaWxlLmJ1Y2tldHMubGVuZ3RoO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgVGhlIGFzeW5jIHBhcnNpbmcgaGVyZSBpcyBhIGJpdCB0cmlja3kuXHJcbiAgICAgKiAgU29tZSBidWNrZXRzIGRlcGVuZCBvbiByZXNvdXJjZXMgdGhhdCBtYXkgbmVlZCB0byBiZSBsb2FkZWQgYXN5bmMgKGdseXBocykuXHJcbiAgICAgKiAgU29tZSBidWNrZXRzIG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyICh0byBnZXQgcGxhY2VtZW50IHByaW9yaXRpZXMgcmlnaHQpLlxyXG4gICAgICpcclxuICAgICAqICBEZXBlbmRlbmNpZXMgY2FsbHMgYXJlIGluaXRpYXRlZCBmaXJzdCB0byBnZXQgdGhvc2Ugcm9sbGluZy5cclxuICAgICAqICBCdWNrZXRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXIsIGFyZW4ndCB0byBzYXZlIHRpbWUuXHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgb3JkZXJlZEJ1Y2tldHMgPSBXb3JrZXJUaWxlLmJ1Y2tldHM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRCdWNrZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYnVja2V0ID0gYnVja2V0c1tvcmRlcmVkQnVja2V0c1tpXS5pZF07XHJcbiAgICAgICAgaWYgKCFidWNrZXQpIHtcclxuICAgICAgICAgICAgcmVtYWluaW5nLS07XHJcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyByYXN0ZXIgYnVja2V0LCBldGNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBidWNrZXQuaW5mby5maWx0ZXI7XHJcbiAgICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuc291cmNlICE9PSB0aGlzLnNvdXJjZSkgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIExpbmsgYnVja2V0cyB0aGF0IG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyXHJcbiAgICAgICAgaWYgKGJ1Y2tldC5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgaWYgKHByZXZQbGFjZW1lbnRCdWNrZXQpIHtcclxuICAgICAgICAgICAgICAgIHByZXZQbGFjZW1lbnRCdWNrZXQubmV4dCA9IGJ1Y2tldDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJ1Y2tldC5wcmV2aW91c1BsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldlBsYWNlbWVudEJ1Y2tldCA9IGJ1Y2tldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChidWNrZXQuZ2V0RGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldC5nZXREZXBlbmRlbmNpZXModGhpcywgYWN0b3IsIGRlcGVuZGVuY2llc0RvbmUoYnVja2V0KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBwYXJzZSBidWNrZXRzIHdoZXJlIG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFuZCBubyBkZXBlbmRlbmNpZXNcclxuICAgIGZvciAoa2V5IGluIGJ1Y2tldHMpIHtcclxuICAgICAgICBidWNrZXQgPSBidWNrZXRzW2tleV07XHJcbiAgICAgICAgaWYgKCFidWNrZXQuZ2V0RGVwZW5kZW5jaWVzICYmICFidWNrZXQuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlcGVuZGVuY2llc0RvbmUoYnVja2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBidWNrZXQuZGVwZW5kZW5jaWVzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBlcnIpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBza2lwKSB7XHJcbiAgICAgICAgaWYgKGJ1Y2tldC5nZXREZXBlbmRlbmNpZXMgJiYgIWJ1Y2tldC5kZXBlbmRlbmNpZXNMb2FkZWQpIHJldHVybjtcclxuICAgICAgICBpZiAoYnVja2V0LmNvbGxpc2lvbiAmJiAhYnVja2V0LnByZXZpb3VzUGxhY2VkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghc2tpcCkge1xyXG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKGJ1Y2tldC50eXBlICE9PSAncmFzdGVyJykgYnVja2V0LmFkZEZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcclxuICAgICAgICAgICAgaWYgKGJ1Y2tldC5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGJ1Y2tldC5mZWF0dXJlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlLmZlYXR1cmVUcmVlLmluc2VydChmZWF0dXJlLmJib3goKSwgYnVja2V0Lm5hbWUsIGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHMgPSBzZWxmLmJ1Y2tldFN0YXRzIHx8IHtfdG90YWw6IDB9O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5idWNrZXRTdGF0cy5fdG90YWwgKz0gdGltZTtcclxuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHNbYnVja2V0Lm5hbWVdID0gKHNlbGYuYnVja2V0U3RhdHNbYnVja2V0Lm5hbWVdIHx8IDApICsgdGltZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVtYWluaW5nLS07XHJcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIHJldHVybiB0aWxlLmRvbmUoKTtcclxuXHJcbiAgICAgICAgLy8gdHJ5IHBhcnNpbmcgdGhlIG5leHQgYnVja2V0LCBpZiBpdCBpcyByZWFkeVxyXG4gICAgICAgIGlmIChidWNrZXQubmV4dCkge1xyXG4gICAgICAgICAgICBidWNrZXQubmV4dC5wcmV2aW91c1BsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldC5uZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBDb2xsZWN0IGFsbCBidWZmZXJzIHRvIG1hcmsgdGhlbSBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0LlxyXG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuYnVmZmVycykge1xyXG4gICAgICAgIGJ1ZmZlcnMucHVzaCh0aGlzLmJ1ZmZlcnNbdHlwZV0uYXJyYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgYnVja2V0cyB0byBhIHRyYW5zZmVyYWJsZSBmb3JtYXRcclxuICAgIHZhciBidWNrZXRzID0gdGhpcy5idWNrZXRzO1xyXG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB7fTtcclxuICAgIGZvciAodmFyIGIgaW4gYnVja2V0cykgZWxlbWVudEdyb3Vwc1tiXSA9IGJ1Y2tldHNbYl0uZWxlbWVudEdyb3VwcztcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHtcclxuICAgICAgICBlbGVtZW50R3JvdXBzOiBlbGVtZW50R3JvdXBzLFxyXG4gICAgICAgIGJ1ZmZlcnM6IHRoaXMuYnVmZmVyc1xyXG4gICAgfSwgYnVmZmVycyk7XHJcblxyXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnl0aGluZyBleGNlcHQgZmVhdHVyZVRyZWUgYXQgdGhpcyBwb2ludCwgc28gd2UgbWFyayBpdCBmb3IgR0NcclxuICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XHJcbiAgICB0aGlzLmNvbGxpc2lvbiA9IG51bGw7XHJcbiAgICB0aGlzLmJ1Y2tldHMgPSBudWxsO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc29ydFRpbGVJbnRvQnVja2V0cyh0aWxlLCBkYXRhLCBidWNrZXRJbmZvKSB7XHJcblxyXG4gICAgdmFyIHNvdXJjZUxheWVycyA9IHt9LFxyXG4gICAgICAgIGJ1Y2tldHMgPSB7fSxcclxuICAgICAgICBsYXllck5hbWU7XHJcblxyXG4gICAgLy8gRm9yIGVhY2ggc291cmNlIGxheWVyLCBmaW5kIGEgbGlzdCBvZiBidWNrZXRzIHRoYXQgdXNlIGRhdGEgZnJvbSBpdFxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRJbmZvLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSBidWNrZXRJbmZvW2ldO1xyXG4gICAgICAgIHZhciBidWNrZXROYW1lID0gaW5mby5pZDtcclxuXHJcbiAgICAgICAgdmFyIG1pblpvb20gPSBpbmZvWydtaW4tem9vbSddO1xyXG4gICAgICAgIHZhciBtYXhab29tID0gaW5mb1snbWF4LXpvb20nXTtcclxuXHJcbiAgICAgICAgaWYgKGluZm8uc291cmNlICE9PSB0aWxlLnNvdXJjZSkgY29udGludWU7XHJcbiAgICAgICAgaWYgKG1pblpvb20gJiYgdGlsZS56b29tIDwgbWluWm9vbSAmJiBtaW5ab29tIDwgdGlsZS5tYXhab29tKSBjb250aW51ZTtcclxuICAgICAgICBpZiAobWF4Wm9vbSAmJiB0aWxlLnpvb20gPj0gbWF4Wm9vbSkgY29udGludWU7XHJcblxyXG4gICAgICAgIHZhciBidWNrZXQgPSBjcmVhdGVCdWNrZXQoaW5mbywgdGlsZS5idWZmZXJzLCB0aWxlLmNvbGxpc2lvbik7XHJcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xyXG4gICAgICAgIGJ1Y2tldC5mZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgIGJ1Y2tldC5uYW1lID0gYnVja2V0TmFtZTtcclxuICAgICAgICBidWNrZXRzW2J1Y2tldE5hbWVdID0gYnVja2V0O1xyXG5cclxuICAgICAgICBpZiAoZGF0YS5sYXllcnMpIHtcclxuICAgICAgICAgICAgLy8gdmVjdG9ydGlsZVxyXG4gICAgICAgICAgICBsYXllck5hbWUgPSBpbmZvWydzb3VyY2UtbGF5ZXInXTtcclxuICAgICAgICAgICAgaWYgKCFzb3VyY2VMYXllcnNbbGF5ZXJOYW1lXSkgc291cmNlTGF5ZXJzW2xheWVyTmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgc291cmNlTGF5ZXJzW2xheWVyTmFtZV1bYnVja2V0TmFtZV0gPSBpbmZvO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdlb2pzb24gdGlsZVxyXG4gICAgICAgICAgICBzb3VyY2VMYXllcnNbYnVja2V0TmFtZV0gPSBpbmZvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyByZWFkIGVhY2ggbGF5ZXIsIGFuZCBzb3J0IGl0cyBmZWF0dXJlJ3MgaW50byBidWNrZXRzXHJcbiAgICBpZiAoZGF0YS5sYXllcnMpIHtcclxuICAgICAgICAvLyB2ZWN0b3J0aWxlXHJcbiAgICAgICAgZm9yIChsYXllck5hbWUgaW4gc291cmNlTGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGRhdGEubGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgc291cmNlTGF5ZXJzW2xheWVyTmFtZV0sIGJ1Y2tldHMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZ2VvanNvblxyXG4gICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGRhdGEsIHNvdXJjZUxheWVycywgYnVja2V0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJ1Y2tldHM7XHJcbn1cclxuXHJcbi8qXHJcbiAqIFNvcnRzIGZlYXR1cmVzIGluIGEgbGF5ZXIgaW50byBkaWZmZXJlbnQgYnVja2V0cywgYWNjb3JkaW5nIHRvIHRoZSBtYXBpbmdcclxuICpcclxuICogTGF5ZXJzIGluIHZlY3RvciB0aWxlcyBjb250YWluIG1hbnkgZGlmZmVyZW50IGZlYXR1cmVzLCBhbmQgZmVhdHVyZSB0eXBlcyxcclxuICogZS5nLiB0aGUgbGFuZHVzZSBsYXllciBoYXMgcGFya3MsIGluZHVzdHJpYWwgYnVpbGRpbmdzLCBmb3Jlc3RzLCBwbGF5Z3JvdW5kc1xyXG4gKiBldGMuIEhvd2V2ZXIsIHdoZW4gc3R5bGluZywgd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGVzZSBmZWF0dXJlcyBzbyB0aGF0IHdlIGNhblxyXG4gKiByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IHdpdGggZGlmZmVyZW50IHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtWZWN0b3JUaWxlTGF5ZXJ9IGxheWVyXHJcbiAqIEBwYXJhbSB7TWFwcGluZ30gbWFwcGluZ1xyXG4gKi9cclxuZnVuY3Rpb24gc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIG1hcHBpbmcsIGJ1Y2tldHMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcHBpbmcpIHtcclxuICAgICAgICAgICAgaWYgKG1hcHBpbmdba2V5XS5jb21wYXJlKGZlYXR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICBidWNrZXRzW2tleV0uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0R2VvbWV0cnkoZmVhdHVyZSkge1xyXG4gICAgcmV0dXJuIGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFR5cGUoZmVhdHVyZSkge1xyXG4gICAgcmV0dXJuIHZ0LlZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV07XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25Mb29wO1xyXG5cclxuZnVuY3Rpb24gQW5pbWF0aW9uTG9vcCgpIHtcclxuICAgIHRoaXMubiA9IDA7XHJcbiAgICB0aGlzLnRpbWVzID0gW107XHJcbn1cclxuXHJcbi8vIEFyZSBhbGwgYW5pbWF0aW9ucyBkb25lP1xyXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5zdG9wcGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xyXG4gICAgICAgIHJldHVybiB0LnRpbWUgPj0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICF0aGlzLnRpbWVzLmxlbmd0aDtcclxufTtcclxuXHJcbi8vIEFkZCBhIG5ldyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biB0IG1pbGxpc2Vjb25kc1xyXG4vLyBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIGl0IGxheWVyXHJcbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHQpIHtcclxuICAgIHRoaXMudGltZXMucHVzaCh7IGlkOiB0aGlzLm4sIHRpbWU6IHQgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMubisrO1xyXG59O1xyXG5cclxuLy8gQ2FuY2VsIGFuIGFuaW1hdGlvblxyXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihuKSB7XHJcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xyXG4gICAgICAgIHJldHVybiB0LmlkICE9IG47XHJcbiAgICB9KTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlRmVhdHVyZTtcclxuXHJcbmZ1bmN0aW9uIGluZml4KG9wZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgKyAnICcgKyBvcGVyYXRvciArICcgJyArIHJpZ2h0OyB9O1xyXG59XHJcblxyXG52YXIgaW5maXhPcGVyYXRvcnMgPSB7XHJcbiAgICAnPT0nOiBpbmZpeCgnPT09JyksXHJcbiAgICAnPic6IGluZml4KCc+JyksICckZ3QnOiBpbmZpeCgnPicpLFxyXG4gICAgJzwnOiBpbmZpeCgnPCcpLCAnJGx0JzogaW5maXgoJzwnKSxcclxuICAgICc8PSc6IGluZml4KCc8PScpLCAnJGx0ZSc6IGluZml4KCc8PScpLFxyXG4gICAgJz49JzogaW5maXgoJz49JyksICckZ3RlJzogaW5maXgoJz49JyksXHJcbiAgICAnIT0nOiBpbmZpeCgnIT09JyksICckbmUnOiBpbmZpeCgnIT09JyksXHJcbiAgICAnJGV4aXN0cyc6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyAnICE9PSB1bmRlZmluZWQnOyB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvcihpdGVtcykgIHsgcmV0dXJuICcoJyArIGl0ZW1zLmpvaW4oJyB8fCAnKSArICcpJzsgfVxyXG5mdW5jdGlvbiBhbmQoaXRlbXMpIHsgcmV0dXJuICcoJyArIGl0ZW1zLmpvaW4oJyAmJiAnKSArICcpJzsgfVxyXG5mdW5jdGlvbiBub3QoaXRlbSkgIHsgcmV0dXJuICchJyArIGl0ZW07IH1cclxuZnVuY3Rpb24gbm9yKGl0ZW1zKSB7IHJldHVybiBub3Qob3IoaXRlbXMpKTsgfVxyXG5cclxudmFyIGFycmF5T3BlcmF0b3JzID0ge1xyXG4gICAgJ3x8Jzogb3IsICckb3InOiBvcixcclxuICAgICcmJic6IGFuZCwgJyRhbmQnOiBhbmQsXHJcbiAgICAnISc6IG5vciwgJyRub3InOiBub3JcclxufTtcclxuXHJcbnZhciBvYmpPcGVyYXRvcnMgPSB7XHJcbiAgICAnISc6IG5vdCwgJyRub3QnOiBub3RcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgLy8gc2ltcGxlIGtleSAmIHZhbHVlIGNvbXBhcmlzb25cclxuICAgIGZ1bmN0aW9uIHZhbHVlRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKCdwWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXBhcmVzIGtleSAmIHZhbHVlIG9yIGtleSAmIG9yKHZhbHVlcylcclxuICAgIGZ1bmN0aW9uIHNpbXBsZUZpZWxkRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIG9wZXJhdG9yRm4gPSBpbmZpeE9wZXJhdG9yc1tvcGVyYXRvciB8fCAnPT0nXTtcclxuICAgICAgICBpZiAoIW9wZXJhdG9yRm4pIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvcGVyYXRvcjogJyArIG9wZXJhdG9yKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcih2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUZpbHRlcihrZXksIHYsIG9wZXJhdG9yRm4pO1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSByZXR1cm4gdmFsdWVGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3JGbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFuZGxlcyBhbnkgZmlsdGVyIGtleS92YWx1ZSBwYWlyXHJcbiAgICBmdW5jdGlvbiBmaWVsZEZpbHRlcihrZXksIHZhbHVlKSB7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIGFycmF5T3BlcmF0b3JzKSB7IC8vIGhhbmRsZSBhbmQvb3Igb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlPcGVyYXRvcnNba2V5XSh2YWx1ZS5tYXAoZmllbGRzRmlsdGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgbm90IG9wZXJhdG9yXHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqT3BlcmF0b3JzKSByZXR1cm4gb2JqT3BlcmF0b3JzW2tleV0oZmllbGRzRmlsdGVyKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUge2tleToge29wZXJhdG9yOiB2YWx1ZX19IG5vdGF0aW9uXHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIG9wIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goc2ltcGxlRmllbGRGaWx0ZXIoa2V5LCB2YWx1ZVtvcF0sIG9wKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFuZChmaWx0ZXJzKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhhbmRsZSBzaW1wbGUga2V5L3ZhbHVlIG9yIGtleS92YWx1ZXMgY29tcGFyaXNvblxyXG4gICAgICAgIHJldHVybiBzaW1wbGVGaWVsZEZpbHRlcihrZXksIHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0eXBlRmlsdGVyKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gJ2YudHlwZSA9PT0gJyArIFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzLmluZGV4T2YodHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmllbGRzRmlsdGVyKG9iaikge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHR5cGVGaWx0ZXIob2JqW2tleV0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaChmaWVsZEZpbHRlcihrZXksIG9ialtrZXldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzLmxlbmd0aCA/IGFuZChmaWx0ZXJzKSA6ICd0cnVlJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsdGVyU3RyID0gJ3ZhciBwID0gZi5wcm9wZXJ0aWVzIHx8IHt9OyByZXR1cm4gJyArIGZpZWxkc0ZpbHRlcihmaWx0ZXIgfHwge30pICsgJzsnO1xyXG5cclxuICAgIC8vIGpzaGludCBldmlsOiB0cnVlXHJcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdmJywgZmlsdGVyU3RyKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxucmVmZXJlbmNlWydjbGFzcyddLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XHJcbiAgICB2YXIgQ2FsY3VsYXRlZCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICB2YXIgc3R5bGUgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcclxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcclxuICAgICAgICBpZiAoc3R5bGVbcHJvcF1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgICAgICBDYWxjdWxhdGVkLnByb3RvdHlwZVtwcm9wXSA9IHN0eWxlW3Byb3BdWydkZWZhdWx0J107XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgnY2xhc3NfJywnJyldID0gQ2FsY3VsYXRlZDtcclxufSk7XHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpO1xyXG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpO1xyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNwcml0ZTtcclxuXHJcbmZ1bmN0aW9uIEltYWdlU3ByaXRlKGJhc2UpIHtcclxuXHJcbiAgICB2YXIgc3ByaXRlID0gdGhpcztcclxuICAgIHRoaXMuYmFzZSA9IGJhc2U7XHJcbiAgICB0aGlzLnJldGluYSA9IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XHJcblxyXG4gICAgYmFzZSA9IHNwcml0ZS5iYXNlICsgKHNwcml0ZS5yZXRpbmEgPyAnQDJ4JyA6ICcnKTtcclxuXHJcbiAgICBhamF4LmdldEpTT04oYmFzZSArICcuanNvbicsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xyXG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMgdmlhIHNwcml0ZSBldmVudC5cclxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XHJcbiAgICAgICAgc3ByaXRlLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIGlmIChzcHJpdGUuaW1nKSBzcHJpdGUuZmlyZSgnbG9hZGVkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhamF4LmdldEltYWdlKGJhc2UgKyAnLnBuZycsIGZ1bmN0aW9uKGVyciwgaW1nKSB7XHJcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycyB2aWEgc3ByaXRlIGV2ZW50LlxyXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxyXG4gICAgICAgIHZhciBkYXRhID0gaW1nLmdldERhdGEoKTtcclxuICAgICAgICB2YXIgbmV3ZGF0YSA9IGltZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrPTQpIHtcclxuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XHJcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDBdID0gZGF0YVtpICsgMF0gKiBhbHBoYTtcclxuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSAqIGFscGhhO1xyXG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XHJcbiAgICAgICAgICAgIG5ld2RhdGFbaSArIDNdID0gZGF0YVtpICsgM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcHJpdGUuaW1nID0gaW1nO1xyXG4gICAgICAgIGlmIChzcHJpdGUuZGF0YSkgc3ByaXRlLmZpcmUoJ2xvYWRlZCcpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XHJcblxyXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xyXG59O1xyXG5cclxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmJiB0aGlzLmltZyk7XHJcbn07XHJcblxyXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oZ2wpIHtcclxuICAgIHZhciBzcHJpdGUgPSB0aGlzO1xyXG4gICAgaWYgKGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgIT09IHNwcml0ZS5yZXRpbmEpIHtcclxuXHJcbiAgICAgICAgdmFyIG5ld1Nwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzcHJpdGUuYmFzZSk7XHJcbiAgICAgICAgbmV3U3ByaXRlLm9uKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIHNwcml0ZS5pbWcgPSBuZXdTcHJpdGUuaW1nO1xyXG4gICAgICAgICAgICBzcHJpdGUuZGF0YSA9IG5ld1Nwcml0ZS5kYXRhO1xyXG4gICAgICAgICAgICBzcHJpdGUucmV0aW5hID0gbmV3U3ByaXRlLnJldGluYTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzcHJpdGUudGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShzcHJpdGUudGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc3ByaXRlLnRleHR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBsaW5lYXIpIHtcclxuICAgIHZhciBzcHJpdGUgPSB0aGlzO1xyXG5cclxuICAgIGlmICghc3ByaXRlLmxvYWRlZCgpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZiAoIXNwcml0ZS50ZXh0dXJlKSB7XHJcbiAgICAgICAgc3ByaXRlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc3ByaXRlLnRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIHZhciBpbWcgPSBzcHJpdGUuaW1nO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcuZGF0YSk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzcHJpdGUudGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpbHRlciA9IGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XHJcbiAgICBpZiAoZmlsdGVyICE9PSBzcHJpdGUuZmlsdGVyKSB7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihuYW1lLCByZXBlYXRpbmcpIHtcclxuXHJcbiAgICAvLyBgcmVwZWF0aW5nYCBpbmRpY2F0ZXMgdGhhdCB0aGUgaW1hZ2Ugd2lsbCBiZSB1c2VkIGluIGEgcmVwZWF0aW5nIHBhdHRlcm5cclxuICAgIC8vIHJlcGVhdGluZyBwYXR0ZXJuIGltYWdlcyBhcmUgYXNzdW1lZCB0byBoYXZlIGEgMXB4IHBhZGRpbmcgdGhhdCBtaXJyb3JzIHRoZSBvcHBvc2l0ZSBlZGdlXHJcbiAgICAvLyBwb3NpdGlvbnMgZm9yIHJlcGVhdGluZyBpbWFnZXMgYXJlIGFkanVzdGVkIHRvIGV4Y2x1ZGUgdGhlIGVkZ2VcclxuICAgIHJlcGVhdGluZyA9IHJlcGVhdGluZyA9PT0gdHJ1ZSA/IDEgOiAwO1xyXG5cclxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xyXG4gICAgaWYgKHBvcyAmJiB0aGlzLmltZykge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuaW1nLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmltZy5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2l6ZTogW3Bvcy53aWR0aCAvIHBvcy5waXhlbFJhdGlvLCBwb3MuaGVpZ2h0IC8gcG9zLnBpeGVsUmF0aW9dLFxyXG4gICAgICAgICAgICB0bDogWyhwb3MueCArIHJlcGVhdGluZykvIHdpZHRoLCAocG9zLnkgKyByZXBlYXRpbmcpIC8gaGVpZ2h0XSxcclxuICAgICAgICAgICAgYnI6IFsocG9zLnggKyBwb3Mud2lkdGggLSAyICogcmVwZWF0aW5nKSAvIHdpZHRoLCAocG9zLnkgKyBwb3MuaGVpZ2h0IC0gMiAqIHJlcGVhdGluZykgLyBoZWlnaHRdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvdjUnKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxucmVmZXJlbmNlLnJlbmRlci5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xyXG4gICAgdmFyIFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wcykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdGhpc1twXSA9IHByb3BzW3BdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHByb3BlcnRpZXMgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcclxuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcbiAgICAgICAgUHJvcGVydGllcy5wcm90b3R5cGVbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdWydkZWZhdWx0J107XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgncmVuZGVyXycsJycpXSA9IFByb3BlcnRpZXM7XHJcbn0pO1xyXG5cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQuanMnKTtcclxuXHJcbnZhciBTdHlsZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3N0eWxldHJhbnNpdGlvbi5qcycpO1xyXG52YXIgU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVkZWNsYXJhdGlvbi5qcycpO1xyXG52YXIgU3R5bGVDb25zdGFudCA9IHJlcXVpcmUoJy4vc3R5bGVjb25zdGFudC5qcycpO1xyXG52YXIgQ2FsY3VsYXRlZFN0eWxlID0gcmVxdWlyZSgnLi9jYWxjdWxhdGVkc3R5bGUuanMnKTtcclxudmFyIEltYWdlU3ByaXRlID0gcmVxdWlyZSgnLi9pbWFnZXNwcml0ZS5qcycpO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XHJcblxyXG4vKlxyXG4gKiBUaGUgbWFwIHN0eWxlJ3MgY3VycmVudCBzdGF0ZVxyXG4gKlxyXG4gKiBUaGUgc3R5bGVzaGVldCBvYmplY3QgaXMgbm90IG1vZGlmaWVkLiBUbyBjaGFuZ2UgdGhlIHN0eWxlLCBqdXN0IGNoYW5nZVxyXG4gKiB0aGUgdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGFuZCB0cmlnZ2VyIGEgY2FzY2FkZS5cclxuICovXHJcbmZ1bmN0aW9uIFN0eWxlKHN0eWxlc2hlZXQsIGFuaW1hdGlvbkxvb3ApIHtcclxuICAgIGlmIChzdHlsZXNoZWV0LnZlcnNpb24gIT09IDUpIGNvbnNvbGUud2FybignU3R5bGVzaGVldCB2ZXJzaW9uIG11c3QgYmUgNScpO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlc2hlZXQubGF5ZXJzKSkgY29uc29sZS53YXJuKCdTdHlsZXNoZWV0IG11c3QgaGF2ZSBsYXllcnMnKTtcclxuXHJcbiAgICB0aGlzLmNsYXNzZXMgPSB7fTtcclxuICAgIHRoaXMuc3R5bGVzaGVldCA9IHN0eWxlc2hlZXQ7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSBhbmltYXRpb25Mb29wO1xyXG5cclxuICAgIHRoaXMuYnVja2V0cyA9IHt9O1xyXG4gICAgdGhpcy5vcmRlcmVkQnVja2V0cyA9IFtdO1xyXG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5jb21wdXRlZCA9IHt9O1xyXG4gICAgdGhpcy5zb3VyY2VzID0ge307XHJcblxyXG4gICAgdGhpcy5jYXNjYWRlKHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xyXG5cclxuICAgIGlmIChzdHlsZXNoZWV0LnNwcml0ZSkgdGhpcy5zZXRTcHJpdGUoc3R5bGVzaGVldC5zcHJpdGUpO1xyXG59XHJcblxyXG5TdHlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50ZWQpO1xyXG5cclxuZnVuY3Rpb24gcHJlbXVsdGlwbHlMYXllcihsYXllciwgdHlwZSkge1xyXG4gICAgdmFyIGNvbG9yUHJvcCA9IHR5cGUgKyAnLWNvbG9yJyxcclxuICAgICAgICBoYWxvUHJvcCA9IHR5cGUgKyAnLWhhbG8tY29sb3InLFxyXG4gICAgICAgIG91dGxpbmVQcm9wID0gdHlwZSArICctb3V0bGluZS1jb2xvcicsXHJcbiAgICAgICAgY29sb3IgPSBsYXllcltjb2xvclByb3BdLFxyXG4gICAgICAgIGhhbG9Db2xvciA9IGxheWVyW2hhbG9Qcm9wXSxcclxuICAgICAgICBvdXRsaW5lQ29sb3IgPSBsYXllcltvdXRsaW5lUHJvcF0sXHJcbiAgICAgICAgb3BhY2l0eSA9IGxheWVyW3R5cGUgKyAnLW9wYWNpdHknXTtcclxuXHJcbiAgICB2YXIgY29sb3JPcGFjaXR5ID0gY29sb3IgJiYgKG9wYWNpdHkgKiBjb2xvclszXSk7XHJcbiAgICB2YXIgaGFsb09wYWNpdHkgPSBoYWxvQ29sb3IgJiYgKG9wYWNpdHkgKiBoYWxvQ29sb3JbM10pO1xyXG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gb3V0bGluZUNvbG9yICYmIChvcGFjaXR5ICogb3V0bGluZUNvbG9yWzNdKTtcclxuXHJcbiAgICBpZiAoY29sb3JPcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgY29sb3JPcGFjaXR5IDwgMSkge1xyXG4gICAgICAgIGxheWVyW2NvbG9yUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBjb2xvck9wYWNpdHldKTtcclxuICAgIH1cclxuICAgIGlmIChoYWxvT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIGhhbG9PcGFjaXR5IDwgMSkge1xyXG4gICAgICAgIGxheWVyW2hhbG9Qcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW2hhbG9Db2xvclswXSwgaGFsb0NvbG9yWzFdLCBoYWxvQ29sb3JbMl0sIGhhbG9PcGFjaXR5XSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3V0bGluZU9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBvdXRsaW5lT3BhY2l0eSA8IDEpIHtcclxuICAgICAgICBsYXllcltvdXRsaW5lUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBGb3JtZXJseSBrbm93biBhcyB6b29tZWQgc3R5bGVzXHJcblN0eWxlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uKHopIHtcclxuICAgIGlmICh0eXBlb2YgeiAhPT0gJ251bWJlcicpIGNvbnNvbGUud2FybigncmVjYWxjdWxhdGUgZXhwZWN0cyB6b29tIGxldmVsJyk7XHJcblxyXG4gICAgdmFyIHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9ucztcclxuICAgIHZhciBsYXllclZhbHVlcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xyXG5cclxuICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gMzAwO1xyXG5cclxuICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNpdGlvbnMpIHtcclxuICAgICAgICB2YXIgbGF5ZXIgPSB0cmFuc2l0aW9uc1tuYW1lXSxcclxuICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5idWNrZXRzW2xheWVyLnJlZiB8fCBuYW1lXSxcclxuICAgICAgICAgICAgbGF5ZXJUeXBlID0gdGhpcy5sYXllcm1hcFtuYW1lXS50eXBlO1xyXG5cclxuICAgICAgICBpZiAoIUNhbGN1bGF0ZWRTdHlsZVtsYXllclR5cGVdKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndW5rbm93biBsYXllciB0eXBlICcgKyBsYXllclR5cGUpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFwcGxpZWRMYXllciA9IGxheWVyVmFsdWVzW25hbWVdID0gbmV3IENhbGN1bGF0ZWRTdHlsZVtsYXllclR5cGVdKCk7XHJcbiAgICAgICAgZm9yICh2YXIgcnVsZSBpbiBsYXllcikge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGxheWVyW3J1bGVdO1xyXG4gICAgICAgICAgICBhcHBsaWVkTGF5ZXJbcnVsZV0gPSB0cmFuc2l0aW9uLmF0KHopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ3N5bWJvbCcpIHtcclxuICAgICAgICAgICAgYXBwbGllZExheWVyLmhpZGRlbiA9XHJcbiAgICAgICAgICAgICAgICAoYXBwbGllZExheWVyWyd0ZXh0LW9wYWNpdHknXSA9PT0gMCB8fCAhYnVja2V0LnJlbmRlclsndGV4dC1maWVsZCddKSAmJlxyXG4gICAgICAgICAgICAgICAgKGFwcGxpZWRMYXllclsnaWNvbi1vcGFjaXR5J10gPT09IDAgfHwgIWJ1Y2tldC5yZW5kZXJbJ2ljb24taW1hZ2UnXSk7XHJcbiAgICAgICAgICAgIGlmICghYXBwbGllZExheWVyLmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlMYXllcihhcHBsaWVkTGF5ZXIsICd0ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgJ2ljb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFwcGxpZWRMYXllci5oaWRkZW4gPSAoYXBwbGllZExheWVyW2xheWVyVHlwZSArICctb3BhY2l0eSddID09PSAwKTtcclxuICAgICAgICAgICAgaWYgKCFhcHBsaWVkTGF5ZXIuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgbGF5ZXJUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIHNvdXJjZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHVzZWRcclxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBhdXRvbWF0aWNhbGx5IGVuYWJsZS9kaXNhYmxlIHRoZW0gYXMgbmVlZGVkXHJcbiAgICAgICAgaWYgKCFhcHBsaWVkTGF5ZXIuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBidWNrZXQgJiYgYnVja2V0LnNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1hcmsgc291cmNlIGFzIHVzZWQgc28gdGhhdCB0aWxlcyBhcmUgZG93bmxvYWRlZFxyXG4gICAgICAgICAgICBpZiAoc291cmNlKSB0aGlzLnNvdXJjZXNbc291cmNlXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXBwbGllZExheWVyWydyYXN0ZXItZmFkZS1kdXJhdGlvbiddKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gTWF0aC5tYXgodGhpcy5yYXN0ZXJGYWRlRHVyYXRpb24sIGFwcGxpZWRMYXllclsncmFzdGVyLWZhZGUtZHVyYXRpb24nXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcHV0ZWQgPSBsYXllclZhbHVlcztcclxuXHJcbiAgICB0aGlzLnogPSB6O1xyXG4gICAgdGhpcy5maXJlKCd6b29tJyk7XHJcbn07XHJcblxyXG5TdHlsZS5wcm90b3R5cGUuX3NpbXBsZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcclxuICAgIHZhciBzaW1wbGUgPSB7fTtcclxuICAgIHNpbXBsZS5pZCA9IGxheWVyLmlkO1xyXG5cclxuICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcclxuICAgIGlmIChidWNrZXQpIHNpbXBsZS5idWNrZXQgPSBidWNrZXQuaWQ7XHJcbiAgICBpZiAobGF5ZXIudHlwZSkgc2ltcGxlLnR5cGUgPSBsYXllci50eXBlO1xyXG5cclxuICAgIGlmIChsYXllci5sYXllcnMpIHtcclxuICAgICAgICBzaW1wbGUubGF5ZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2ltcGxlLmxheWVycy5wdXNoKHRoaXMuX3NpbXBsZUxheWVyKGxheWVyLmxheWVyc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaW1wbGU7XHJcbn07XHJcblxyXG4vLyBTcGxpdCB0aGUgbGF5ZXJzIGludG8gZ3JvdXBzIG9mIGNvbnNlY3V0aXZlIGxheWVycyB3aXRoIHRoZSBzYW1lIGRhdGFzb3VyY2VcclxuU3R5bGUucHJvdG90eXBlLl9ncm91cExheWVycyA9IGZ1bmN0aW9uKGxheWVycykge1xyXG4gICAgdmFyIGcgPSAwO1xyXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xyXG4gICAgdmFyIGdyb3VwO1xyXG5cclxuICAgIC8vIGxvb3Agb3ZlciBsYXllcnMgdG9wIGRvd25cclxuICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XHJcblxyXG4gICAgICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcclxuICAgICAgICB2YXIgc291cmNlID0gYnVja2V0ICYmIGJ1Y2tldC5zb3VyY2U7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxheWVyIGlzIGluIGEgZGlmZmVyZW50IHNvdXJjZVxyXG4gICAgICAgIGlmIChncm91cCAmJiBzb3VyY2UgIT09IGdyb3VwLnNvdXJjZSkgZysrO1xyXG5cclxuICAgICAgICBpZiAoIWdyb3Vwc1tnXSkge1xyXG4gICAgICAgICAgICBncm91cCA9IFtdO1xyXG4gICAgICAgICAgICBncm91cC5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIGdyb3Vwc1tnXSA9IGdyb3VwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ3JvdXAucHVzaCh0aGlzLl9zaW1wbGVMYXllcihsYXllcikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBncm91cHM7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBUYWtlIGFsbCB0aGUgcnVsZXMgYW5kIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBzdHlsZXNoZWV0LFxyXG4gKiBhbmQgZmlndXJlIG91dCB3aGljaCBhcHBseSBjdXJyZW50bHlcclxuICovXHJcblN0eWxlLnByb3RvdHlwZS5jYXNjYWRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xyXG4gICAgICAgIHRyYW5zaXRpb246IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGEsIGI7XHJcbiAgICB2YXIgaWQ7XHJcbiAgICB2YXIgcHJvcDtcclxuICAgIHZhciBsYXllcjtcclxuICAgIHZhciBjbGFzc05hbWU7XHJcbiAgICB2YXIgc3R5bGVOYW1lO1xyXG4gICAgdmFyIHN0eWxlO1xyXG4gICAgdmFyIHN0eWxlVHJhbnM7XHJcbiAgICB2YXIgY29uc3RhbnRzID0gdGhpcy5zdHlsZXNoZWV0LmNvbnN0YW50cztcclxuXHJcbiAgICAvLyBkZXJpdmUgYnVja2V0cyBmcm9tIGxheWVyc1xyXG4gICAgdGhpcy5vcmRlcmVkQnVja2V0cyA9IFtdO1xyXG4gICAgdGhpcy5idWNrZXRzID0gZ2V0YnVja2V0cyh7fSwgdGhpcy5vcmRlcmVkQnVja2V0cywgdGhpcy5zdHlsZXNoZWV0LmxheWVycyk7XHJcbiAgICBmdW5jdGlvbiBnZXRidWNrZXRzKGJ1Y2tldHMsIG9yZGVyZWQsIGxheWVycykge1xyXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbGF5ZXJzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1thXTtcclxuICAgICAgICAgICAgaWYgKGxheWVyLmxheWVycykge1xyXG4gICAgICAgICAgICAgICAgYnVja2V0cyA9IGdldGJ1Y2tldHMoYnVja2V0cywgb3JkZXJlZCwgbGF5ZXIubGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSB8fCAhbGF5ZXIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IHsgaWQ6IGxheWVyLmlkIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoL15zdHlsZS8pLnRlc3QocHJvcCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgYnVja2V0W3Byb3BdID0gbGF5ZXJbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVja2V0LnJlbmRlciA9IFN0eWxlQ29uc3RhbnQucmVzb2x2ZShidWNrZXQucmVuZGVyLCBjb25zdGFudHMpO1xyXG4gICAgICAgICAgICBidWNrZXRzW2xheWVyLmlkXSA9IGJ1Y2tldDtcclxuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGJ1Y2tldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidWNrZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0eWxlIGNsYXNzIGtleXNcclxuICAgIHZhciBzdHlsZU5hbWVzID0gWydzdHlsZSddO1xyXG4gICAgZm9yIChjbGFzc05hbWUgaW4gdGhpcy5jbGFzc2VzKSBzdHlsZU5hbWVzLnB1c2goJ3N0eWxlLicgKyBjbGFzc05hbWUpO1xyXG5cclxuICAgIC8vIGFwcGx5IGxheWVyIGdyb3VwIGluaGVyaXRhbmNlIHJlc3VsdGluZyBpbiBhIGZsYXR0ZW5lZCBhcnJheVxyXG4gICAgdmFyIGZsYXR0ZW5lZCA9IGZsYXR0ZW5MYXllcnModGhpcy5zdHlsZXNoZWV0LmxheWVycyk7XHJcblxyXG4gICAgLy8gbWFwIGxheWVyIGlkcyB0byBsYXllciBkZWZpbml0aW9ucyBmb3IgcmVzb2x2aW5nIHJlZnNcclxuICAgIHZhciBsYXllcm1hcCA9IHRoaXMubGF5ZXJtYXAgPSB7fTtcclxuICAgIGZvciAoYSA9IDA7IGEgPCBmbGF0dGVuZWQubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICBsYXllciA9IGZsYXR0ZW5lZFthXTtcclxuXHJcbiAgICAgICAgdmFyIG5ld0xheWVyID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcikge1xyXG4gICAgICAgICAgICBpZiAoayA9PT0gJ2xheWVycycpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBuZXdMYXllcltrXSA9IGxheWVyW2tdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGF5ZXJtYXBbbGF5ZXIuaWRdID0gbmV3TGF5ZXI7XHJcbiAgICAgICAgZmxhdHRlbmVkW2FdID0gbmV3TGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChhID0gMDsgYSA8IGZsYXR0ZW5lZC5sZW5ndGg7IGErKykge1xyXG4gICAgICAgIGZsYXR0ZW5lZFthXSA9IHJlc29sdmVMYXllcihsYXllcm1hcCwgZmxhdHRlbmVkW2FdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIGxheWVyIHJlZmVyZW5jZXMuXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlTGF5ZXIobGF5ZXJtYXAsIGxheWVyKSB7XHJcbiAgICAgICAgaWYgKCFsYXllci5yZWYgfHwgIWxheWVybWFwW2xheWVyLnJlZl0pIHJldHVybiBsYXllcjtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHJlc29sdmVMYXllcihsYXllcm1hcCwgbGF5ZXJtYXBbbGF5ZXIucmVmXSk7XHJcbiAgICAgICAgbGF5ZXIucmVuZGVyID0gcGFyZW50LnJlbmRlcjtcclxuICAgICAgICBsYXllci50eXBlID0gcGFyZW50LnR5cGU7XHJcbiAgICAgICAgbGF5ZXIuZmlsdGVyID0gcGFyZW50LmZpbHRlcjtcclxuICAgICAgICBsYXllci5zb3VyY2UgPSBwYXJlbnQuc291cmNlO1xyXG4gICAgICAgIGxheWVyWydzb3VyY2UtbGF5ZXInXSA9IHBhcmVudFsnc291cmNlLWxheWVyJ107XHJcbiAgICAgICAgbGF5ZXJbJ21pbi16b29tJ10gPSBwYXJlbnRbJ21pbi16b29tJ107XHJcbiAgICAgICAgbGF5ZXJbJ21heC16b29tJ10gPSBwYXJlbnRbJ21heC16b29tJ107XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGbGF0dGVuIGNvbXBvc2l0ZSBsYXllciBzdHJ1Y3R1cmVzLlxyXG4gICAgZnVuY3Rpb24gZmxhdHRlbkxheWVycyhsYXllcnMpIHtcclxuICAgICAgICB2YXIgZmxhdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZsYXQucHVzaChsYXllcnNbaV0pO1xyXG4gICAgICAgICAgICBpZiAobGF5ZXJzW2ldLmxheWVycykge1xyXG4gICAgICAgICAgICAgICAgZmxhdC5wdXNoLmFwcGx5KGZsYXQsIGZsYXR0ZW5MYXllcnMobGF5ZXJzW2ldLmxheWVycykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbGF0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmFuc2l0aW9ucyA9IHt9O1xyXG4gICAgdmFyIGdsb2JhbFRyYW5zID0gdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb247XHJcblxyXG4gICAgZm9yIChhIGluIGZsYXR0ZW5lZCkge1xyXG4gICAgICAgIGxheWVyID0gZmxhdHRlbmVkW2FdO1xyXG5cclxuICAgICAgICBpZCA9IGxheWVyLmlkO1xyXG4gICAgICAgIHN0eWxlID0ge307XHJcbiAgICAgICAgc3R5bGVUcmFucyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBiYXNpYyBjYXNjYWRpbmcgb2Ygc3R5bGVzXHJcbiAgICAgICAgZm9yIChiID0gMDsgYiA8IHN0eWxlTmFtZXMubGVuZ3RoOyBiKyspIHtcclxuICAgICAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVOYW1lc1tiXTtcclxuICAgICAgICAgICAgaWYgKCFsYXllcltzdHlsZU5hbWVdKSBjb250aW51ZTtcclxuICAgICAgICAgICAgLy8gc2V0IHN0eWxlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgZm9yIChwcm9wIGluIGxheWVyW3N0eWxlTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3RyYW5zaXRpb24tJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbcHJvcF0gPSBsYXllcltzdHlsZU5hbWVdW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRyYW5zW3Byb3AucmVwbGFjZSgndHJhbnNpdGlvbi0nLCAnJyldID0gbGF5ZXJbc3R5bGVOYW1lXVtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3R5bGUgPSBTdHlsZUNvbnN0YW50LnJlc29sdmUoc3R5bGUsIGNvbnN0YW50cyk7XHJcblxyXG4gICAgICAgIHZhciByZW5kZXJUeXBlID0gbGF5ZXIudHlwZTtcclxuICAgICAgICB0cmFuc2l0aW9uc1tpZF0gPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChwcm9wIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdEZWNsYXJhdGlvbiA9IG5ldyBTdHlsZURlY2xhcmF0aW9uKHJlbmRlclR5cGUsIHByb3AsIHN0eWxlW3Byb3BdKTtcclxuICAgICAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25zW2lkXSAmJiB0aGlzLnRyYW5zaXRpb25zW2lkXVtwcm9wXTtcclxuICAgICAgICAgICAgdmFyIG5ld1N0eWxlVHJhbnMgPSB7fTtcclxuICAgICAgICAgICAgbmV3U3R5bGVUcmFucy5kdXJhdGlvbiA9IHN0eWxlVHJhbnNbcHJvcF0gJiYgc3R5bGVUcmFuc1twcm9wXS5kdXJhdGlvbiA/IHN0eWxlVHJhbnNbcHJvcF0uZHVyYXRpb24gOiBnbG9iYWxUcmFucyAmJiBnbG9iYWxUcmFucy5kdXJhdGlvbiA/IGdsb2JhbFRyYW5zLmR1cmF0aW9uIDogMzAwO1xyXG4gICAgICAgICAgICBuZXdTdHlsZVRyYW5zLmRlbGF5ID0gc3R5bGVUcmFuc1twcm9wXSAmJiBzdHlsZVRyYW5zW3Byb3BdLmRlbGF5ID8gc3R5bGVUcmFuc1twcm9wXS5kZWxheSA6IGdsb2JhbFRyYW5zICYmIGdsb2JhbFRyYW5zLmRlbGF5ID8gZ2xvYmFsVHJhbnMuZGVsYXkgOiAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0eWxlVHJhbnMuZHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgbmV3U3R5bGVUcmFucy5kZWxheSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGEgbmV3IHRyYW5zaXRpb24gaWYgdGhlIGRlY2xhcmF0aW9uIGNoYW5nZWRcclxuICAgICAgICAgICAgaWYgKCFvbGRUcmFuc2l0aW9uIHx8IG9sZFRyYW5zaXRpb24uZGVjbGFyYXRpb24uanNvbiAhPT0gbmV3RGVjbGFyYXRpb24uanNvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1RyYW5zaXRpb24gPSBuZXcgU3R5bGVUcmFuc2l0aW9uKG5ld0RlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCBuZXdTdHlsZVRyYW5zKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zW2lkXVtwcm9wXSA9IG5ld1RyYW5zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUnVuIHRoZSBhbmltYXRpb24gbG9vcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ld1RyYW5zaXRpb24uaW5zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbi5sb29wSUQgPSB0aGlzLmFuaW1hdGlvbkxvb3Auc2V0KG5ld1RyYW5zaXRpb24uZW5kVGltZSAtIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLmNhbmNlbChvbGRUcmFuc2l0aW9uLmxvb3BJRCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tpZF1bcHJvcF0gPSBvbGRUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcclxuICAgIHRoaXMubGF5ZXJHcm91cHMgPSB0aGlzLl9ncm91cExheWVycyh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcclxuXHJcbiAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xyXG59O1xyXG5cclxuLyogVGhpcyBzaG91bGQgYmUgbW92ZWQgZWxzZXdoZXJlLiBMb2NhbGl6aW5nIHJlc291cmNlcyBkb2Vzbid0IGJlbG9uZyBoZXJlICovXHJcblN0eWxlLnByb3RvdHlwZS5zZXRTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpIHtcclxuICAgIHRoaXMuc3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHNwcml0ZSk7XHJcbiAgICB0aGlzLnNwcml0ZS5vbignbG9hZGVkJywgdGhpcy5maXJlLmJpbmQodGhpcywgJ2NoYW5nZScpKTtcclxufTtcclxuXHJcbi8vIE1vZGlmeSBjbGFzc2VzXHJcblN0eWxlLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKG4sIG9wdGlvbnMpIHtcclxuICAgIGlmICh0aGlzLmNsYXNzZXNbbl0pIHJldHVybjsgLy8gcHJldmVudCB1bm5lY2Vzc2FyeSByZWNhbGN1bGF0aW9uXHJcbiAgICB0aGlzLmNsYXNzZXNbbl0gPSB0cnVlO1xyXG4gICAgdGhpcy5jYXNjYWRlKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuU3R5bGUucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24obiwgb3B0aW9ucykge1xyXG4gICAgaWYgKCF0aGlzLmNsYXNzZXNbbl0pIHJldHVybjsgLy8gcHJldmVudCB1bm5lY2Vzc2FyeSByZWNhbGN1bGF0aW9uXHJcbiAgICBkZWxldGUgdGhpcy5jbGFzc2VzW25dO1xyXG4gICAgdGhpcy5jYXNjYWRlKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuU3R5bGUucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24obikge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jbGFzc2VzW25dO1xyXG59O1xyXG5cclxuU3R5bGUucHJvdG90eXBlLnNldENsYXNzTGlzdCA9IGZ1bmN0aW9uKGwsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5jbGFzc2VzW2xbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuY2FzY2FkZShvcHRpb25zKTtcclxufTtcclxuXHJcblN0eWxlLnByb3RvdHlwZS5nZXRDbGFzc0xpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNsYXNzZXMpO1xyXG59O1xyXG5cclxuU3R5bGUucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiB0aGlzLmxheWVybWFwW2lkXTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbiAocHJvcGVydGllcywgY29uc3RhbnRzKSB7XHJcbiAgICBpZiAoIWNvbnN0YW50cylcclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0ge30sIGk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcgPyBjb25zdGFudHNbdmFsdWVdIDogdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSByZXNvbHZlKHByb3BlcnRpZXNba2V5XSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSBpbiBjb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlc29sdmUodmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsdWUuc3RvcHMpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLmV4dGVuZCh7fSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB2YWx1ZS5zdG9wcyA9IHZhbHVlLnN0b3BzLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdG9wc1tpXVsxXSBpbiBjb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wc1tpXSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wc1tpXVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZS5zdG9wc1tpXVsxXSlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyksXHJcbiAgICByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpLFxyXG4gICAgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3R5bGVEZWNsYXJhdGlvbjtcclxuXHJcbi8qXHJcbiAqIEEgcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGEgcHJvcGVydHk6dmFsdWUgcGFpclxyXG4gKi9cclxuZnVuY3Rpb24gU3R5bGVEZWNsYXJhdGlvbihyZW5kZXJUeXBlLCBwcm9wLCB2YWx1ZSkge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9ICdjbGFzc18nICsgcmVuZGVyVHlwZTtcclxuICAgIHZhciBwcm9wUmVmZXJlbmNlID0gcmVmZXJlbmNlW2NsYXNzTmFtZV0gJiYgcmVmZXJlbmNlW2NsYXNzTmFtZV1bcHJvcF07XHJcbiAgICBpZiAoIXByb3BSZWZlcmVuY2UpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZVZhbHVlKHZhbHVlLCBwcm9wUmVmZXJlbmNlLnR5cGUsIHByb3BSZWZlcmVuY2UudmFsdWVzKTtcclxuICAgIHRoaXMucHJvcCA9IHByb3A7XHJcbiAgICB0aGlzLnR5cGUgPSBwcm9wUmVmZXJlbmNlLnR5cGU7XHJcblxyXG4gICAgLy8gaW1tdWF0YWJsZSByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZS4gdXNlZCBmb3IgY29tcGFyaXNvblxyXG4gICAgdGhpcy5qc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG5cclxufVxyXG5cclxuU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24oeikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAnZnVuY3Rpb24nID8gdGhpcy52YWx1ZSh6KSA6IHRoaXMudmFsdWU7XHJcbn07XHJcblxyXG5TdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIHZhbHVlcykge1xyXG4gICAgaWYgKHR5cGUgPT09ICdjb2xvcicpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VDb2xvcih2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXJBcnJheSh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlbnVtJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YodmFsdWUpID49IDAgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKHR5cGUgKyAnIGlzIG5vdCBhIHN1cHBvcnRlZCBwcm9wZXJ0eSB0eXBlJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZU51bWJlcihudW0pIHtcclxuICAgIGlmIChudW0uc3RvcHMpIG51bSA9IHN0b3BzRm4obnVtKTtcclxuICAgIHZhciB2YWx1ZSA9ICtudW07XHJcbiAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSA/IHZhbHVlIDogbnVtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZU51bWJlckFycmF5KGFycmF5KSB7XHJcbiAgICB2YXIgd2lkdGhzID0gYXJyYXkubWFwKHBhcnNlTnVtYmVyKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlb2Ygd2lkdGhzW2ldID09PSAnZnVuY3Rpb24nID8gd2lkdGhzW2ldKHopIDogd2lkdGhzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBjb2xvckNhY2hlID0ge307XHJcblxyXG5mdW5jdGlvbiBwYXJzZUNvbG9yKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUuc3RvcHMpIHJldHVybiBzdG9wc0ZuKHZhbHVlLCB0cnVlKTtcclxuICAgIGlmIChjb2xvckNhY2hlW3ZhbHVlXSkgcmV0dXJuIGNvbG9yQ2FjaGVbdmFsdWVdO1xyXG5cclxuICAgIHZhciBjb2xvciA9IGNvbG9yQ2FjaGVbdmFsdWVdID0gcHJlcGFyZUNvbG9yKHBhcnNlQ1NTQ29sb3IodmFsdWUpKTtcclxuICAgIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcHNGbihwYXJhbXMsIGNvbG9yKSB7XHJcbiAgICB2YXIgc3RvcHMgPSBwYXJhbXMuc3RvcHM7XHJcbiAgICB2YXIgYmFzZSA9IHBhcmFtcy5iYXNlIHx8IHJlZmVyZW5jZS5mdW5jdGlvbi5iYXNlLmRlZmF1bHQ7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcclxuXHJcbiAgICAgICAgLy8gZmluZCB0aGUgdHdvIHN0b3BzIHdoaWNoIHRoZSBjdXJyZW50IHogaXMgYmV0d2VlblxyXG4gICAgICAgIHZhciBsb3csIGhpZ2g7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPD0geikgbG93ID0gc3RvcDtcclxuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPiB6KSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gc3RvcDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobG93ICYmIGhpZ2gpIHtcclxuICAgICAgICAgICAgdmFyIHpvb21EaWZmID0gaGlnaFswXSAtIGxvd1swXSxcclxuICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyA9IHogLSBsb3dbMF0sXHJcblxyXG4gICAgICAgICAgICAgICAgdCA9IGJhc2UgPT09IDEgP1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyAvIHpvb21EaWZmIDpcclxuICAgICAgICAgICAgICAgICAgICAoTWF0aC5wb3coYmFzZSwgem9vbVByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIHpvb21EaWZmKSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbG9yKSByZXR1cm4gaW50ZXJwQ29sb3IocGFyc2VDb2xvcihsb3dbMV0pLCBwYXJzZUNvbG9yKGhpZ2hbMV0pLCB0KTtcclxuICAgICAgICAgICAgZWxzZSByZXR1cm4gdXRpbC5pbnRlcnAobG93WzFdLCBoaWdoWzFdLCB0KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yKSByZXR1cm4gcGFyc2VDb2xvcihsb3dbMV0pO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBsb3dbMV07XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoaGlnaCkge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHJldHVybiBwYXJzZUNvbG9yKGhpZ2hbMV0pO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBoaWdoWzFdO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHJldHVybiBbMCwgMCwgMCwgMV07XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yKGMpIHtcclxuICAgIHJldHVybiBbY1swXSAvIDI1NSwgY1sxXSAvIDI1NSwgY1syXSAvIDI1NSwgY1szXSAvIDFdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnBDb2xvcihmcm9tLCB0bywgdCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICB1dGlsLmludGVycChmcm9tWzBdLCB0b1swXSwgdCksXHJcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsxXSwgdG9bMV0sIHQpLFxyXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMl0sIHRvWzJdLCB0KSxcclxuICAgICAgICB1dGlsLmludGVycChmcm9tWzNdLCB0b1szXSwgdClcclxuICAgIF07XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3R5bGVUcmFuc2l0aW9uO1xyXG5cclxuLypcclxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gZGVjbGFyYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBTdHlsZVRyYW5zaXRpb24oZGVjbGFyYXRpb24sIG9sZFRyYW5zaXRpb24sIHZhbHVlKSB7XHJcblxyXG4gICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG4gICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cclxuICAgIHZhciB0eXBlID0gZGVjbGFyYXRpb24udHlwZTtcclxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRoaXMuaW50ZXJwID0gdXRpbC5pbnRlcnA7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb2xvcicpIHtcclxuICAgICAgICB0aGlzLmludGVycCA9IGludGVycENvbG9yO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnAgPSBpbnRlcnBOdW1iZXJBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9sZFRyYW5zaXRpb24gPSBvbGRUcmFuc2l0aW9uO1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uIHx8IDA7XHJcbiAgICB0aGlzLmRlbGF5ID0gdmFsdWUuZGVsYXkgfHwgMDtcclxuXHJcbiAgICBpZiAoIXRoaXMuaW5zdGFudCgpKSB7XHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uICsgdGhpcy5kZWxheTtcclxuICAgICAgICB0aGlzLmVhc2UgPSB1dGlsLmVhc2VDdWJpY0luT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbGRUcmFuc2l0aW9uICYmIG9sZFRyYW5zaXRpb24uZW5kVGltZSA8PSB0aGlzLnN0YXJ0VGltZSkge1xyXG4gICAgICAgIC8vIE9sZCB0cmFuc2l0aW9uIGlzIGRvbmUgcnVubmluZywgc28gd2UgY2FuXHJcbiAgICAgICAgLy8gZGVsZXRlIGl0cyByZWZlcmVuY2UgdG8gaXRzIG9sZCB0cmFuc2l0aW9uLlxyXG5cclxuICAgICAgICBkZWxldGUgb2xkVHJhbnNpdGlvbi5vbGRUcmFuc2l0aW9uO1xyXG4gICAgfVxyXG59XHJcblxyXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmluc3RhbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhdGhpcy5vbGRUcmFuc2l0aW9uIHx8ICF0aGlzLmludGVycCB8fCAodGhpcy5kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLmRlbGF5ID09PSAwKTtcclxufTtcclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgYXQgem9vbSBsZXZlbCBgemAgYW5kIG9wdGlvbmFsIHRpbWUgYHRgXHJcbiAqL1xyXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oeiwgdCkge1xyXG5cclxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZGVjbGFyYXRpb24uY2FsY3VsYXRlKHopO1xyXG5cclxuICAgIGlmICh0aGlzLmluc3RhbnQoKSkgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgIHQgPSB0IHx8IERhdGUubm93KCk7XHJcblxyXG4gICAgaWYgKHQgPCB0aGlzLmVuZFRpbWUpIHtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm9sZFRyYW5zaXRpb24uYXQoeiwgdGhpcy5zdGFydFRpbWUpO1xyXG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuZWFzZSgodCAtIHRoaXMuc3RhcnRUaW1lIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uKTtcclxuICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJwKG9sZFZhbHVlLCB2YWx1ZSwgZWFzZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbnRlcnBOdW1iZXJBcnJheShmcm9tLCB0bywgdCkge1xyXG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gdXRpbC5pbnRlcnAoZCwgdG9baV0sIHQpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVycENvbG9yKGZyb20sIHRvLCB0KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMF0sIHRvWzBdLCB0KSxcclxuICAgICAgICB1dGlsLmludGVycChmcm9tWzFdLCB0b1sxXSwgdCksXHJcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsyXSwgdG9bMl0sIHQpLFxyXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bM10sIHRvWzNdLCB0KVxyXG4gICAgXTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3I7XHJcblxyXG5mdW5jdGlvbiBBbmNob3IoeCwgeSwgYW5nbGUsIHNjYWxlLCBzZWdtZW50KSB7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcclxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuXHJcbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcclxuICAgIH1cclxufVxyXG5cclxuQW5jaG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKTtcclxuXHJcbkFuY2hvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgQW5jaG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLmFuZ2xlLCB0aGlzLnNjYWxlLCB0aGlzLnNlZ21lbnQpO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpblBhY2s7XHJcbmZ1bmN0aW9uIEJpblBhY2sod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB0aGlzLmZyZWUgPSBbeyB4OiAwLCB5OiAwLCB3OiB3aWR0aCwgaDogaGVpZ2h0IH1dO1xyXG59XHJcblxyXG5CaW5QYWNrLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24ocmVjdCkge1xyXG4gICAgLy8gU2ltcGxlIGFsZ29yaXRobSB0byByZWN1cnNpdmVseSBtZXJnZSB0aGUgbmV3bHkgcmVsZWFzZWQgY2VsbCB3aXRoIGl0c1xyXG4gICAgLy8gbmVpZ2hib3IuIFRoaXMgZG9lc24ndCBtZXJnZSBtb3JlIHRoYW4gdHdvIGNlbGxzIGF0IGEgdGltZSwgYW5kIGZhaWxzXHJcbiAgICAvLyBmb3IgY29tcGxpY2F0ZWQgbWVyZ2VzLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZnJlZSA9IHRoaXMuZnJlZVtpXTtcclxuICAgICAgICBpZiAoZnJlZS55ID09IHJlY3QueSAmJiBmcmVlLmggPT0gcmVjdC5oICYmIGZyZWUueCArIGZyZWUudyA9PSByZWN0LngpIHtcclxuICAgICAgICAgICAgZnJlZS53ICs9IHJlY3QudztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJlZS54ID09IHJlY3QueCAmJiBmcmVlLncgPT0gcmVjdC53ICYmIGZyZWUueSArIGZyZWUuaCA9PSByZWN0LnkpIHtcclxuICAgICAgICAgICAgZnJlZS5oICs9IHJlY3QuaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVjdC55ID09IGZyZWUueSAmJiByZWN0LmggPT0gZnJlZS5oICYmIHJlY3QueCArIHJlY3QudyA9PSBmcmVlLngpIHtcclxuICAgICAgICAgICAgZnJlZS54ID0gcmVjdC54O1xyXG4gICAgICAgICAgICBmcmVlLncgKz0gcmVjdC53O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWN0LnggPT0gZnJlZS54ICYmIHJlY3QudyA9PSBmcmVlLncgJiYgcmVjdC55ICsgcmVjdC5oID09IGZyZWUueSkge1xyXG4gICAgICAgICAgICBmcmVlLnkgPSByZWN0Lnk7XHJcbiAgICAgICAgICAgIGZyZWUuaCArPSByZWN0Lmg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZyZWUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIHRoaXMucmVsZWFzZShmcmVlKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfVxyXG4gICAgdGhpcy5mcmVlLnB1c2gocmVjdCk7XHJcbn07XHJcblxyXG5CaW5QYWNrLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGZyZWUgcmVjdCBhbmdsZVxyXG4gICAgdmFyIHJlY3QgPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgdzogSW5maW5pdHksIGg6IEluZmluaXR5IH07XHJcbiAgICB2YXIgc21hbGxlc3QgPSAtMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuZnJlZVtpXTtcclxuICAgICAgICBpZiAod2lkdGggPD0gcmVmLncgJiYgaGVpZ2h0IDw9IHJlZi5oICYmIHJlZi55IDw9IHJlY3QueSAmJiByZWYueCA8PSByZWN0LngpIHtcclxuICAgICAgICAgICAgcmVjdCA9IHJlZjtcclxuICAgICAgICAgICAgc21hbGxlc3QgPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc21hbGxlc3QgPCAwKSB7XHJcbiAgICAgICAgLy8gVGhlcmUncyBubyBzcGFjZSBsZWZ0IGZvciB0aGlzIGNoYXIuXHJcbiAgICAgICAgcmV0dXJuIHsgeDogLTEsIHk6IC0xIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZnJlZS5zcGxpY2Uoc21hbGxlc3QsIDEpO1xyXG5cclxuICAgICAgICAvLyBTaG9ydGVyL0xvbmdlciBBeGlzIFNwbGl0IFJ1bGUgKFNBUylcclxuICAgICAgICAvLyBodHRwOi8vY2xiLmRlbW9uLmZpL2ZpbGVzL1JlY3RhbmdsZUJpblBhY2sucGRmIHAuIDE1XHJcbiAgICAgICAgLy8gSWdub3JlIHRoZSBkaW1lbnNpb24gb2YgUiBhbmQganVzdCBzcGxpdCBsb25nIHRoZSBzaG9ydGVyIGRpbWVuc2lvblxyXG4gICAgICAgIC8vIFNlZSBBbHNvOiBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfmNoYXplbGxlL3B1YnMvYmxiaW5wYWNraW5nLnBkZlxyXG4gICAgICAgIGlmIChyZWN0LncgPCByZWN0LmgpIHtcclxuICAgICAgICAgICAgLy8gc3BsaXQgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC8vICstLSstLS0rXHJcbiAgICAgICAgICAgIC8vIHxfX3xfX198ICA8LS0gYjFcclxuICAgICAgICAgICAgLy8gKy0tLS0tLSsgIDwtLSBiMlxyXG4gICAgICAgICAgICBpZiAocmVjdC53ID4gd2lkdGgpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54ICsgd2lkdGgsIHk6IHJlY3QueSwgdzogcmVjdC53IC0gd2lkdGgsIGg6IGhlaWdodCB9KTtcclxuICAgICAgICAgICAgaWYgKHJlY3QuaCA+IGhlaWdodCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LngsIHk6IHJlY3QueSArIGhlaWdodCwgdzogcmVjdC53LCBoOiByZWN0LmggLSBoZWlnaHQgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseVxyXG4gICAgICAgICAgICAvLyArLS0rLS0tK1xyXG4gICAgICAgICAgICAvLyB8X198ICAgfCA8LS0gYjFcclxuICAgICAgICAgICAgLy8gKy0tfC0tLSsgPC0tIGIyXHJcbiAgICAgICAgICAgIGlmIChyZWN0LncgPiB3aWR0aCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LnggKyB3aWR0aCwgeTogcmVjdC55LCB3OiByZWN0LncgLSB3aWR0aCwgaDogcmVjdC5oIH0pO1xyXG4gICAgICAgICAgICBpZiAocmVjdC5oID4gaGVpZ2h0KSB0aGlzLmZyZWUucHVzaCh7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgaGVpZ2h0LCB3OiB3aWR0aCwgaDogcmVjdC5oIC0gaGVpZ2h0IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgeDogcmVjdC54LCB5OiByZWN0LnksIHc6IHdpZHRoLCBoOiBoZWlnaHQgfTtcclxuICAgIH1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKSxcclxuICAgIHJvdGF0aW9uUmFuZ2UgPSByZXF1aXJlKCcuL3JvdGF0aW9ucmFuZ2UuanMnKSxcclxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uO1xyXG5cclxuZnVuY3Rpb24gQ29sbGlzaW9uKHpvb20sIHRpbGVFeHRlbnQsIHRpbGVTaXplLCBwbGFjZW1lbnREZXB0aCkge1xyXG4gICAgdGhpcy5oVHJlZSA9IHJidXNoKCk7IC8vIHRyZWUgZm9yIGhvcml6b250YWwgbGFiZWxzXHJcbiAgICB0aGlzLmNUcmVlID0gcmJ1c2goKTsgLy8gdHJlZSBmb3IgZ2x5cGhzIGZyb20gY3VydmVkIGxhYmVsc1xyXG5cclxuICAgIC8vIHRpbGUgcGl4ZWxzIHBlciBzY3JlZW4gcGl4ZWxzIGF0IHRoZSB0aWxlJ3Mgem9vbSBsZXZlbFxyXG4gICAgdGhpcy50aWxlUGl4ZWxSYXRpbyA9IHRpbGVFeHRlbnQgLyB0aWxlU2l6ZTtcclxuXHJcbiAgICB0aGlzLnpvb20gPSB6b29tO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBzY2FsZSB3ZSBjYW4gZ28gZG93biBpbiBvdXIgZmFrZS0zZCBydHJlZSBzbyB0aGF0XHJcbiAgICAvLyBwbGFjZW1lbnQgc3RpbGwgbWFrZXMgc2Vuc2UuIFRoaXMgaXMgY2FsY3VsYXRlZCBzbyB0aGF0IHRoZSBtaW5pbXVtXHJcbiAgICAvLyBwbGFjZW1lbnQgem9vbSBjYW4gYmUgYXQgbW9zdCAyNS41ICh3ZSB1c2UgYW4gdW5zaWduZWQgaW50ZWdlciB4MTAgdG9cclxuICAgIC8vIHN0b3JlIHRoZSBtaW5pbXVtIHpvb20pLlxyXG4gICAgLy9cclxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcGxhY2UgbGFiZWxzIGFsbCB0aGUgd2F5IHRvIDI1LjUuIFRoaXMgbGV0cyB0b28gbWFueVxyXG4gICAgLy8gZ2x5cGhzIGJlIHBsYWNlZCwgc2xvd2luZyBkb3duIGNvbGxpc2lvbiBjaGVja2luZy4gT25seSBwbGFjZSBsYWJlbHMgaWZcclxuICAgIC8vIHRoZXkgd2lsbCBzaG93IHVwIHdpdGhpbiB0aGUgaW50ZW5kZWQgem9vbSByYW5nZSBvZiB0aGUgdGlsZS5cclxuICAgIHBsYWNlbWVudERlcHRoID0gTWF0aC5taW4oMywgcGxhY2VtZW50RGVwdGggfHwgMSwgMjUuNSAtIHRoaXMuem9vbSk7XHJcbiAgICB0aGlzLm1heFBsYWNlbWVudFNjYWxlID0gTWF0aC5leHAoTWF0aC5MTjIgKiBwbGFjZW1lbnREZXB0aCk7XHJcblxyXG4gICAgdmFyIG0gPSA0MDk2O1xyXG4gICAgdmFyIGVkZ2UgPSBtICogdGhpcy50aWxlUGl4ZWxSYXRpbyAqIDI7XHJcblxyXG4gICAgdmFyIGZ1bGxSYW5nZSA9IFtNYXRoLlBJICogMiwgMF07XHJcblxyXG4gICAgdGhpcy5sZWZ0ID0ge1xyXG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KDAsIDApLFxyXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAtZWRnZSwgeDI6IDAsIHkyOiBlZGdlIH0sXHJcbiAgICAgICAgcGxhY2VtZW50UmFuZ2U6IGZ1bGxSYW5nZSxcclxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxyXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcclxuICAgICAgICBwYWRkaW5nOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudG9wID0ge1xyXG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KDAsIDApLFxyXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAtZWRnZSwgeDI6IGVkZ2UsIHkyOiAwIH0sXHJcbiAgICAgICAgcGxhY2VtZW50UmFuZ2U6IGZ1bGxSYW5nZSxcclxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxyXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcclxuICAgICAgICBwYWRkaW5nOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYm90dG9tID0ge1xyXG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KG0sIG0pLFxyXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAwLCB4MjogZWRnZSwgeTI6IGVkZ2UgfSxcclxuICAgICAgICBwbGFjZW1lbnRSYW5nZTogZnVsbFJhbmdlLFxyXG4gICAgICAgIHBsYWNlbWVudFNjYWxlOiAwLjUsXHJcbiAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5LFxyXG4gICAgICAgIHBhZGRpbmc6IDBcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yaWdodCA9IHtcclxuICAgICAgICBhbmNob3I6IG5ldyBQb2ludChtLCBtKSxcclxuICAgICAgICBib3g6IHsgeDE6IDAsIHkxOiAtZWRnZSwgeDI6IGVkZ2UsIHkyOiBlZGdlIH0sXHJcbiAgICAgICAgcGxhY2VtZW50UmFuZ2U6IGZ1bGxSYW5nZSxcclxuICAgICAgICBwbGFjZW1lbnRTY2FsZTogMC41LFxyXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcclxuICAgICAgICBwYWRkaW5nOiAwXHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuQ29sbGlzaW9uLnByb3RvdHlwZS5nZXRQbGFjZW1lbnRTY2FsZSA9IGZ1bmN0aW9uKGdseXBocywgbWluUGxhY2VtZW50U2NhbGUsIGF2b2lkRWRnZXMpIHtcclxuXHJcbiAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICB2YXIgdG9wID0gdGhpcy50b3A7XHJcbiAgICB2YXIgYm90dG9tID0gdGhpcy5ib3R0b207XHJcblxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBnbHlwaHMubGVuZ3RoOyBrKyspIHtcclxuXHJcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2tdO1xyXG4gICAgICAgIHZhciBib3ggPSBnbHlwaC5ib3g7XHJcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGJveDtcclxuICAgICAgICB2YXIgYW5jaG9yID0gZ2x5cGguYW5jaG9yO1xyXG4gICAgICAgIHZhciBwYWQgPSBnbHlwaC5wYWRkaW5nO1xyXG5cclxuICAgICAgICB2YXIgbWluU2NhbGUgPSBNYXRoLm1heChtaW5QbGFjZW1lbnRTY2FsZSwgZ2x5cGgubWluU2NhbGUpO1xyXG4gICAgICAgIHZhciBtYXhTY2FsZSA9IGdseXBoLm1heFNjYWxlIHx8IEluZmluaXR5O1xyXG5cclxuICAgICAgICBpZiAobWluU2NhbGUgPj0gbWF4U2NhbGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBzY2FsZWQgYm91bmRpbmcgYm94IG9mIHRoZSB1bnJvdGF0ZWQgZ2x5cGhcclxuICAgICAgICB2YXIgc2VhcmNoQm94ID0gdGhpcy5nZXRCb3goYW5jaG9yLCBiYm94LCBtaW5TY2FsZSwgbWF4U2NhbGUpO1xyXG5cclxuICAgICAgICB2YXIgYmxvY2tpbmcgPSB0aGlzLmhUcmVlLnNlYXJjaChzZWFyY2hCb3gpLmNvbmNhdCh0aGlzLmNUcmVlLnNlYXJjaChzZWFyY2hCb3gpKTtcclxuXHJcbiAgICAgICAgaWYgKGF2b2lkRWRnZXMpIHtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaEJveFswXSA8IDApIGJsb2NraW5nLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hCb3hbMV0gPCAwKSBibG9ja2luZy5wdXNoKHRvcCk7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hCb3hbMl0gPj0gNDA5NikgYmxvY2tpbmcucHVzaChyaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hCb3hbM10gPj0gNDA5NikgYmxvY2tpbmcucHVzaChib3R0b20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJsb2NraW5nLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hID0gYW5jaG9yOyAvLyBuZXcgYW5jaG9yXHJcbiAgICAgICAgICAgIHZhciBuYiA9IGJveDsgLy8gbmV3IGJveFxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBibG9ja2luZy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9hID0gYmxvY2tpbmdbbF0uYW5jaG9yOyAvLyBvbGQgYW5jaG9yXHJcbiAgICAgICAgICAgICAgICB2YXIgb2IgPSBibG9ja2luZ1tsXS5ib3g7IC8vIG9sZCBib3hcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNob3JzIGFyZSBpZGVudGljYWwsIHdlJ3JlIGdvaW5nIHRvIHNraXAgdGhlIGxhYmVsLlxyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpc24ndCByaWdodCBiZWNhdXNlIHRoZXJlIGNhbiBiZSBnbHlwaHMgd2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNhbWUgYW5jaG9yIGJ1dCBkaWZmZXJpbmcgYm94IG9mZnNldHMuXHJcbiAgICAgICAgICAgICAgICBpZiAobmEuZXF1YWxzKG9hKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRvZG86IHVuaGFyZGNvZGUgdGhlIDggPSB0aWxlRXh0ZW50L3RpbGVTaXplXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IE1hdGgubWF4KHBhZCwgYmxvY2tpbmdbbF0ucGFkZGluZykgKiA4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IChvYi54MSAtIG5iLngyIC0gcGFkZGluZykgLyAobmEueCAtIG9hLngpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBsZWZ0IG9mIG9sZCBib3hcclxuICAgICAgICAgICAgICAgIHZhciBzMiA9IChvYi54MiAtIG5iLngxICsgcGFkZGluZykgLyAobmEueCAtIG9hLngpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSByaWdodCBvZiBvbGQgYm94XHJcbiAgICAgICAgICAgICAgICB2YXIgczMgPSAob2IueTEgLSBuYi55MiAtIHBhZGRpbmcpIC8gKG5hLnkgLSBvYS55KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgdG9wIG9mIG9sZCBib3hcclxuICAgICAgICAgICAgICAgIHZhciBzNCA9IChvYi55MiAtIG5iLnkxICsgcGFkZGluZykgLyAobmEueSAtIG9hLnkpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBib3R0b20gb2Ygb2xkIGJveFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihzMSkgfHwgaXNOYU4oczIpKSBzMSA9IHMyID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihzMykgfHwgaXNOYU4oczQpKSBzMyA9IHM0ID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uRnJlZVNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoczEsIHMyKSwgTWF0aC5tYXgoczMsIHM0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgbGFiZWwncyBtaW4gc2NhbGUgaWYgdGhlIGdseXBoIHdhcyByZXN0cmljdGVkIGJ5IGEgY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gbWluUGxhY2VtZW50U2NhbGUgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25GcmVlU2NhbGUgPiBtaW5TY2FsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA8IG1heFNjYWxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlIDwgYmxvY2tpbmdbbF0ubWF4U2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5QbGFjZW1lbnRTY2FsZSA9IGNvbGxpc2lvbkZyZWVTY2FsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWluUGxhY2VtZW50U2NhbGUgPiB0aGlzLm1heFBsYWNlbWVudFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcclxufTtcclxuXHJcbkNvbGxpc2lvbi5wcm90b3R5cGUuZ2V0UGxhY2VtZW50UmFuZ2UgPSBmdW5jdGlvbihnbHlwaHMsIHBsYWNlbWVudFNjYWxlLCBob3Jpem9udGFsKSB7XHJcblxyXG4gICAgdmFyIHBsYWNlbWVudFJhbmdlID0gWzIqTWF0aC5QSSwgMF07XHJcblxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBnbHlwaHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNba107XHJcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGdseXBoLmJveDtcclxuICAgICAgICB2YXIgYW5jaG9yID0gZ2x5cGguYW5jaG9yO1xyXG5cclxuICAgICAgICB2YXIgbWluUGxhY2VkWCA9IGFuY2hvci54ICsgYmJveC54MSAvIHBsYWNlbWVudFNjYWxlO1xyXG4gICAgICAgIHZhciBtaW5QbGFjZWRZID0gYW5jaG9yLnkgKyBiYm94LnkxIC8gcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgdmFyIG1heFBsYWNlZFggPSBhbmNob3IueCArIGJib3gueDIgLyBwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICB2YXIgbWF4UGxhY2VkWSA9IGFuY2hvci55ICsgYmJveC55MiAvIHBsYWNlbWVudFNjYWxlO1xyXG5cclxuICAgICAgICB2YXIgc2VhcmNoQm94ID0gW21pblBsYWNlZFgsIG1pblBsYWNlZFksIG1heFBsYWNlZFgsIG1heFBsYWNlZFldO1xyXG5cclxuICAgICAgICB2YXIgYmxvY2tpbmcgPSB0aGlzLmhUcmVlLnNlYXJjaChzZWFyY2hCb3gpO1xyXG5cclxuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBibG9ja2luZyA9IGJsb2NraW5nLmNvbmNhdCh0aGlzLmNUcmVlLnNlYXJjaChzZWFyY2hCb3gpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYmxvY2tpbmcubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBibG9ja2luZ1tsXTtcclxuICAgICAgICAgICAgdmFyIGJib3gyID0gYi5oQm94IHx8IGIuYm94O1xyXG5cclxuICAgICAgICAgICAgdmFyIHgxLCB4MiwgeTEsIHkyLCBpbnRlcnNlY3RYLCBpbnRlcnNlY3RZO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRqdXN0IGFuZCBjb21wYXJlIGJib3hlcyB0byBzZWUgaWYgdGhlIGdseXBocyBtaWdodCBpbnRlcnNlY3RcclxuICAgICAgICAgICAgaWYgKHBsYWNlbWVudFNjYWxlID4gYi5wbGFjZW1lbnRTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgeDEgPSBiLmFuY2hvci54ICsgYmJveDIueDEgLyBwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICAgICAgICAgIHkxID0gYi5hbmNob3IueSArIGJib3gyLnkxIC8gcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgICAgICB4MiA9IGIuYW5jaG9yLnggKyBiYm94Mi54MiAvIHBsYWNlbWVudFNjYWxlO1xyXG4gICAgICAgICAgICAgICAgeTIgPSBiLmFuY2hvci55ICsgYmJveDIueTIgLyBwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdFggPSB4MSA8IG1heFBsYWNlZFggJiYgeDIgPiBtaW5QbGFjZWRYO1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0WSA9IHkxIDwgbWF4UGxhY2VkWSAmJiB5MiA+IG1pblBsYWNlZFk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4MSA9IGFuY2hvci54ICsgYmJveC54MSAvIGIucGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgICAgICB5MSA9IGFuY2hvci55ICsgYmJveC55MSAvIGIucGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgICAgICB4MiA9IGFuY2hvci54ICsgYmJveC54MiAvIGIucGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgICAgICB5MiA9IGFuY2hvci55ICsgYmJveC55MiAvIGIucGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RYID0geDEgPCBiWzJdICYmIHgyID4gYlswXTtcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdFkgPSB5MSA8IGJbM10gJiYgeTIgPiBiWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGV5IGNhbid0IGludGVyc2VjdCwgc2tpcCBtb3JlIGV4cGVuc2l2ZSByb3RhdGlvbiBjYWxjdWxhdGlvblxyXG4gICAgICAgICAgICBpZiAoIShpbnRlcnNlY3RYICYmIGludGVyc2VjdFkpKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KHBsYWNlbWVudFNjYWxlLCBiLnBsYWNlbWVudFNjYWxlKTtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gcm90YXRpb25SYW5nZS5yb3RhdGlvblJhbmdlKGdseXBoLCBiLCBzY2FsZSk7XHJcblxyXG4gICAgICAgICAgICBwbGFjZW1lbnRSYW5nZVswXSA9IE1hdGgubWluKHBsYWNlbWVudFJhbmdlWzBdLCByYW5nZVswXSk7XHJcbiAgICAgICAgICAgIHBsYWNlbWVudFJhbmdlWzFdID0gTWF0aC5tYXgocGxhY2VtZW50UmFuZ2VbMV0sIHJhbmdlWzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBsYWNlbWVudFJhbmdlO1xyXG5cclxufTtcclxuXHJcbi8vIEluc2VydCBnbHlwaCBwbGFjZW1lbnRzIGludG8gcnRyZWUuXHJcbkNvbGxpc2lvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oZ2x5cGhzLCBhbmNob3IsIHBsYWNlbWVudFNjYWxlLCBwbGFjZW1lbnRSYW5nZSwgaG9yaXpvbnRhbCkge1xyXG5cclxuICAgIHZhciBhbGxCb3VuZHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGdseXBocy5sZW5ndGg7IGsrKykge1xyXG5cclxuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNba107XHJcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGdseXBoLmJveDtcclxuXHJcbiAgICAgICAgdmFyIG1pblNjYWxlID0gTWF0aC5tYXgocGxhY2VtZW50U2NhbGUsIGdseXBoLm1pblNjYWxlKTtcclxuICAgICAgICB2YXIgbWF4U2NhbGUgPSBnbHlwaC5tYXhTY2FsZSB8fCBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm94KGFuY2hvciwgYmJveCwgbWluU2NhbGUsIG1heFNjYWxlKTtcclxuXHJcbiAgICAgICAgYm91bmRzLmFuY2hvciA9IGFuY2hvcjtcclxuICAgICAgICBib3VuZHMuYm94ID0gZ2x5cGguYm94O1xyXG4gICAgICAgIGlmIChnbHlwaC5oQm94KSBib3VuZHMuaEJveCA9IGJib3g7XHJcbiAgICAgICAgYm91bmRzLnBsYWNlbWVudFJhbmdlID0gcGxhY2VtZW50UmFuZ2U7XHJcbiAgICAgICAgYm91bmRzLnBsYWNlbWVudFNjYWxlID0gbWluU2NhbGU7XHJcbiAgICAgICAgYm91bmRzLm1heFNjYWxlID0gbWF4U2NhbGU7XHJcbiAgICAgICAgYm91bmRzLnBhZGRpbmcgPSBnbHlwaC5wYWRkaW5nO1xyXG5cclxuICAgICAgICBhbGxCb3VuZHMucHVzaChib3VuZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIChob3Jpem9udGFsID8gdGhpcy5oVHJlZSA6IHRoaXMuY1RyZWUpLmxvYWQoYWxsQm91bmRzKTtcclxufTtcclxuXHJcbkNvbGxpc2lvbi5wcm90b3R5cGUuZ2V0Qm94ID0gZnVuY3Rpb24oYW5jaG9yLCBiYm94LCBtaW5TY2FsZSwgbWF4U2NhbGUpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYW5jaG9yLnggKyBNYXRoLm1pbihiYm94LngxIC8gbWluU2NhbGUsIGJib3gueDEgLyBtYXhTY2FsZSksXHJcbiAgICAgICAgYW5jaG9yLnkgKyBNYXRoLm1pbihiYm94LnkxIC8gbWluU2NhbGUsIGJib3gueTEgLyBtYXhTY2FsZSksXHJcbiAgICAgICAgYW5jaG9yLnggKyBNYXRoLm1heChiYm94LngyIC8gbWluU2NhbGUsIGJib3gueDIgLyBtYXhTY2FsZSksXHJcbiAgICAgICAgYW5jaG9yLnkgKyBNYXRoLm1heChiYm94LnkyIC8gbWluU2NhbGUsIGJib3gueTIgLyBtYXhTY2FsZSldO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQmluUGFjayA9IHJlcXVpcmUoJy4vYmlucGFjay5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEF0bGFzO1xyXG5mdW5jdGlvbiBHbHlwaEF0bGFzKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuYmluID0gbmV3IEJpblBhY2sod2lkdGgsIGhlaWdodCk7XHJcbiAgICB0aGlzLmluZGV4ID0ge307XHJcbiAgICB0aGlzLmlkcyA9IHt9O1xyXG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG59XHJcblxyXG5HbHlwaEF0bGFzLnByb3RvdHlwZSA9IHtcclxuICAgIGdldCBkZWJ1ZygpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbnZhcycgaW4gdGhpcztcclxuICAgIH0sXHJcbiAgICBzZXQgZGVidWcodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5jYW52YXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmN0eDtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkdseXBoQXRsYXMucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGdseXBocyA9IHt9LFxyXG4gICAgICAgIHNwbGl0LFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgaWQ7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XHJcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcclxuICAgICAgICBuYW1lID0gc3BsaXRbMF07XHJcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaHNbbmFtZV0pIGdseXBoc1tuYW1lXSA9IFtdO1xyXG4gICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2x5cGhzO1xyXG59O1xyXG5cclxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZWN0cyA9IHt9LFxyXG4gICAgICAgIHNwbGl0LFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgaWQ7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XHJcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcclxuICAgICAgICBuYW1lID0gc3BsaXRbMF07XHJcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcclxuXHJcbiAgICAgICAgaWYgKCFyZWN0c1tuYW1lXSkgcmVjdHNbbmFtZV0gPSB7fTtcclxuICAgICAgICByZWN0c1tuYW1lXVtpZF0gPSB0aGlzLmluZGV4W2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlY3RzO1xyXG59O1xyXG5cclxuR2x5cGhBdGxhcy5wcm90b3R5cGUucmVtb3ZlR2x5cGhzID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmlkcykge1xyXG5cclxuICAgICAgICB2YXIgaWRzID0gdGhpcy5pZHNba2V5XTtcclxuXHJcbiAgICAgICAgdmFyIHBvcyA9IGlkcy5pbmRleE9mKGlkKTtcclxuICAgICAgICBpZiAocG9zID49IDApIGlkcy5zcGxpY2UocG9zLCAxKTtcclxuICAgICAgICB0aGlzLmlkc1trZXldID0gaWRzO1xyXG5cclxuICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmluZGV4W2tleV07XHJcblxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHJlY3QuaDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkpICsgcmVjdC54O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByZWN0Lnc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFt5MSArIHhdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJpbi5yZWxlYXNlKHJlY3QpO1xyXG5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhba2V5XTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUodGhpcy5nbCk7XHJcbn07XHJcblxyXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyKSB7XHJcbiAgICBpZiAoIWdseXBoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdtaXNzaW5nIGdseXBoJywgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5ID0gbmFtZSArIFwiI1wiICsgZ2x5cGguaWQ7XHJcblxyXG4gICAgLy8gVGhlIGdseXBoIGlzIGFscmVhZHkgaW4gdGhpcyB0ZXh0dXJlLlxyXG4gICAgaWYgKHRoaXMuaW5kZXhba2V5XSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkc1trZXldLnB1c2goaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXHJcbiAgICBpZiAoIWdseXBoLmJpdG1hcCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBidWZmZXJlZF93aWR0aCA9IGdseXBoLndpZHRoICsgYnVmZmVyICogMjtcclxuICAgIHZhciBidWZmZXJlZF9oZWlnaHQgPSBnbHlwaC5oZWlnaHQgKyBidWZmZXIgKiAyO1xyXG5cclxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxyXG4gICAgdmFyIHBhY2tfd2lkdGggPSBidWZmZXJlZF93aWR0aDtcclxuICAgIHZhciBwYWNrX2hlaWdodCA9IGJ1ZmZlcmVkX2hlaWdodDtcclxuXHJcbiAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXHJcbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cclxuICAgIC8vIGludG8gMiBieXRlcyByYXRoZXIgdGhhbiA0IGJ5dGVzLlxyXG4gICAgcGFja193aWR0aCArPSAoNCAtIHBhY2tfd2lkdGggJSA0KTtcclxuICAgIHBhY2tfaGVpZ2h0ICs9ICg0IC0gcGFja19oZWlnaHQgJSA0KTtcclxuXHJcbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLmFsbG9jYXRlKHBhY2tfd2lkdGgsIHBhY2tfaGVpZ2h0KTtcclxuICAgIGlmIChyZWN0LnggPCAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdnbHlwaCBiaXRtYXAgb3ZlcmZsb3cnKTtcclxuICAgICAgICByZXR1cm4geyBnbHlwaDogZ2x5cGgsIHJlY3Q6IG51bGwgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgbGVmdCBhbmQgdG9wIGdseXBoIG9mZnNldHMgdG8gcmVjdC5cclxuICAgIHJlY3QubCA9IGdseXBoLmxlZnQ7XHJcbiAgICByZWN0LnQgPSBnbHlwaC50b3A7XHJcblxyXG4gICAgdGhpcy5pbmRleFtrZXldID0gcmVjdDtcclxuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xyXG5cclxuICAgIHZhciB0YXJnZXQgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBidWZmZXJlZF9oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSkgKyByZWN0Lng7XHJcbiAgICAgICAgdmFyIHkyID0gYnVmZmVyZWRfd2lkdGggKiB5O1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyZWRfd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IHNvdXJjZVt5MiArIHhdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdseXBoQXRsYXMucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCkge1xyXG4gICAgdGhpcy5iaW5kKGdsKTtcclxuICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcblxyXG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xyXG5cclxuICAgICAgICAvLyBERUJVR1xyXG4gICAgICAgIGlmICh0aGlzLmN0eCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKywgaiArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbal0gPSB0aGlzLmRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaisxXSA9IHRoaXMuZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqKzJdID0gdGhpcy5kYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2orM10gPSAyNTU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmJpbi5mcmVlLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJlZSA9IHRoaXMuYmluLmZyZWVba107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KGZyZWUueCwgZnJlZS55LCBmcmVlLncsIGZyZWUuaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIERFQlVHXHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94LmpzJykubm9ybWFsaXplR2x5cGhzVVJMO1xyXG52YXIgZ2V0QXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKS5nZXRBcnJheUJ1ZmZlcjtcclxudmFyIEdseXBocyA9IHJlcXVpcmUoJy4uL3V0aWwvZ2x5cGhzLmpzJyk7XHJcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFNvdXJjZTtcclxuXHJcbmZ1bmN0aW9uIEdseXBoU291cmNlKHVybCwgZ2x5cGhBdGxhcykge1xyXG4gICAgdGhpcy51cmwgPSB1cmwgJiYgbm9ybWFsaXplVVJMKHVybCk7XHJcbiAgICB0aGlzLmdseXBoQXRsYXMgPSBnbHlwaEF0bGFzO1xyXG4gICAgdGhpcy5zdGFja3MgPSB7fTtcclxuICAgIHRoaXMubG9hZGluZyA9IHt9O1xyXG59XHJcblxyXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB0aWxlSUQsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKHRoaXMuc3RhY2tzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkgdGhpcy5zdGFja3NbZm9udHN0YWNrXSA9IHt9O1xyXG5cclxuICAgIHZhciByZWN0cyA9IHt9O1xyXG4gICAgdmFyIGdseXBocyA9IHt9O1xyXG4gICAgdmFyIHJlc3VsdCA9IHsgcmVjdHM6IHJlY3RzLCBnbHlwaHM6IGdseXBocyB9O1xyXG5cclxuICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tzW2ZvbnRzdGFja107XHJcbiAgICB2YXIgZ2x5cGhBdGxhcyA9IHRoaXMuZ2x5cGhBdGxhcztcclxuXHJcbiAgICB2YXIgbWlzc2luZyA9IHt9O1xyXG4gICAgdmFyIHJlbWFpbmluZyA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaElEcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBnbHlwaElEID0gZ2x5cGhJRHNbaV07XHJcbiAgICAgICAgdmFyIHJhbmdlID0gTWF0aC5mbG9vcihnbHlwaElEIC8gMjU2KTtcclxuXHJcbiAgICAgICAgaWYgKHN0YWNrW3JhbmdlXSkge1xyXG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFja1tyYW5nZV0uZ2x5cGhzW2dseXBoSURdO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gMztcclxuICAgICAgICAgICAgcmVjdHNbZ2x5cGhJRF0gPSBnbHlwaEF0bGFzLmFkZEdseXBoKHRpbGVJRCwgZm9udHN0YWNrLCBnbHlwaCwgYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBzaW1wbGVHbHlwaChnbHlwaCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1pc3NpbmdbcmFuZ2VdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdID0gW107XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmcrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaXNzaW5nW3JhbmdlXS5wdXNoKGdseXBoSUQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCByZXN1bHQpO1xyXG5cclxuICAgIHZhciBnbHlwaFNvdXJjZSA9IHRoaXM7XHJcbiAgICBmb3IgKHZhciByIGluIG1pc3NpbmcpIHtcclxuICAgICAgICB0aGlzLmxvYWRSYW5nZShmb250c3RhY2ssIHIsIG9uUmFuZ2VMb2FkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uUmFuZ2VMb2FkZWQoZXJyLCByYW5nZSwgZGF0YSkge1xyXG4gICAgICAgIC8vIFRPRE8gbm90IGJlIHNpbGVudCBhYm91dCBlcnJvcnNcclxuICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBnbHlwaFNvdXJjZS5zdGFja3NbZm9udHN0YWNrXVtyYW5nZV0gPSBkYXRhLnN0YWNrc1tmb250c3RhY2tdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pc3NpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhJRCA9IG1pc3NpbmdbcmFuZ2VdW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IDM7XHJcbiAgICAgICAgICAgICAgICByZWN0c1tnbHlwaElEXSA9IGdseXBoQXRsYXMuYWRkR2x5cGgodGlsZUlELCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBzaW1wbGVHbHlwaChnbHlwaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtYWluaW5nLS07XHJcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHNpbXBsZUdseXBoKGdseXBoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkdmFuY2U6IGdseXBoLmFkdmFuY2UsXHJcbiAgICAgICAgbGVmdDogZ2x5cGgubGVmdCxcclxuICAgICAgICB0b3A6IGdseXBoLnRvcFxyXG4gICAgfTtcclxufVxyXG5cclxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmxvYWRSYW5nZSA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgcmFuZ2UsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKHJhbmdlICogMjU2ID49IDY1MjgwKSByZXR1cm4gY2FsbGJhY2soJ2d5cGhzID4gNjUyODAgbm90IHN1cHBvcnRlZCcpO1xyXG5cclxuICAgIGlmICh0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9IHt9O1xyXG4gICAgdmFyIGxvYWRpbmcgPSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXTtcclxuXHJcbiAgICBpZiAobG9hZGluZ1tyYW5nZV0pIHtcclxuICAgICAgICBsb2FkaW5nW3JhbmdlXS5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0gPSBbY2FsbGJhY2tdO1xyXG5cclxuICAgICAgICB2YXIgcmFuZ2VOYW1lID0gKHJhbmdlICogMjU2KSArICctJyArIChyYW5nZSAqIDI1NiArIDI1NSk7XHJcbiAgICAgICAgdmFyIHVybCA9IGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2VOYW1lLCB0aGlzLnVybCk7XHJcblxyXG4gICAgICAgIGdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSAhZXJyICYmIG5ldyBHbHlwaHMobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9hZGluZ1tyYW5nZV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdbcmFuZ2VdW2ldKGVyciwgcmFuZ2UsIGdseXBocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdbcmFuZ2VdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZSwgdXJsLCBzdWJkb21haW5zKSB7XHJcbiAgICBzdWJkb21haW5zID0gc3ViZG9tYWlucyB8fCAnYWJjJztcclxuXHJcbiAgICByZXR1cm4gdXJsXHJcbiAgICAgICAgLnJlcGxhY2UoJ3tzfScsIHN1YmRvbWFpbnNbZm9udHN0YWNrLmxlbmd0aCAlIHN1YmRvbWFpbnMubGVuZ3RoXSlcclxuICAgICAgICAucmVwbGFjZSgne2ZvbnRzdGFja30nLCBmb250c3RhY2spXHJcbiAgICAgICAgLnJlcGxhY2UoJ3tyYW5nZX0nLCByYW5nZSk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcclxuICAgIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3IuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XHJcblxyXG52YXIgbWluU2NhbGUgPSAwLjU7XHJcbnZhciBtaW5TY2FsZUFycmF5cyA9IHtcclxuICAgIDE6IFttaW5TY2FsZV0sXHJcbiAgICAyOiBbbWluU2NhbGUsIDJdLFxyXG4gICAgNDogW21pblNjYWxlLCA0LCAyLCA0XSxcclxuICAgIDg6IFttaW5TY2FsZSwgOCwgNCwgOCwgMiwgOCwgNCwgOF1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh2ZXJ0aWNlcywgc3BhY2luZywgbWluU2NhbGUsIG1heFNjYWxlLCB0aWxlUGl4ZWxSYXRpbywgc3RhcnQpIHtcclxuXHJcbiAgICBpZiAobWluU2NhbGUgPT09IHVuZGVmaW5lZCkgbWluU2NhbGUgPSAwO1xyXG5cclxuICAgIG1heFNjYWxlID0gTWF0aC5yb3VuZChNYXRoLm1heChNYXRoLm1pbig4LCBtYXhTY2FsZSAvIDIpLCAxKSk7XHJcbiAgICBzcGFjaW5nICo9IHRpbGVQaXhlbFJhdGlvIC8gbWF4U2NhbGU7XHJcbiAgICB2YXIgbWluU2NhbGVzID0gbWluU2NhbGVBcnJheXNbbWF4U2NhbGVdO1xyXG4gICAgdmFyIGxlbiA9IG1pblNjYWxlcy5sZW5ndGg7XHJcblxyXG4gICAgdmFyIGRpc3RhbmNlID0gMCxcclxuICAgICAgICBtYXJrZWREaXN0YW5jZSA9IDAsXHJcbiAgICAgICAgYWRkZWQgPSBzdGFydCB8fCAwO1xyXG5cclxuICAgIHZhciBwb2ludHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cclxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzW2ldLFxyXG4gICAgICAgICAgICBiID0gdmVydGljZXNbaSArIDFdO1xyXG5cclxuICAgICAgICB2YXIgc2VnbWVudERpc3QgPSBhLmRpc3QoYiksXHJcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xyXG5cclxuICAgICAgICB3aGlsZSAobWFya2VkRGlzdGFuY2UgKyBzcGFjaW5nIDwgZGlzdGFuY2UgKyBzZWdtZW50RGlzdCkge1xyXG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xyXG5cclxuICAgICAgICAgICAgdmFyIHQgPSAobWFya2VkRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBzZWdtZW50RGlzdCxcclxuICAgICAgICAgICAgICAgIHggPSB1dGlsLmludGVycChhLngsIGIueCwgdCksXHJcbiAgICAgICAgICAgICAgICB5ID0gdXRpbC5pbnRlcnAoYS55LCBiLnksIHQpLFxyXG4gICAgICAgICAgICAgICAgcyA9IG1pblNjYWxlc1thZGRlZCAlIGxlbl07XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCA0MDk2ICYmIHkgPj0gMCAmJiB5IDwgNDA5Nikge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgcywgaSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRlZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlzdGFuY2UgKz0gc2VnbWVudERpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50cztcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZXRJY29uOiBnZXRJY29uLFxyXG4gICAgZ2V0R2x5cGhzOiBnZXRHbHlwaHNcclxufTtcclxuXHJcbnZhciBtaW5TY2FsZSA9IDAuNTsgLy8gdW5kZXJzY2FsZSBieSAxIHpvb20gbGV2ZWxcclxuXHJcbmZ1bmN0aW9uIGdldEljb24oYW5jaG9yLCBpbWFnZSwgYm94U2NhbGUsIGxpbmUsIHByb3BzKSB7XHJcblxyXG4gICAgdmFyIHggPSBpbWFnZS53aWR0aCAvIDIgLyBpbWFnZS5waXhlbFJhdGlvO1xyXG4gICAgdmFyIHkgPSBpbWFnZS5oZWlnaHQgLyAyIC8gaW1hZ2UucGl4ZWxSYXRpbztcclxuXHJcbiAgICB2YXIgZHggPSBwcm9wc1snaWNvbi1vZmZzZXQnXVswXTtcclxuICAgIHZhciBkeSA9IHByb3BzWydpY29uLW9mZnNldCddWzFdO1xyXG4gICAgdmFyIHgxID0gKGR4IC0geCk7XHJcbiAgICB2YXIgeDIgPSAoZHggKyB4KTtcclxuICAgIHZhciB5MSA9IChkeSAtIHkpO1xyXG4gICAgdmFyIHkyID0gKGR5ICsgeSk7XHJcblxyXG4gICAgdmFyIHRsID0gbmV3IFBvaW50KHgxLCB5MSk7XHJcbiAgICB2YXIgdHIgPSBuZXcgUG9pbnQoeDIsIHkxKTtcclxuICAgIHZhciBiciA9IG5ldyBQb2ludCh4MiwgeTIpO1xyXG4gICAgdmFyIGJsID0gbmV3IFBvaW50KHgxLCB5Mik7XHJcblxyXG4gICAgdmFyIGFuZ2xlID0gcHJvcHNbJ2ljb24tcm90YXRlJ10gKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgaWYgKGFuY2hvci5zZWdtZW50ICE9PSB1bmRlZmluZWQgJiYgcHJvcHNbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gIT09ICd2aWV3cG9ydCcpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IGxpbmVbYW5jaG9yLnNlZ21lbnRdO1xyXG4gICAgICAgIGFuZ2xlICs9IC1NYXRoLmF0YW4yKG5leHQueCAtIGFuY2hvci54LCBuZXh0LnkgLSBhbmNob3IueSkgKyBNYXRoLlBJIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYW5nbGUpIHtcclxuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxyXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXHJcbiAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcclxuXHJcbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XHJcbiAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XHJcbiAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XHJcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XHJcblxyXG4gICAgICAgIHgxID0gTWF0aC5taW4odGwueCwgdHIueCwgYmwueCwgYnIueCk7XHJcbiAgICAgICAgeDIgPSBNYXRoLm1heCh0bC54LCB0ci54LCBibC54LCBici54KTtcclxuICAgICAgICB5MSA9IE1hdGgubWluKHRsLnksIHRyLnksIGJsLnksIGJyLnkpO1xyXG4gICAgICAgIHkyID0gTWF0aC5tYXgodGwueSwgdHIueSwgYmwueSwgYnIueSk7XHJcbiAgICB9XHJcbiAgICB2YXIgYm94ID0ge1xyXG4gICAgICAgIHgxOiB4MSAqIGJveFNjYWxlLFxyXG4gICAgICAgIHgyOiB4MiAqIGJveFNjYWxlLFxyXG4gICAgICAgIHkxOiB5MSAqIGJveFNjYWxlLFxyXG4gICAgICAgIHkyOiB5MiAqIGJveFNjYWxlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpY29uQm94ID0ge1xyXG4gICAgICAgIGJveDogYm94LFxyXG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxyXG4gICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZSxcclxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXHJcbiAgICAgICAgcGFkZGluZzogcHJvcHNbJ2ljb24tcGFkZGluZyddXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpY29uID0ge1xyXG4gICAgICAgIHRsOiB0bCxcclxuICAgICAgICB0cjogdHIsXHJcbiAgICAgICAgYnI6IGJyLFxyXG4gICAgICAgIGJsOiBibCxcclxuICAgICAgICB0ZXg6IGltYWdlLFxyXG4gICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxyXG4gICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZSxcclxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHlcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzaGFwZXM6IFtpY29uXSxcclxuICAgICAgICBib3hlczogW2ljb25Cb3hdLFxyXG4gICAgICAgIG1pblNjYWxlOiBhbmNob3Iuc2NhbGVcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEdseXBocyhhbmNob3IsIG9yaWdpbiwgc2hhcGluZywgZmFjZXMsIGJveFNjYWxlLCBob3Jpem9udGFsLCBsaW5lLCBwcm9wcykge1xyXG5cclxuICAgIHZhciBtYXhBbmdsZURlbHRhID0gcHJvcHNbJ3RleHQtbWF4LWFuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgdmFyIHJvdGF0ZSA9IHByb3BzWyd0ZXh0LXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcclxuICAgIHZhciBwYWRkaW5nID0gcHJvcHNbJ3RleHQtcGFkZGluZyddO1xyXG4gICAgdmFyIGFsb25nTGluZSA9IHByb3BzWyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddICE9PSAndmlld3BvcnQnO1xyXG4gICAgdmFyIGtlZXBVcHJpZ2h0ID0gcHJvcHNbJ3RleHQta2VlcC11cHJpZ2h0J107XHJcblxyXG4gICAgdmFyIGdseXBocyA9IFtdLFxyXG4gICAgICAgIGJveGVzID0gW107XHJcblxyXG4gICAgdmFyIGJ1ZmZlciA9IDM7XHJcblxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaGFwaW5nLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGluZ1trXTtcclxuICAgICAgICB2YXIgZm9udHN0YWNrID0gZmFjZXNbc2hhcGUuZm9udHN0YWNrXTtcclxuICAgICAgICB2YXIgZ2x5cGggPSBmb250c3RhY2suZ2x5cGhzW3NoYXBlLmdseXBoXTtcclxuICAgICAgICB2YXIgcmVjdCA9IGZvbnRzdGFjay5yZWN0c1tzaGFwZS5nbHlwaF07XHJcblxyXG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAoIShyZWN0ICYmIHJlY3QudyA+IDAgJiYgcmVjdC5oID4gMCkpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB2YXIgeCA9IChvcmlnaW4ueCArIHNoYXBlLnggKyBnbHlwaC5sZWZ0IC0gYnVmZmVyICsgcmVjdC53IC8gMikgKiBib3hTY2FsZTtcclxuXHJcbiAgICAgICAgdmFyIGdseXBoSW5zdGFuY2VzO1xyXG4gICAgICAgIGlmIChhbmNob3Iuc2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIGFsb25nTGluZSkge1xyXG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIHgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAxLCBtYXhBbmdsZURlbHRhKTtcclxuICAgICAgICAgICAgaWYgKGtlZXBVcHJpZ2h0KSBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIHgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAtMSwgbWF4QW5nbGVEZWx0YSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW3tcclxuICAgICAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgYW5nbGU6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXHJcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogbWluU2NhbGVcclxuICAgICAgICAgICAgfV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeDEgPSBvcmlnaW4ueCArIHNoYXBlLnggKyBnbHlwaC5sZWZ0IC0gYnVmZmVyLFxyXG4gICAgICAgICAgICB5MSA9IG9yaWdpbi55ICsgc2hhcGUueSAtIGdseXBoLnRvcCAtIGJ1ZmZlcixcclxuICAgICAgICAgICAgeDIgPSB4MSArIHJlY3QudyxcclxuICAgICAgICAgICAgeTIgPSB5MSArIHJlY3QuaCxcclxuXHJcbiAgICAgICAgICAgIG90bCA9IG5ldyBQb2ludCh4MSwgeTEpLFxyXG4gICAgICAgICAgICBvdHIgPSBuZXcgUG9pbnQoeDIsIHkxKSxcclxuICAgICAgICAgICAgb2JsID0gbmV3IFBvaW50KHgxLCB5MiksXHJcbiAgICAgICAgICAgIG9iciA9IG5ldyBQb2ludCh4MiwgeTIpO1xyXG5cclxuICAgICAgICB2YXIgb2JveCA9IHtcclxuICAgICAgICAgICAgICAgIHgxOiBib3hTY2FsZSAqIHgxLFxyXG4gICAgICAgICAgICAgICAgeTE6IGJveFNjYWxlICogeTEsXHJcbiAgICAgICAgICAgICAgICB4MjogYm94U2NhbGUgKiB4MixcclxuICAgICAgICAgICAgICAgIHkyOiBib3hTY2FsZSAqIHkyXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGdseXBoSW5zdGFuY2VzW2ldLFxyXG5cclxuICAgICAgICAgICAgICAgIHRsID0gb3RsLFxyXG4gICAgICAgICAgICAgICAgdHIgPSBvdHIsXHJcbiAgICAgICAgICAgICAgICBibCA9IG9ibCxcclxuICAgICAgICAgICAgICAgIGJyID0gb2JyLFxyXG4gICAgICAgICAgICAgICAgYm94ID0gb2JveCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGFtcCB0byAtOTAvKzkwIGRlZ3JlZXNcclxuICAgICAgICAgICAgICAgIGFuZ2xlID0gaW5zdGFuY2UuYW5nbGUgKyByb3RhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cclxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXHJcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcclxuXHJcbiAgICAgICAgICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcclxuICAgICAgICAgICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJldmVudCBsYWJlbCBmcm9tIGV4dGVuZGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpbmVcclxuICAgICAgICAgICAgdmFyIGdseXBoTWluU2NhbGUgPSBNYXRoLm1heChpbnN0YW5jZS5taW5TY2FsZSwgYW5jaG9yLnNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBnbHlwaCBmb3IgbGF0ZXIgaW5zZXJ0aW9uLlxyXG4gICAgICAgICAgICBnbHlwaHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0bDogdGwsXHJcbiAgICAgICAgICAgICAgICB0cjogdHIsXHJcbiAgICAgICAgICAgICAgICBibDogYmwsXHJcbiAgICAgICAgICAgICAgICBicjogYnIsXHJcbiAgICAgICAgICAgICAgICB0ZXg6IHJlY3QsXHJcbiAgICAgICAgICAgICAgICBhbmdsZTogKGFuY2hvci5hbmdsZSArIHJvdGF0ZSArIGluc3RhbmNlLm9mZnNldCArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSksXHJcbiAgICAgICAgICAgICAgICBhbmNob3I6IGluc3RhbmNlLmFuY2hvcixcclxuICAgICAgICAgICAgICAgIG1pblNjYWxlOiBnbHlwaE1pblNjYWxlLFxyXG4gICAgICAgICAgICAgICAgbWF4U2NhbGU6IGluc3RhbmNlLm1heFNjYWxlXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5vZmZzZXQpIHsgLy8gbm90IGEgZmxpcHBlZCBnbHlwaFxyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByb3RhdGVkIGdseXBoJ3MgYm91bmRpbmcgYm94IG9mZnNldHMgZnJvbSB0aGUgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGJveCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IGJveFNjYWxlICogTWF0aC5taW4odGwueCwgdHIueCwgYmwueCwgYnIueCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBib3hTY2FsZSAqIE1hdGgubWluKHRsLnksIHRyLnksIGJsLnksIGJyLnkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogYm94U2NhbGUgKiBNYXRoLm1heCh0bC54LCB0ci54LCBibC54LCBici54KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IGJveFNjYWxlICogTWF0aC5tYXgodGwueSwgdHIueSwgYmwueSwgYnIueSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94OiBib3gsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBpbnN0YW5jZS5hbmNob3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluU2NhbGU6IGdseXBoTWluU2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4U2NhbGU6IGluc3RhbmNlLm1heFNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gYXZvaWQgY3JlYXRpbmcgdGhlIGJveGVzIGluIHRoZSBmaXJzdCBwbGFjZT9cclxuICAgIGlmIChob3Jpem9udGFsKSBib3hlcyA9IFtnZXRNZXJnZWRCb3hlcyhib3hlcywgYW5jaG9yKV07XHJcblxyXG4gICAgdmFyIG1pblBsYWNlbWVudFNjYWxlID0gYW5jaG9yLnNjYWxlO1xyXG4gICAgdmFyIG1pbkdseXBoU2NhbGUgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgYm94ZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICBtaW5HbHlwaFNjYWxlID0gTWF0aC5taW4obWluR2x5cGhTY2FsZSwgYm94ZXNbbV0ubWluU2NhbGUpO1xyXG4gICAgfVxyXG4gICAgbWluR2x5cGhTY2FsZSA9IE1hdGgubWF4KG1pblBsYWNlbWVudFNjYWxlLCBtaW5TY2FsZSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBib3hlczogYm94ZXMsXHJcbiAgICAgICAgc2hhcGVzOiBnbHlwaHMsXHJcbiAgICAgICAgbWluU2NhbGU6IG1pbkdseXBoU2NhbGVcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhzLCBhbmNob3IsIG9mZnNldCwgbGluZSwgc2VnbWVudCwgZGlyZWN0aW9uLCBtYXhBbmdsZURlbHRhKSB7XHJcbiAgICB2YXIgdXBzaWRlRG93biA9IGRpcmVjdGlvbiA8IDA7XHJcblxyXG4gICAgaWYgKG9mZnNldCA8IDApICBkaXJlY3Rpb24gKj0gLTE7XHJcblxyXG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHNlZ21lbnQrKztcclxuXHJcbiAgICB2YXIgbmV3QW5jaG9yID0gYW5jaG9yO1xyXG4gICAgdmFyIGVuZCA9IGxpbmVbc2VnbWVudF07XHJcbiAgICB2YXIgcHJldnNjYWxlID0gSW5maW5pdHk7XHJcbiAgICB2YXIgcHJldkFuZ2xlO1xyXG5cclxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XHJcblxyXG4gICAgdmFyIHBsYWNlbWVudFNjYWxlID0gYW5jaG9yLnNjYWxlO1xyXG5cclxuICAgIHNlZ21lbnRfbG9vcDpcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBuZXdBbmNob3IuZGlzdChlbmQpO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IG9mZnNldC9kaXN0O1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKGVuZC54IC0gbmV3QW5jaG9yLngsIGVuZC55IC0gbmV3QW5jaG9yLnkpICsgZGlyZWN0aW9uICogTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgaWYgKHVwc2lkZURvd24pIGFuZ2xlICs9IE1hdGguUEk7XHJcblxyXG4gICAgICAgIC8vIERvbid0IHBsYWNlIGFyb3VuZCBzaGFycCBjb3JuZXJzXHJcbiAgICAgICAgdmFyIGFuZ2xlRGlmZiA9IChhbmdsZSAtIHByZXZBbmdsZSkgJSAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIGlmIChwcmV2QW5nbGUgJiYgTWF0aC5hYnMoYW5nbGVEaWZmKSA+IG1heEFuZ2xlRGVsdGEpIHtcclxuICAgICAgICAgICAgYW5jaG9yLnNjYWxlID0gcHJldnNjYWxlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBocy5wdXNoKHtcclxuICAgICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3IsXHJcbiAgICAgICAgICAgIG9mZnNldDogdXBzaWRlRG93biA/IE1hdGguUEkgOiAwLFxyXG4gICAgICAgICAgICBtaW5TY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgIG1heFNjYWxlOiBwcmV2c2NhbGUsXHJcbiAgICAgICAgICAgIGFuZ2xlOiAoYW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChzY2FsZSA8PSBwbGFjZW1lbnRTY2FsZSkgYnJlYWs7XHJcblxyXG4gICAgICAgIG5ld0FuY2hvciA9IGVuZDtcclxuXHJcbiAgICAgICAgLy8gc2tpcCBkdXBsaWNhdGUgbm9kZXNcclxuICAgICAgICB3aGlsZSAobmV3QW5jaG9yLmVxdWFscyhlbmQpKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBlbmQgPSBsaW5lW3NlZ21lbnRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlbmQpIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvci5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgc2VnbWVudF9sb29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdW5pdCA9IGVuZC5zdWIobmV3QW5jaG9yKS5fdW5pdCgpO1xyXG4gICAgICAgIG5ld0FuY2hvciA9IG5ld0FuY2hvci5zdWIodW5pdC5fbXVsdChkaXN0KSk7XHJcblxyXG4gICAgICAgIHByZXZzY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHByZXZBbmdsZSA9IGFuZ2xlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNZXJnZWRCb3hlcyhnbHlwaHMsIGFuY2hvcikge1xyXG4gICAgICAvLyBDb2xsaXNpb24gY2hlY2tzIGJldHdlZW4gcm90YXRpbmcgYW5kIGZpeGVkIGxhYmVscyBhcmUgcmVsYXRpdmVseSBleHBlbnNpdmUsXHJcbiAgICAgIC8vIHNvIHdlIHVzZSBvbmUgYm94IHBlciBsYWJlbCwgbm90IHBlciBnbHlwaCBmb3IgaG9yaXpvbnRhbCBsYWJlbHMuXHJcblxyXG4gICAgdmFyIG1lcmdlZGdseXBocyA9IHtcclxuICAgICAgICBib3g6IHsgeDE6IEluZmluaXR5LCB5MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSxcclxuICAgICAgICBhbmNob3I6IGFuY2hvcixcclxuICAgICAgICBtaW5TY2FsZTogMCxcclxuICAgICAgICBwYWRkaW5nOiAtSW5maW5pdHlcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGJveCA9IG1lcmdlZGdseXBocy5ib3g7XHJcblxyXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBnbHlwaHMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICB2YXIgZ2JveCA9IGdseXBoc1ttXS5ib3g7XHJcbiAgICAgICAgYm94LngxID0gTWF0aC5taW4oYm94LngxLCBnYm94LngxKTtcclxuICAgICAgICBib3gueTEgPSBNYXRoLm1pbihib3gueTEsIGdib3gueTEpO1xyXG4gICAgICAgIGJveC54MiA9IE1hdGgubWF4KGJveC54MiwgZ2JveC54Mik7XHJcbiAgICAgICAgYm94LnkyID0gTWF0aC5tYXgoYm94LnkyLCBnYm94LnkyKTtcclxuICAgICAgICBtZXJnZWRnbHlwaHMubWluU2NhbGUgPSBNYXRoLm1heChtZXJnZWRnbHlwaHMubWluU2NhbGUsIGdseXBoc1ttXS5taW5TY2FsZSk7XHJcbiAgICAgICAgbWVyZ2VkZ2x5cGhzLnBhZGRpbmcgPSBNYXRoLm1heChtZXJnZWRnbHlwaHMucGFkZGluZywgZ2x5cGhzW21dLnBhZGRpbmcpO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yIGFsbCBob3Jpem9udGFsIGxhYmVscywgY2FsY3VsYXRlIGJib3ggY292ZXJpbmcgYWxsIHJvdGF0ZWQgcG9zaXRpb25zXHJcbiAgICB2YXIgeDEyID0gYm94LngxICogYm94LngxLFxyXG4gICAgICAgIHkxMiA9IGJveC55MSAqIGJveC55MSxcclxuICAgICAgICB4MjIgPSBib3gueDIgKiBib3gueDIsXHJcbiAgICAgICAgeTIyID0gYm94LnkyICogYm94LnkyLFxyXG4gICAgICAgIGRpYWcgPSBNYXRoLnNxcnQoTWF0aC5tYXgoeDEyICsgeTEyLCB4MTIgKyB5MjIsIHgyMiArIHkxMiwgeDIyICsgeTIyKSk7XHJcblxyXG4gICAgbWVyZ2VkZ2x5cGhzLmhCb3ggPSB7XHJcbiAgICAgICAgeDE6IC1kaWFnLFxyXG4gICAgICAgIHkxOiAtZGlhZyxcclxuICAgICAgICB4MjogZGlhZyxcclxuICAgICAgICB5MjogZGlhZ1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbWVyZ2VkZ2x5cGhzO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vdXRpbC90b2tlbi5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVGV4dDtcclxuXHJcbi8vIEZvciBhbiBhcnJheSBvZiBmZWF0dXJlcyBkZXRlcm1pbmUgd2hhdCBnbHlwaCByYW5nZXMgbmVlZCB0byBiZSBsb2FkZWRcclxuLy8gYW5kIGFwcGx5IGFueSB0ZXh0IHByZXByb2Nlc3NpbmcuIFRoZSByZW1haW5pbmcgdXNlcnMgb2YgdGV4dCBzaG91bGRcclxuLy8gdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3NpbmdcclxuLy8gZmVhdHVyZSB0ZXh0IGRpcmVjdGx5LlxyXG5mdW5jdGlvbiByZXNvbHZlVGV4dChmZWF0dXJlcywgaW5mbywgZ2x5cGhzKSB7XHJcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gW107XHJcbiAgICB2YXIgY29kZXBvaW50cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBmbCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGZsOyBpKyspIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgaW5mb1sndGV4dC1maWVsZCddKTtcclxuICAgICAgICB2YXIgaGFzdGV4dCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGV4dCkgY29udGludWU7XHJcbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGluZm9bJ3RleHQtdHJhbnNmb3JtJ107XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVVcHBlckNhc2UoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ2xvd2VyY2FzZScpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHRleHQubGVuZ3RoOyBqIDwgamw7IGorKykge1xyXG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopIDw9IDY1NTMzKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlcG9pbnRzLnB1c2godGV4dC5jaGFyQ29kZUF0KGopKTtcclxuICAgICAgICAgICAgICAgIGhhc3RleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyYWNrIGluZGV4ZXMgb2YgZmVhdHVyZXMgd2l0aCB0ZXh0LlxyXG4gICAgICAgIGlmIChoYXN0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRleHRGZWF0dXJlc1tpXSA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBhIGxpc3Qgb2YgdW5pcXVlIGNvZGVwb2ludHMgd2UgYXJlIG1pc3NpbmdcclxuICAgIGNvZGVwb2ludHMgPSB1bmlxKGNvZGVwb2ludHMsIGdseXBocyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0RmVhdHVyZXM6IHRleHRGZWF0dXJlcyxcclxuICAgICAgICBjb2RlcG9pbnRzOiBjb2RlcG9pbnRzXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bmlxKGlkcywgYWxyZWFkeUhhdmUpIHtcclxuICAgIHZhciB1ID0gW107XHJcbiAgICB2YXIgbGFzdDtcclxuICAgIGlkcy5zb3J0KHNvcnROdW1iZXJzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlkc1tpXSAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICBsYXN0ID0gaWRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWFscmVhZHlIYXZlW2xhc3RdKSB1LnB1c2goaWRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdTtcclxufVxyXG5cclxuZnVuY3Rpb24gc29ydE51bWJlcnMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxyXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICByb3RhdGlvblJhbmdlOiByb3RhdGlvblJhbmdlLFxyXG4gICAgbWVyZ2VDb2xsaXNpb25zOiBtZXJnZUNvbGxpc2lvbnMsXHJcblxyXG4gICAgcm90YXRpbmdGaXhlZENvbGxpc2lvbnM6IHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zLFxyXG4gICAgcm90YXRpbmdSb3RhdGluZ0NvbGxpc2lvbnM6IHJvdGF0aW5nUm90YXRpbmdDb2xsaXNpb25zLFxyXG5cclxuICAgIGNvcm5lckJveENvbGxpc2lvbnM6IGNvcm5lckJveENvbGxpc2lvbnMsXHJcbiAgICBjaXJjbGVFZGdlQ29sbGlzaW9uczogY2lyY2xlRWRnZUNvbGxpc2lvbnMsXHJcblxyXG4gICAgZ2V0Q29ybmVyczogZ2V0Q29ybmVycyxcclxufTtcclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgcmFuZ2UgYSBib3ggY29uZmxpY3RzIHdpdGggYSBzZWNvbmQgYm94XHJcbiAqL1xyXG5mdW5jdGlvbiByb3RhdGlvblJhbmdlKGluc2VydGluZywgYmxvY2tlciwgc2NhbGUpIHtcclxuXHJcbiAgICB2YXIgY29sbGlzaW9ucywgYm94O1xyXG5cclxuICAgIHZhciBhID0gaW5zZXJ0aW5nO1xyXG4gICAgdmFyIGIgPSBibG9ja2VyO1xyXG5cclxuICAgIC8vIEluc3RlYWQgb2Ygc2NhbGluZyB0aGUgYm94ZXMsIHdlIG1vdmUgdGhlIGFuY2hvcnNcclxuICAgIHZhciByZWxhdGl2ZUFuY2hvciA9IG5ldyBQb2ludChcclxuICAgICAgICAoYi5hbmNob3IueCAtIGEuYW5jaG9yLngpICogc2NhbGUsXHJcbiAgICAgICAgKGIuYW5jaG9yLnkgLSBhLmFuY2hvci55KSAqIHNjYWxlKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhIGxpc3Qgb2YgY29sbGlzaW9uIGludGVydmFsXHJcbiAgICBpZiAoYS5oQm94ICYmIGIuaEJveCkge1xyXG4gICAgICAgIGNvbGxpc2lvbnMgPSByb3RhdGluZ1JvdGF0aW5nQ29sbGlzaW9ucyhhLmJveCwgYi5ib3gsIHJlbGF0aXZlQW5jaG9yKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGEuaEJveCkge1xyXG4gICAgICAgIGJveCA9IHtcclxuICAgICAgICAgICAgeDE6IGIuYm94LngxICsgcmVsYXRpdmVBbmNob3IueCxcclxuICAgICAgICAgICAgeTE6IGIuYm94LnkxICsgcmVsYXRpdmVBbmNob3IueSxcclxuICAgICAgICAgICAgeDI6IGIuYm94LngyICsgcmVsYXRpdmVBbmNob3IueCxcclxuICAgICAgICAgICAgeTI6IGIuYm94LnkyICsgcmVsYXRpdmVBbmNob3IueVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29sbGlzaW9ucyA9IHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zKGEuYm94LCBib3gpO1xyXG5cclxuXHJcbiAgICB9IGVsc2UgaWYgKGIuaEJveCkge1xyXG4gICAgICAgIGJveCA9IHtcclxuICAgICAgICAgICAgeDE6IGEuYm94LngxIC0gcmVsYXRpdmVBbmNob3IueCxcclxuICAgICAgICAgICAgeTE6IGEuYm94LnkxIC0gcmVsYXRpdmVBbmNob3IueSxcclxuICAgICAgICAgICAgeDI6IGEuYm94LngyIC0gcmVsYXRpdmVBbmNob3IueCxcclxuICAgICAgICAgICAgeTI6IGEuYm94LnkyIC0gcmVsYXRpdmVBbmNob3IueVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29sbGlzaW9ucyA9IHJvdGF0aW5nRml4ZWRDb2xsaXNpb25zKGIuYm94LCBib3gpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sbGlzaW9ucyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgYW5kIHJldHVybiB0aGUgY29udGlub3VzIGFyZSBhcm91bmQgMCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xyXG4gICAgcmV0dXJuIG1lcmdlQ29sbGlzaW9ucyhjb2xsaXNpb25zLCBibG9ja2VyLnBsYWNlbWVudFJhbmdlKTtcclxufVxyXG5cclxuLypcclxuICogQ29tYmluZSBhbiBhcnJheSBvZiBjb2xsaXNpb24gcmFuZ2VzIHRvIGZvcm0gYSBjb250aW51b3VzXHJcbiAqIHJhbmdlIHRoYXQgaW5jbHVkZXMgMC4gQ29sbGlzaW9ucyB3aXRoaW4gdGhlIGlnbm9yZVJhbmdlIGFyZSBpZ25vcmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUNvbGxpc2lvbnMoY29sbGlzaW9ucywgaWdub3JlUmFuZ2UpIHtcclxuXHJcbiAgICAvLyBmaW5kIGNvbnRpbnVvdXMgaW50ZXJ2YWwgaW5jbHVkaW5nIDAgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGNvbGxpc2lvbnNcclxuICAgIHZhciBtaW4gPSAyICogTWF0aC5QSTtcclxuICAgIHZhciBtYXggPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xyXG5cclxuICAgICAgICB2YXIgZW50cnlPdXRzaWRlID0gaWdub3JlUmFuZ2VbMF0gPD0gY29sbGlzaW9uWzBdICYmIGNvbGxpc2lvblswXSA8PSBpZ25vcmVSYW5nZVsxXTtcclxuICAgICAgICB2YXIgZXhpdE91dHNpZGUgPSBpZ25vcmVSYW5nZVswXSA8PSBjb2xsaXNpb25bMV0gJiYgY29sbGlzaW9uWzFdIDw9IGlnbm9yZVJhbmdlWzFdO1xyXG5cclxuICAgICAgICBpZiAoZW50cnlPdXRzaWRlICYmIGV4aXRPdXRzaWRlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGNvbGxpc2lvbiwgc2luY2UgYmxvY2tlciBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5T3V0c2lkZSkge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGlnbm9yZVJhbmdlWzFdKTtcclxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBjb2xsaXNpb25bMV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhpdE91dHNpZGUpIHtcclxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBjb2xsaXNpb25bMF0pO1xyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGlnbm9yZVJhbmdlWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGNvbGxpc2lvblswXSk7XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgY29sbGlzaW9uWzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFttaW4sIG1heF07XHJcbn1cclxuXHJcbi8qXHJcbiAqICBDYWxjdWxhdGUgY29sbGlzaW9uIHJhbmdlcyBmb3IgdHdvIHJvdGF0aW5nIGJveGVzLlxyXG4gKi9cclxuXHJcbnZhciBob3Jpem9udGFsID0gbmV3IFBvaW50KDEsIDApO1xyXG5cclxuZnVuY3Rpb24gcm90YXRpbmdSb3RhdGluZ0NvbGxpc2lvbnMoYSwgYiwgYW5jaG9yVG9BbmNob3IpIHtcclxuICAgIHZhciBkID0gYW5jaG9yVG9BbmNob3IubWFnKCk7XHJcblxyXG4gICAgdmFyIGFuZ2xlQmV0d2VlbkFuY2hvcnMgPSBhbmNob3JUb0FuY2hvci5hbmdsZVdpdGgoaG9yaXpvbnRhbCk7XHJcblxyXG4gICAgdmFyIGMgPSBbXSxcclxuICAgICAgICBjb2xsaXNpb25zID0gW10sXHJcbiAgICAgICAgaztcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYW5nbGVzIGF0IHdoaWNoIGNvbGxpc2lvbnMgbWF5IG9jY3VyXHJcbiAgICAvLyB0b3AvYm90dG9tXHJcbiAgICBjWzBdID0gTWF0aC5hc2luKChhLnkyIC0gYi55MSkgLyBkKTtcclxuICAgIGNbMV0gPSBNYXRoLmFzaW4oKGEueTIgLSBiLnkxKSAvIGQpICsgTWF0aC5QSTtcclxuICAgIGNbMl0gPSAyICogTWF0aC5QSSAtIE1hdGguYXNpbigoLWEueTEgKyBiLnkyKSAvIGQpO1xyXG4gICAgY1szXSA9IE1hdGguUEkgLSBNYXRoLmFzaW4oKC1hLnkxICsgYi55MikgLyBkKTtcclxuXHJcbiAgICAvLyBsZWZ0L3JpZ2h0XHJcbiAgICBjWzRdID0gMiAqIE1hdGguUEkgLSBNYXRoLmFjb3MoKGEueDIgLSBiLngxKSAvIGQpO1xyXG4gICAgY1s1XSA9IE1hdGguYWNvcygoYS54MiAtIGIueDEpIC8gZCk7XHJcbiAgICBjWzZdID0gTWF0aC5QSSAtIE1hdGguYWNvcygoLWEueDEgKyBiLngyKSAvIGQpO1xyXG4gICAgY1s3XSA9IE1hdGguUEkgKyBNYXRoLmFjb3MoKC1hLngxICsgYi54MikgLyBkKTtcclxuXHJcbiAgICB2YXIgcmwgPSBhLngyIC0gYi54MTtcclxuICAgIHZhciBsciA9IC1hLngxICsgYi54MjtcclxuICAgIHZhciB0YiA9IGEueTIgLSBiLnkxO1xyXG4gICAgdmFyIGJ0ID0gLWEueTEgKyBiLnkyO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugc3F1YXJlZCBvZiB0aGUgZGlhZ29uYWwgd2hpY2ggd2lsbCBiZSB1c2VkXHJcbiAgICAvLyB0byBjaGVjayBpZiB0aGUgYm94ZXMgYXJlIGNsb3NlIGVub3VnaCBmb3IgY29sbGlzaW9ucyB0byBvY2N1ciBhdCBlYWNoIGFuZ2xlXHJcbiAgICAvLyB0b2RvLCB0cmlwbGUgY2hlY2sgdGhlc2VcclxuICAgIHZhciBlID0gW107XHJcbiAgICAvLyB0b3AvYm90dG9tXHJcbiAgICBlWzBdID0gcmwgKiBybCArIHRiICogdGI7XHJcbiAgICBlWzFdID0gbHIgKiBsciArIHRiICogdGI7XHJcbiAgICBlWzJdID0gcmwgKiBybCArIGJ0ICogYnQ7XHJcbiAgICBlWzNdID0gbHIgKiBsciArIGJ0ICogYnQ7XHJcbiAgICAvLyBsZWZ0L3JpZ2h0XHJcbiAgICBlWzRdID0gcmwgKiBybCArIHRiICogdGI7XHJcbiAgICBlWzVdID0gcmwgKiBybCArIGJ0ICogYnQ7XHJcbiAgICBlWzZdID0gbHIgKiBsciArIGJ0ICogYnQ7XHJcbiAgICBlWzddID0gbHIgKiBsciArIHRiICogdGI7XHJcblxyXG5cclxuICAgIGMgPSBjLmZpbHRlcihmdW5jdGlvbih4LCBpKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgY2xvc2UgZW5vdWdoIHRvIGNvbGxpZGVcclxuICAgICAgICByZXR1cm4gIWlzTmFOKHgpICYmIGQgKiBkIDw9IGVbaV07XHJcbiAgICB9KS5tYXAoZnVuY3Rpb24oeCkge1xyXG4gICAgICAgIC8vIFNvIGZhciwgYW5nbGVzIGhhdmUgYmVlbiBjYWx1bGF0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIHZlY3RvciBiZXR3ZWVuIGFuY2hvcnMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgYW5nbGVzIHRvIGFuZ2xlcyBmcm9tIG5vcnRoLlxyXG4gICAgICAgIHJldHVybiAoeCArIGFuZ2xlQmV0d2VlbkFuY2hvcnMgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR3JvdXAgdGhlIGNvbGxpc2lvbiBhbmdsZXMgYnkgdHdvXHJcbiAgICAvLyBlYWNoIGdyb3VwIHJlcHJlc2VudHMgYSByYW5nZSB3aGVyZSB0aGUgdHdvIGJveGVzIGNvbGxpZGVcclxuICAgIGMuc29ydCgpO1xyXG4gICAgZm9yIChrID0gMDsgayA8IGMubGVuZ3RoOyBrKz0yKSB7XHJcbiAgICAgICAgY29sbGlzaW9ucy5wdXNoKFtjW2tdLCBjW2srMV1dKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sbGlzaW9ucztcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqICBDYWxjdWxhdGUgY29sbGlzaW9uIHJhbmdlcyBmb3IgYSByb3RhdGluZyBib3ggYW5kIGEgZml4ZWQgYm94O1xyXG4gKi9cclxuZnVuY3Rpb24gcm90YXRpbmdGaXhlZENvbGxpc2lvbnMocm90YXRpbmcsIGZpeGVkKSB7XHJcblxyXG4gICAgdmFyIGNvcm5lcnNSID0gZ2V0Q29ybmVycyhyb3RhdGluZyk7XHJcbiAgICB2YXIgY29ybmVyc0YgPSBnZXRDb3JuZXJzKGZpeGVkKTtcclxuXHJcbiAgICAvLyBBIGNvbGxpc2lvbiBvY2N1cnMgd2hlbiwgYW5kIG9ubHkgYXQgbGVhc3Qgb25lIGNvcm5lciBmcm9tIG9uZSBvZiB0aGUgYm94ZXNcclxuICAgIC8vIGlzIHdpdGhpbiB0aGUgb3RoZXIgYm94LiBDYWxjdWxhdGUgdGhlc2UgcmFuZ2VzIGZvciBlYWNoIGNvcm5lci5cclxuXHJcbiAgICB2YXIgY29sbGlzaW9ucyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrICkge1xyXG4gICAgICAgIGNvcm5lckJveENvbGxpc2lvbnMoY29sbGlzaW9ucywgY29ybmVyc1JbaV0sIGNvcm5lcnNGKTtcclxuICAgICAgICBjb3JuZXJCb3hDb2xsaXNpb25zKGNvbGxpc2lvbnMsIGNvcm5lcnNGW2ldLCBjb3JuZXJzUiwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbGxpc2lvbnM7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiAgQ2FsY3VsYXRlIHRoZSByYW5nZXMgZm9yIHdoaWNoIHRoZSBjb3JuZXIsXHJcbiAqICByb3RhdGF0ZWQgYXJvdW5kIHRoZSBhbmNob3IsIGlzIHdpdGhpbiB0aGUgYm94O1xyXG4gKi9cclxuZnVuY3Rpb24gY29ybmVyQm94Q29sbGlzaW9ucyhjb2xsaXNpb25zLCBjb3JuZXIsIGJveENvcm5lcnMsIGZsaXApIHtcclxuICAgIHZhciByYWRpdXMgPSBjb3JuZXIubWFnKCksXHJcbiAgICAgICAgYW5nbGVzID0gW107XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2ludHMgYXQgd2hpY2ggdGhlIGNvcm5lcnMgaW50ZXJzZWN0IHdpdGggdGhlIGVkZ2VzXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDM7IGkgPCA0OyBqID0gaSsrKSB7XHJcbiAgICAgICAgY2lyY2xlRWRnZUNvbGxpc2lvbnMoYW5nbGVzLCBjb3JuZXIsIHJhZGl1cywgYm94Q29ybmVyc1tqXSwgYm94Q29ybmVyc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuZ2xlcy5sZW5ndGggJSAyICE9PSAwKSB7XHJcbiAgICAgICAgLy8gVE9ETyBmaXhcclxuICAgICAgICAvLyBUaGlzIGNvdWxkIGdldCBoaXQgd2hlbiBhIHBvaW50IGludGVyc2VjdHMgdmVyeSBjbG9zZSB0byBhIGNvcm5lclxyXG4gICAgICAgIC8vIGFuZCBmbG9hdGluZyBwb2ludCBpc3N1ZXMgY2F1c2Ugb25seSBvbmUgb2YgdGhlIGVudHJ5IG9yIGV4aXQgdG8gYmUgY291bnRlZFxyXG4gICAgICAgIHRocm93KCdleHBlY3RpbmcgYW4gZXZlbiBudW1iZXIgb2YgaW50ZXJzZWN0aW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGFuZ2xlcy5zb3J0KCk7XHJcblxyXG4gICAgLy8gR3JvdXAgYnkgcGFpcnMsIHdoZXJlIGVhY2ggcmVwcmVzZW50cyBhIHJhbmdlIHdoZXJlIGEgY29sbGlzaW9uIG9jY3Vyc1xyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBhbmdsZXMubGVuZ3RoOyBrKz0yKSB7XHJcbiAgICAgICAgY29sbGlzaW9uc1trLzJdID0gZmxpcCA/XHJcbiAgICAgICAgICAgIFsyICogTWF0aC5QSSAtIGFuZ2xlc1trKzFdLCAyICogTWF0aC5QSSAtIGFuZ2xlc1trXV0gOiAvLyByZWZsZWN0IGFuIGFuZ2xlIGFyb3VuZCAwIGRlZ3JlZXNcclxuICAgICAgICAgICAgW2FuZ2xlc1trXSwgYW5nbGVzW2srMV1dO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xsaXNpb25zO1xyXG59XHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIGludGVyc2VjdGlvbiBwb2ludHMgb2YgYSBjaXJjbGUgYW5kIGEgbGluZSBzZWdtZW50O1xyXG4gKi9cclxuZnVuY3Rpb24gY2lyY2xlRWRnZUNvbGxpc2lvbnMoYW5nbGVzLCBjb3JuZXIsIHJhZGl1cywgcDEsIHAyKSB7XHJcblxyXG4gICAgdmFyIGVkZ2VYID0gcDIueCAtIHAxLng7XHJcbiAgICB2YXIgZWRnZVkgPSBwMi55IC0gcDEueTtcclxuXHJcbiAgICB2YXIgYSA9IGVkZ2VYICogZWRnZVggKyBlZGdlWSAqIGVkZ2VZO1xyXG4gICAgdmFyIGIgPSAoZWRnZVggKiBwMS54ICsgZWRnZVkgKiBwMS55KSAqIDI7XHJcbiAgICB2YXIgYyA9IHAxLnggKiBwMS54ICsgcDEueSAqIHAxLnkgLSByYWRpdXMgKiByYWRpdXM7XHJcblxyXG4gICAgdmFyIGRpc2NyaW1pbmFudCA9IGIqYiAtIDQqYSpjO1xyXG5cclxuICAgIC8vIGEgY29sbGlzaW9uIGV4aXN0cyBvbmx5IGlmIGxpbmUgaW50ZXJzZWN0cyBjaXJjbGUgYXQgdHdvIHBvaW50c1xyXG4gICAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcclxuICAgICAgICB2YXIgeDEgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xyXG4gICAgICAgIHZhciB4MiA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XHJcblxyXG4gICAgICAgIC8vIG9ubHkgYWRkIHBvaW50cyBpZiB3aXRoaW4gbGluZSBzZWdtZW50XHJcbiAgICAgICAgLy8gaGFjayB0byBoYW5kbGUgZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb25zIG9mIDAgYW5kIDFcclxuICAgICAgICBpZiAoMCA8IHgxICYmIHgxIDwgMSkge1xyXG4gICAgICAgICAgICBhbmdsZXMucHVzaChnZXRBbmdsZShwMSwgcDIsIHgxLCBjb3JuZXIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgwIDwgeDIgJiYgeDIgPCAxKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlcy5wdXNoKGdldEFuZ2xlKHAxLCBwMiwgeDIsIGNvcm5lcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5nbGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIGQsIGNvcm5lcikge1xyXG4gICAgcmV0dXJuICgtY29ybmVyLmFuZ2xlV2l0aFNlcChcclxuICAgICAgICB1dGlsLmludGVycChwMS54LCBwMi54LCBkKSxcclxuICAgICAgICB1dGlsLmludGVycChwMS55LCBwMi55LCBkKSkgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb3JuZXJzKGEpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbmV3IFBvaW50KGEueDEsIGEueTEpLFxyXG4gICAgICAgIG5ldyBQb2ludChhLngxLCBhLnkyKSxcclxuICAgICAgICBuZXcgUG9pbnQoYS54MiwgYS55MiksXHJcbiAgICAgICAgbmV3IFBvaW50KGEueDIsIGEueTEpXHJcbiAgICBdO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc2hhcGU6IHNoYXBlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaGFwZSh0ZXh0LCBuYW1lLCBzdGFja3MsIG1heFdpZHRoLCBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRyYW5zbGF0ZSkge1xyXG4gICAgdmFyIGdseXBocyA9IHN0YWNrc1tuYW1lXS5nbHlwaHM7XHJcbiAgICB2YXIgZ2x5cGg7XHJcblxyXG4gICAgdmFyIHNoYXBpbmcgPSBbXTtcclxuXHJcbiAgICB2YXIgeCA9IHRyYW5zbGF0ZVswXTtcclxuICAgIHZhciB5ID0gdHJhbnNsYXRlWzFdO1xyXG4gICAgdmFyIGlkO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlkID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2lkXTtcclxuXHJcbiAgICAgICAgaWYgKGlkID09PSAwIHx8ICFnbHlwaCkgY29udGludWU7XHJcblxyXG4gICAgICAgIHNoYXBpbmcucHVzaCh7XHJcbiAgICAgICAgICAgIGZvbnRzdGFjazogbmFtZSxcclxuICAgICAgICAgICAgZ2x5cGg6IGlkLFxyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZSArIHNwYWNpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzaGFwaW5nLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHNoYXBpbmcgPSBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnkpO1xyXG5cclxuICAgIHJldHVybiBzaGFwaW5nO1xyXG59XHJcblxyXG52YXIgYnJlYWthYmxlID0geyAzMjogdHJ1ZSB9OyAvLyBDdXJyZW50bHkgb25seSBicmVha3MgYXQgcmVndWxhciBzcGFjZXNcclxuXHJcbmZ1bmN0aW9uIGxpbmV3cmFwKHNoYXBpbmcsIGdseXBocywgbGluZUhlaWdodCwgbWF4V2lkdGgsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSkge1xyXG4gICAgdmFyIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xyXG5cclxuICAgIHZhciBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSA9IDA7XHJcbiAgICB2YXIgbGluZVN0YXJ0SW5kZXggPSAwO1xyXG4gICAgdmFyIGxpbmUgPSAwO1xyXG5cclxuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcclxuXHJcbiAgICBpZiAobWF4V2lkdGgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGluZ1tpXTtcclxuXHJcbiAgICAgICAgICAgIHNoYXBlLnggLT0gbGVuZ3RoQmVmb3JlQ3VycmVudExpbmU7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgKz0gbGluZUhlaWdodCAqIGxpbmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUueCA+IG1heFdpZHRoICYmIGxhc3RTYWZlQnJlYWsgIT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IHNoYXBpbmdbbGFzdFNhZmVCcmVhayArIDFdLng7XHJcbiAgICAgICAgICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZUxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGxhc3RTYWZlQnJlYWsgKyAxOyBrIDw9IGk7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBpbmdba10ueSArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBpbmdba10ueCAtPSBsaW5lTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUxpbmUoc2hhcGluZywgZ2x5cGhzLCBsaW5lU3RhcnRJbmRleCwgbGFzdFNhZmVCcmVhayAtIDEsIGp1c3RpZnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxpbmVTdGFydEluZGV4ID0gbGFzdFNhZmVCcmVhayArIDE7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lICs9IGxpbmVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsaW5lKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChicmVha2FibGVbc2hhcGUuZ2x5cGhdKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtYXhMaW5lTGVuZ3RoID0gbWF4TGluZUxlbmd0aCB8fCBzaGFwaW5nW3NoYXBpbmcubGVuZ3RoIC0gMV0ueDtcclxuXHJcbiAgICBqdXN0aWZ5TGluZShzaGFwaW5nLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBzaGFwaW5nLmxlbmd0aCAtIDEsIGp1c3RpZnkpO1xyXG4gICAgYWxpZ24oc2hhcGluZywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lKTtcclxuICAgIHJldHVybiBzaGFwaW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBqdXN0aWZ5TGluZShzaGFwaW5nLCBnbHlwaHMsIHN0YXJ0LCBlbmQsIGp1c3RpZnkpIHtcclxuICAgIHZhciBsYXN0QWR2YW5jZSA9IGdseXBoc1tzaGFwaW5nW2VuZF0uZ2x5cGhdLmFkdmFuY2U7XHJcbiAgICB2YXIgbGluZUluZGVudCA9IChzaGFwaW5nW2VuZF0ueCArIGxhc3RBZHZhbmNlKSAqIGp1c3RpZnk7XHJcblxyXG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XHJcbiAgICAgICAgc2hhcGluZ1tqXS54IC09IGxpbmVJbmRlbnQ7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBhbGlnbihzaGFwaW5nLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUpIHtcclxuICAgIHZhciBzaGlmdFggPSAoanVzdGlmeSAtIGhvcml6b250YWxBbGlnbikgKiBtYXhMaW5lTGVuZ3RoO1xyXG4gICAgdmFyIHNoaWZ0WSA9ICgtdmVydGljYWxBbGlnbiAqIChsaW5lICsgMSkgKyAwLjUpICogbGluZUhlaWdodDtcclxuXHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYXBpbmcubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBzaGFwaW5nW2pdLnggKz0gc2hpZnRYO1xyXG4gICAgICAgIHNoYXBpbmdbal0ueSArPSBzaGlmdFk7XHJcbiAgICB9XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wuanMnKSxcclxuICAgIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tLmpzJyksXHJcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uO1xyXG5cclxuZnVuY3Rpb24gQXR0cmlidXRpb24oKSB7fVxyXG5cclxuQXR0cmlidXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcclxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtYXR0cmliJyxcclxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBtYXAuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UuYWRkJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIG1hcC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlRWRpdExpbmsuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhdHRyT2JqID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFwLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX21hcC5zb3VyY2VzW2lkXTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS50aWxlSlNPTiAmJiBzb3VyY2UudGlsZUpTT04uYXR0cmlidXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGF0dHJPYmpbc291cmNlLnRpbGVKU09OLmF0dHJpYnV0aW9uXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0ck9iaikge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbnMucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGF0dHJpYnV0aW9ucy5qb2luKCcgfCAnKTtcclxuICAgICAgICB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXBib3gtaW1wcm92ZS1tYXAnKVswXTtcclxuICAgICAgICB0aGlzLl91cGRhdGVFZGl0TGluaygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfdXBkYXRlRWRpdExpbms6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lZGl0TGluaykge1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9lZGl0TGluay5ocmVmID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwLWZlZWRiYWNrLyMvJyArXHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLmxuZyArICcvJyArIGNlbnRlci5sYXQgKyAnLycgKyBNYXRoLnJvdW5kKHRoaXMuX21hcC5nZXRab29tKCkgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2w7XHJcblxyXG5mdW5jdGlvbiBDb250cm9sKCkge31cclxuXHJcbkNvbnRyb2wucHJvdG90eXBlID0ge1xyXG5cdGFkZFRvOiBmdW5jdGlvbihtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbC5qcycpLFxyXG4gICAgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20uanMnKSxcclxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcclxuXHJcbmZ1bmN0aW9uIE5hdmlnYXRpb24oKSB7fVxyXG5cclxuTmF2aWdhdGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xyXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1uYXYnO1xyXG5cclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBtYXAuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctem9vbS1pbicsIG1hcC56b29tSW4uYmluZChtYXApKTtcclxuICAgICAgICB0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctem9vbS1vdXQnLCBtYXAuem9vbU91dC5iaW5kKG1hcCkpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbXBhc3NDYW52YXMgPSB0aGlzLl9jb21wYXNzQ2FudmFzID0gRE9NLmNyZWF0ZSgnY2FudmFzJywgY2xhc3NOYW1lICsgJy1jb21wYXNzLWNhbnZhcycsIHRoaXMuX2NvbXBhc3MpO1xyXG4gICAgICAgIGNvbXBhc3NDYW52YXMuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDoyNnB4OyBoZWlnaHQ6MjZweDsnO1xyXG4gICAgICAgIGNvbXBhc3NDYW52YXMud2lkdGggPSAyNiAqIDI7XHJcbiAgICAgICAgY29tcGFzc0NhbnZhcy5oZWlnaHQgPSAyNiAqIDI7XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbXBhc3MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Db21wYXNzRG93bi5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9vbkNvbXBhc3NNb3ZlID0gdGhpcy5fb25Db21wYXNzTW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29tcGFzc0N0eCA9IGNvbXBhc3NDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgbWFwLm9uKCdyb3RhdGUnLCB0aGlzLl9kcmF3Tm9ydGguYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5fZHJhd05vcnRoKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNvbXBhc3NEb3duOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgRE9NLmRpc2FibGVEcmFnKCk7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQ29tcGFzc01vdmUpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XHJcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XHJcblxyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNvbXBhc3NNb3ZlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIHggPSBlLnNjcmVlblgsXHJcbiAgICAgICAgICAgIGQgPSB4IDwgMiA/IC01IDogLy8gbGVmdCBlZGdlIG9mIHRoZSBzY3JlZW4sIGNvbnRpbnVlIHJvdGF0aW5nXHJcbiAgICAgICAgICAgICAgICB4ID4gd2luZG93LnNjcmVlbi53aWR0aCAtIDIgPyA1IDogLy8gcmlnaHQgZWRnZVxyXG4gICAgICAgICAgICAgICAgKHggLSB0aGlzLl9wcmV2WCkgLyA0O1xyXG5cclxuICAgICAgICB0aGlzLl9tYXAuc2V0QmVhcmluZyh0aGlzLl9tYXAuZ2V0QmVhcmluZygpIC0gZCk7XHJcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgX29uQ29tcGFzc1VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Db21wYXNzVXApO1xyXG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uKGNsYXNzTmFtZSwgZm4pIHtcclxuICAgICAgICB2YXIgYSA9IERPTS5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgYS5ocmVmID0gJyMnO1xyXG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9LFxyXG5cclxuICAgIF9kcmF3Tm9ydGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByYWQgPSAyMCxcclxuICAgICAgICAgICAgd2lkdGggPSA4LFxyXG4gICAgICAgICAgICBjZW50ZXIgPSAyNixcclxuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICsgKE1hdGguUEkgLyAyKSxcclxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fY29tcGFzc0N0eDtcclxuXHJcbiAgICAgICAgdGhpcy5fY29tcGFzc0NhbnZhcy53aWR0aCA9IHRoaXMuX2NvbXBhc3NDYW52YXMud2lkdGg7XHJcblxyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLCBjZW50ZXIpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcclxuICAgICAgICBjdHgubGluZVRvKDAsIC13aWR0aCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygtcmFkLCAwKTtcclxuICAgICAgICBjdHgubGluZVRvKDAsIHdpZHRoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjYmJiJztcclxuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xyXG4gICAgICAgIGN0eC5saW5lVG8oMCwgd2lkdGgpO1xyXG4gICAgICAgIGN0eC5saW5lVG8ocmFkLCAwKTtcclxuICAgICAgICBjdHgubGluZVRvKDAsIC13aWR0aCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gNDtcclxuICAgICAgICBjdHgubW92ZVRvKDAsIC13aWR0aCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygwLCB3aWR0aCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcclxuICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKSxcclxuICAgIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmcuanMnKSxcclxuICAgIExhdExuZ0JvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmdib3VuZHMuanMnKSxcclxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcclxuXHJcbnV0aWwuZXh0ZW5kKGV4cG9ydHMsIHtcclxuICAgIGlzRWFzaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYWJvcnRGbjtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hYm9ydEZuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Rm4uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Fib3J0Rm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9maW5pc2hGbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZmluaXNoRm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZWFzZTogZnVuY3Rpb24oZnJhbWUsIGZpbmlzaCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaEZuID0gZmluaXNoO1xyXG4gICAgICAgIHRoaXMuX2Fib3J0Rm4gPSBicm93c2VyLnRpbWVkKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgIGZyYW1lLmNhbGwodGhpcywgb3B0aW9ucy5lYXNpbmcodCkpO1xyXG4gICAgICAgICAgICBpZiAodCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Fib3J0Rm47XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hGbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaEZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uLCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB1dGlsLmV4dGVuZCh7b2Zmc2V0OiBQb2ludC5jb252ZXJ0KG9mZnNldCkubXVsdCgtMSl9LCBvcHRpb25zKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhblRvOiBmdW5jdGlvbihsYXRsbmcsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgbGF0bG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcclxuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2UsXHJcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KS5yb3RhdGUoLXRyLmFuZ2xlKSxcclxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxyXG4gICAgICAgICAgICB0byA9IHRyLnByb2plY3QobGF0bG5nKS5zdWIob2Zmc2V0KTtcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcclxuICAgICAgICAgICAgdHIuY2VudGVyID0gdHIudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1Yihmcm9tKS5tdWx0KGspKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdmUoKTtcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBab29tcyB0byBhIGNlcnRhaW4gem9vbSBsZXZlbCB3aXRoIGVhc2luZy5cclxuICAgIHpvb21UbzogZnVuY3Rpb24oem9vbSwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMuZWFzaW5nID0gdGhpcy5fdXBkYXRlRWFzaW5nKG9wdGlvbnMuZHVyYXRpb24sIHpvb20sIG9wdGlvbnMuZWFzaW5nKTtcclxuXHJcbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLmNlbnRlcixcclxuICAgICAgICAgICAgc3RhcnRab29tID0gdHIuem9vbTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFyb3VuZCA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLnBvaW50TG9jYXRpb24odHIuY2VudGVyUG9pbnQuYWRkKFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkgb3B0aW9ucy5kdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy56b29taW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcclxuICAgICAgICAgICAgdHIuc2V0Wm9vbUFyb3VuZCh1dGlsLmludGVycChzdGFydFpvb20sIHpvb20sIGspLCBhcm91bmQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuX21vdmUodHJ1ZSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWFzZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmR1cmF0aW9uID49IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA8IDIwMCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25ab29tRW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fb25ab29tRW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDIwMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgem9vbUluOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgKyAxLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgem9vbU91dDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpIC0gMSwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbihiZWFyaW5nLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0QmVhcmluZygpLFxyXG4gICAgICAgICAgICBhcm91bmQgPSB0ci5jZW50ZXI7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmFyb3VuZCkge1xyXG4gICAgICAgICAgICBhcm91bmQgPSBMYXRMbmcuY29udmVydChvcHRpb25zLmFyb3VuZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9mZnNldCkge1xyXG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZChQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgICAgIHRyLnNldEJlYXJpbmdBcm91bmQodXRpbC5pbnRlcnAoc3RhcnQsIGJlYXJpbmcsIGspLCBhcm91bmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICAgICAgICB9LCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0Tm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVUbygwLCB1dGlsLmV4dGVuZCh7ZHVyYXRpb246IDEwMDB9LCBvcHRpb25zKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpdEJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxyXG4gICAgICAgICAgICBtYXhab29tOiBJbmZpbml0eVxyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBib3VuZHMgPSBMYXRMbmdCb3VuZHMuY29udmVydChib3VuZHMpO1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXHJcbiAgICAgICAgICAgIHRyID0gdGhpcy50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIG53ID0gdHIucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gICAgICAgICAgICBzZSA9IHRyLnByb2plY3QoYm91bmRzLmdldFNvdXRoRWFzdCgpKSxcclxuICAgICAgICAgICAgc2l6ZSA9IHNlLnN1YihudyksXHJcbiAgICAgICAgICAgIGNlbnRlciA9IHRyLnVucHJvamVjdChudy5hZGQoc2UpLmRpdigyKSksXHJcblxyXG4gICAgICAgICAgICBzY2FsZVggPSAodHIud2lkdGggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LngpICogMikgLyBzaXplLngsXHJcbiAgICAgICAgICAgIHNjYWxlWSA9ICh0ci5oZWlnaHQgLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LnkpICogMikgLyBzaXplLnksXHJcblxyXG4gICAgICAgICAgICB6b29tID0gTWF0aC5taW4odHIuc2NhbGVab29tKHRyLnNjYWxlICogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSwgb3B0aW9ucy5tYXhab29tKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGluZWFyID9cclxuICAgICAgICAgICAgdGhpcy5lYXNlVG8oY2VudGVyLCB6b29tLCAwLCBvcHRpb25zKSA6XHJcbiAgICAgICAgICAgIHRoaXMuZmx5VG8oY2VudGVyLCB6b29tLCAwLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgZWFzZVRvOiBmdW5jdGlvbihsYXRsbmcsIHpvb20sIGJlYXJpbmcsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcclxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KS5yb3RhdGUoLXRyLmFuZ2xlKSxcclxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXHJcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpO1xyXG5cclxuICAgICAgICBsYXRsbmcgPSBMYXRMbmcuY29udmVydChsYXRsbmcpO1xyXG4gICAgICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB6b29tO1xyXG4gICAgICAgIGJlYXJpbmcgPSBiZWFyaW5nID09PSB1bmRlZmluZWQgPyBzdGFydEJlYXJpbmcgOiBiZWFyaW5nO1xyXG5cclxuICAgICAgICB2YXIgc2NhbGUgPSB0ci56b29tU2NhbGUoem9vbSAtIHN0YXJ0Wm9vbSksXHJcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcclxuICAgICAgICAgICAgdG8gPSBsYXRsbmcgPyB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldC5kaXYoc2NhbGUpKSA6IHRyLnBvaW50LFxyXG4gICAgICAgICAgICBhcm91bmQ7XHJcblxyXG4gICAgICAgIGlmICh6b29tICE9PSBzdGFydFpvb20pIHtcclxuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQodG8uc3ViKGZyb20pLmRpdigxIC0gMSAvIHNjYWxlKSkpO1xyXG4gICAgICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICBpZiAoem9vbSAhPT0gc3RhcnRab29tKSB7XHJcbiAgICAgICAgICAgICAgICB0ci5zZXRab29tQXJvdW5kKHV0aWwuaW50ZXJwKHN0YXJ0Wm9vbSwgem9vbSwgayksIGFyb3VuZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQoaykpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZykge1xyXG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IHV0aWwuaW50ZXJwKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcclxuICAgICAgICAgICAgdGhpcy5fbW92ZSh6b29tICE9PSBzdGFydFpvb20sIGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZmx5VG86IGZ1bmN0aW9uKGxhdGxuZywgem9vbSwgYmVhcmluZywgb3B0aW9ucykge1xyXG5cclxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICAgICAgc3BlZWQ6IDEuMixcclxuICAgICAgICAgICAgY3VydmU6IDEuNDIsXHJcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGxhdGxuZyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcclxuICAgICAgICAgICAgdHIgPSB0aGlzLnRyYW5zZm9ybSxcclxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXHJcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpO1xyXG5cclxuICAgICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogem9vbTtcclxuICAgICAgICBiZWFyaW5nID0gYmVhcmluZyA9PT0gdW5kZWZpbmVkID8gc3RhcnRCZWFyaW5nIDogYmVhcmluZztcclxuXHJcbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxyXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXHJcbiAgICAgICAgICAgIHRvID0gdHIucHJvamVjdChsYXRsbmcpLnN1YihvZmZzZXQuZGl2KHNjYWxlKSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXcobGF0bG5nLCB6b29tLCBiZWFyaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdGFydFdvcmxkU2l6ZSA9IHRyLndvcmxkU2l6ZSxcclxuICAgICAgICAgICAgcmhvID0gb3B0aW9ucy5jdXJ2ZSxcclxuICAgICAgICAgICAgViA9IG9wdGlvbnMuc3BlZWQsXHJcblxyXG4gICAgICAgICAgICB3MCA9IE1hdGgubWF4KHRyLndpZHRoLCB0ci5oZWlnaHQpLFxyXG4gICAgICAgICAgICB3MSA9IHcwIC8gc2NhbGUsXHJcbiAgICAgICAgICAgIHUxID0gdG8uc3ViKGZyb20pLm1hZygpLFxyXG4gICAgICAgICAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByKGkpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSAodzEgKiB3MSAtIHcwICogdzAgKyAoaSA/IC0xIDogMSkgKiByaG8yICogcmhvMiAqIHUxICogdTEpIC8gKDIgKiAoaSA/IHcxIDogdzApICogcmhvMiAqIHUxKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKE1hdGguc3FydChiICogYiArIDEpIC0gYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcbiAgICAgICAgdmFyIHIwID0gcigwKSxcclxuICAgICAgICAgICAgdyA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9LFxyXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHcwICogKChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzIpIC8gdTE7IH0sXHJcbiAgICAgICAgICAgIFMgPSAocigxKSAtIHIwKSAvIHJobztcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHUxKSA8IDAuMDAwMDAxKSB7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh3MCAtIHcxKSA8IDAuMDAwMDAxKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gdzEgPCB3MCA/IC0xIDogMTtcclxuICAgICAgICAgICAgUyA9IE1hdGguYWJzKE1hdGgubG9nKHcxIC8gdzApKSAvIHJobztcclxuXHJcbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XHJcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbihzKSB7IHJldHVybiBNYXRoLmV4cChrICogcmhvICogcyk7IH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMTAwMCAqIFMgLyBWO1xyXG5cclxuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChzdGFydEJlYXJpbmcgIT0gYmVhcmluZykgdGhpcy5yb3RhdGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBrICogUyxcclxuICAgICAgICAgICAgICAgIHVzID0gdShzKTtcclxuXHJcbiAgICAgICAgICAgIHRyLnpvb20gPSBzdGFydFpvb20gKyB0ci5zY2FsZVpvb20oMSAvIHcocykpO1xyXG4gICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQodXMpKSwgc3RhcnRXb3JsZFNpemUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZykge1xyXG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IHV0aWwuaW50ZXJwKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21vdmUodHJ1ZSwgYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKTtcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfdXBkYXRlRWFzaW5nOiBmdW5jdGlvbihkdXJhdGlvbiwgem9vbSwgYmV6aWVyKSB7XHJcbiAgICAgICAgdmFyIGVhc2luZztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWFzZSkge1xyXG4gICAgICAgICAgICB2YXIgZWFzZSA9IHRoaXMuZWFzZSxcclxuICAgICAgICAgICAgICAgIHQgPSAoRGF0ZS5ub3coKSAtIGVhc2Uuc3RhcnQpIC8gZWFzZS5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIHNwZWVkID0gZWFzZS5lYXNpbmcodCArIDAuMDEpIC0gZWFzZS5lYXNpbmcodCksXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUXVpY2sgaGFjayB0byBtYWtlIG5ldyBiZXppZXIgdGhhdCBpcyBjb250aW51b3VzIHdpdGggbGFzdFxyXG4gICAgICAgICAgICAgICAgeCA9IDAuMjcgLyBNYXRoLnNxcnQoc3BlZWQgKiBzcGVlZCArIDAuMDAwMSkgKiAwLjAxLFxyXG4gICAgICAgICAgICAgICAgeSA9IE1hdGguc3FydCgwLjI3ICogMC4yNyAtIHggKiB4KTtcclxuXHJcbiAgICAgICAgICAgIGVhc2luZyA9IHV0aWwuYmV6aWVyKHgsIHksIDAuMjUsIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVhc2luZyA9IGJlemllciA/IHV0aWwuYmV6aWVyLmFwcGx5KHV0aWwsIGJlemllcikgOiB1dGlsLmVhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdG9yZSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IGVhc2luZ1xyXG4gICAgICAgIHRoaXMuZWFzZSA9IHtcclxuICAgICAgICAgICAgc3RhcnQ6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIHRvOiBNYXRoLnBvdygyLCB6b29tKSxcclxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBlYXNpbmc6IGVhc2luZ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBlYXNpbmc7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuL2ludGVyYWN0aW9uLmpzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZXJzO1xyXG5cclxuZnVuY3Rpb24gSGFuZGxlcnMobWFwKSB7XHJcblxyXG4gICAgdmFyIHJvdGF0ZUVuZDtcclxuXHJcbiAgICB2YXIgaW5lcnRpYUxpbmVhcml0eSA9IDAuMixcclxuICAgICAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSk7XHJcblxyXG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbihtYXAuY29udGFpbmVyKVxyXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIG1hcC5maXJlKCdjbGljaycsIGUpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdob3ZlcicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgbWFwLmZpcmUoJ2hvdmVyJywgZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2Rvd24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG1hcC5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbigncmVzaXplJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XHJcbiAgICAgICAgICAgIG1hcC5yZXNpemUoKTtcclxuICAgICAgICAgICAgbWFwLnVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdwYW4nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XHJcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0ucGFuQnkoZS5vZmZzZXQpO1xyXG4gICAgICAgICAgICBtYXAuX21vdmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbigncGFuZW5kJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAoIWUuaW5lcnRpYSkgbWFwLmZpcmUoJ21vdmVlbmQnKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHZlbG9jaXR5IHRvIHB4L3MgJiBhZGp1c3QgZm9yIGluY3JlYXNlZCBpbml0aWFsIGFuaW1hdGlvbiBzcGVlZCB3aGVuIGVhc2luZyBvdXRcclxuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IGUuaW5lcnRpYS5tdWx0KDEwMDAgKiBpbmVydGlhTGluZWFyaXR5KSxcclxuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IHZlbG9jaXR5Lm1hZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXhTcGVlZCA9IDQwMDA7IC8vIHB4L3NcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWQgPj0gbWF4U3BlZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IG1heFNwZWVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5Ll91bml0KCkuX211bHQobWF4U3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWNlbGVyYXRpb24gPSA4MDAwLCAvLyBweC9zXjJcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHNwZWVkIC8gKGRlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHZlbG9jaXR5Lm11bHQoLWR1cmF0aW9uIC8gMikucm91bmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXAucGFuQnkob2Zmc2V0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMTAwMCxcclxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ3pvb20nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZS5kZWx0YSAvIDEwMCkpKTtcclxuICAgICAgICAgICAgaWYgKGUuZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSBzY2FsZSA9IDEgLyBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmcm9tU2NhbGUgPSBtYXAuZWFzZSAmJiBpc0Zpbml0ZShlLmRlbHRhKSA/IG1hcC5lYXNlLnRvIDogbWFwLnRyYW5zZm9ybS5zY2FsZSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gIWlzRmluaXRlKGUuZGVsdGEpID8gODAwIDogZS5zb3VyY2UgPT0gJ3RyYWNrcGFkJyA/IDAgOiAzMDA7XHJcblxyXG4gICAgICAgICAgICBtYXAuem9vbVRvKG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKGZyb21TY2FsZSAqIHNjYWxlKSwge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXJvdW5kOiBtYXAudW5wcm9qZWN0KGUucG9pbnQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdyb3RhdGUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBtYXAudHJhbnNmb3JtLmNlbnRlclBvaW50LCAvLyBDZW50ZXIgb2Ygcm90YXRpb25cclxuICAgICAgICAgICAgICAgIHN0YXJ0VG9DZW50ZXIgPSBlLnN0YXJ0LnN1YihjZW50ZXIpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRUb0NlbnRlckRpc3QgPSBzdGFydFRvQ2VudGVyLm1hZygpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNsaWNrIHdhcyB0b28gY2xvc2UgdG8gdGhlIGNlbnRlciwgbW92ZSB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIGJ5IDIwMCBwaXhlbHNcclxuICAgICAgICAgICAgLy8gaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY2xpY2suXHJcbiAgICAgICAgICAgIGlmIChzdGFydFRvQ2VudGVyRGlzdCA8IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyID0gZS5zdGFydC5hZGQobmV3IFBvaW50KC0yMDAsIDApLl9yb3RhdGUoc3RhcnRUb0NlbnRlci5hbmdsZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBiZWFyaW5nRGlmZiA9IGUucHJldi5zdWIoY2VudGVyKS5hbmdsZVdpdGgoZS5jdXJyZW50LnN1YihjZW50ZXIpKSAvIE1hdGguUEkgKiAxODA7XHJcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0uYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZjtcclxuXHJcbiAgICAgICAgICAgIG1hcC5fbW92ZShmYWxzZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJvdGF0ZUVuZCk7XHJcbiAgICAgICAgICAgIHJvdGF0ZUVuZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgbWFwLnJvdGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBtYXAuX3JlcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH0sIDIwMCk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcclxuXHJcbmZ1bmN0aW9uIEhhc2gobWFwKSB7XHJcbiAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5vbmhhc2guYmluZCh0aGlzKSwgZmFsc2UpO1xyXG4gICAgbWFwLm9uKCdtb3ZlJywgdXRpbC5kZWJvdW5jZSh0aGlzLnVwZGF0ZUhhc2guYmluZCh0aGlzKSwgMTAwKSk7XHJcbn1cclxuXHJcbkhhc2gucHJvdG90eXBlID0ge1xyXG4gICAgb25oYXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbG9jID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgaWYgKGxvYy5sZW5ndGggPj0gMykge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRWaWV3KFsrbG9jWzFdLCArbG9jWzJdXSwgK2xvY1swXSwgKyhsb2NbM10gfHwgMCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVIYXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5tYXAuZ2V0Q2VudGVyKCksXHJcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLm1hcC5nZXRab29tKCksXHJcbiAgICAgICAgICAgIGJlYXJpbmcgPSB0aGlzLm1hcC5nZXRCZWFyaW5nKCksXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZyh6b29tKSAvIE1hdGguTE4yKSksXHJcblxyXG4gICAgICAgICAgICBoYXNoID0gJyMnICsgKE1hdGgucm91bmQoem9vbSAqIDEwMCkgLyAxMDApICtcclxuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sYXQudG9GaXhlZChwcmVjaXNpb24pICtcclxuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sbmcudG9GaXhlZChwcmVjaXNpb24pICtcclxuICAgICAgICAgICAgICAgIChiZWFyaW5nID8gJy8nICsgKE1hdGgucm91bmQoYmVhcmluZyAqIDEwKSAvIDEwKSA6ICcnKTtcclxuXHJcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCAnJywgaGFzaCk7XHJcbiAgICB9XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkLmpzJyksXHJcbiAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyksXHJcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uO1xyXG5cclxuZnVuY3Rpb24gSW50ZXJhY3Rpb24oZWwpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IHRoaXM7XHJcbiAgICBpZiAoIWVsKSByZXR1cm47XHJcblxyXG4gICAgdmFyIHJvdGF0aW5nID0gZmFsc2UsXHJcbiAgICAgICAgcGFubmVkID0gZmFsc2UsXHJcbiAgICAgICAgZmlyc3RQb3MgPSBudWxsLFxyXG4gICAgICAgIHBvcyA9IG51bGwsXHJcbiAgICAgICAgaW5lcnRpYSA9IG51bGwsXHJcbiAgICAgICAgbm93O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNlUG9zKGUpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXHJcbiAgICAgICAgICAgIGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGVsLmNsaWVudExlZnQsXHJcbiAgICAgICAgICAgIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gZWwuY2xpZW50VG9wKTtcclxuICAgIH1cclxuXHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgcm90YXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGZpcnN0UG9zID0gcG9zID0gbW91c2VQb3MoZXYpO1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9LCBmYWxzZSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbm1vdXNlZG93biwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9ubW91c2V1cCwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25tb3VzZW1vdmUsIGZhbHNlKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xyXG4gICAgc2Nyb2xsd2hlZWwoem9vbSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIG9uZG91YmxlY2xpY2ssIGZhbHNlKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUsIGZhbHNlKTtcclxuXHJcbiAgICBmdW5jdGlvbiB6b29tKHR5cGUsIGRlbHRhLCBwb2ludCkge1xyXG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3pvb20nLCB7XHJcbiAgICAgICAgICAgIHNvdXJjZTogdHlwZSxcclxuICAgICAgICAgICAgZGVsdGE6IGRlbHRhLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnRcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbmVydGlhID0gbnVsbDtcclxuICAgICAgICBub3cgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsaWNrKHBvaW50KSB7XHJcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnY2xpY2snLCB7cG9pbnQ6IHBvaW50fSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaG92ZXIocG9pbnQpIHtcclxuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdob3ZlcicsIHtwb2ludDogcG9pbnR9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYW4ocG9pbnQpIHtcclxuICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBwb3Muc3ViKHBvaW50KTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgncGFuJywge29mZnNldDogb2Zmc2V0fSk7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgYW4gYXZlcmFnZWQgdmVyc2lvbiBvZiB0aGlzIG1vdmVtZW50IHRvIHRoZSBpbmVydGlhIHZlY3RvclxyXG4gICAgICAgICAgICBpZiAoaW5lcnRpYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIG5vdztcclxuICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBpdCdzIDAgYWZ0ZXIgc29tZSBlcnJhdGljIHBhbmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBkdXJhdGlvbiArIG5vdztcclxuICAgICAgICAgICAgICAgICAgICBpbmVydGlhLnB1c2goW3RpbWUsIHBvaW50XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMiAmJiB0aW1lIC0gaW5lcnRpYVswXVswXSA+IDEwMCkgaW5lcnRpYS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluZXJ0aWEgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBwb3MgPSBwb2ludDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xyXG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3Jlc2l6ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvdGF0ZShwb2ludCkge1xyXG4gICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgncm90YXRlJywge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0UG9zLFxyXG4gICAgICAgICAgICAgICAgcHJldjogcG9zLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudDogcG9pbnRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBvcyA9IHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbm1vdXNlZG93bihldikge1xyXG4gICAgICAgIGZpcnN0UG9zID0gcG9zID0gbW91c2VQb3MoZXYpO1xyXG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2Rvd24nKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbm1vdXNldXAoKSB7XHJcbiAgICAgICAgcGFubmVkID0gcG9zICYmIGZpcnN0UG9zICYmIChwb3MueCAhPSBmaXJzdFBvcy54IHx8IHBvcy55ICE9IGZpcnN0UG9zLnkpO1xyXG5cclxuICAgICAgICByb3RhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHBvcyA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChpbmVydGlhICYmIGluZXJ0aWEubGVuZ3RoID49IDIgJiYgbm93ID4gRGF0ZS5ub3coKSAtIDEwMCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gbGFzdFsxXS5zdWIoZmlyc3RbMV0pLmRpdihsYXN0WzBdIC0gZmlyc3RbMF0pO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdwYW5lbmQnLCAge2luZXJ0aWE6IHZlbG9jaXR5fSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpbnRlcmFjdGlvbi5maXJlKCdwYW5lbmQnKTtcclxuXHJcbiAgICAgICAgaW5lcnRpYSA9IG51bGw7XHJcbiAgICAgICAgbm93ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbm1vdXNlbW92ZShldikge1xyXG4gICAgICAgIHZhciBwb2ludCA9IG1vdXNlUG9zKGV2KTtcclxuXHJcbiAgICAgICAgaWYgKHJvdGF0aW5nKSB7IHJvdGF0ZShwb2ludCk7IH1cclxuICAgICAgICBlbHNlIGlmIChwb3MpIHBhbihwb2ludCk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50b0VsZW1lbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9IGVsICYmIHRhcmdldC5wYXJlbnROb2RlKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgaG92ZXIocG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uY2xpY2soZXYpIHtcclxuICAgICAgICBpZiAoIXBhbm5lZCkgY2xpY2sobW91c2VQb3MoZXYpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbmRvdWJsZWNsaWNrKGV2KSB7XHJcbiAgICAgICAgem9vbSgnd2hlZWwnLCBJbmZpbml0eSAqIChldi5zaGlmdEtleSA/IC0xIDogMSksIG1vdXNlUG9zKGV2KSk7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY3JvbGx3aGVlbChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBmaXJlZm94ID0gL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgICAgIHZhciBzYWZhcmkgPSAvU2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0Nocm9tKGl1bXxlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgICAgdmFyIHRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZTtcclxuXHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB3aGVlbCwgZmFsc2UpO1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHZhciBsYXN0RXZlbnQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHR5cGVUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2Nyb2xsKHZhbHVlLCBldikge1xyXG4gICAgICAgICAgICB2YXIgc3RhbXAgPSB0aW1lLm5vdygpO1xyXG4gICAgICAgICAgICB2YXIgdGltZURlbHRhID0gc3RhbXAgLSBsYXN0RXZlbnQ7XHJcbiAgICAgICAgICAgIGxhc3RFdmVudCA9IHN0YW1wO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbW91c2VQb3MoZXYpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9ICd3aGVlbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RyYWNrcGFkJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lRGVsdGEgPiA0MDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgbmV3IHNjcm9sbCBhY3Rpb24uXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgYSB0aW1lb3V0IGluIGNhc2UgdGhpcyB3YXMgYSBzaW5ndWxhciBldmVudCwgYW5kIGRlbHkgaXRcclxuICAgICAgICAgICAgICAgIC8vIGJ5IHVwIHRvIDQwbXMuXHJcbiAgICAgICAgICAgICAgICB0eXBlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICd3aGVlbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHlwZSwgLWluaXRpYWxWYWx1ZSwgcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfSwgNDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHlldC4gSWYgdGhlIGRlbHRhIHBlciB0aW1lIGlzIHNtYWxsLCB3ZSBhc3N1bWUgaXQncyBhXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHRyYWNrcGFkOyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cclxuICAgICAgICAgICAgICAgIHR5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZVxyXG4gICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG9cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHlwZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgIC8vIGRldmljZSB0aGUgdXNlciB1c2VzLlxyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHlwZSwgLXZhbHVlLCBwb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdoZWVsKGUpIHtcclxuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZO1xyXG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxyXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIGRlbHRhWSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkgZGVsdGFZICo9IDQwO1xyXG4gICAgICAgICAgICBzY3JvbGwoZGVsdGFZLCBlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbW91c2V3aGVlbChlKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSAtZS53aGVlbERlbHRhWTtcclxuICAgICAgICAgICAgaWYgKHNhZmFyaSkgZGVsdGFZID0gZGVsdGFZIC8gMztcclxuICAgICAgICAgICAgc2Nyb2xsKGRlbHRhWSwgZSk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbkludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vdXRpbC9kaXNwYXRjaGVyLmpzJyksXHJcbiAgICBDYW52YXMgPSByZXF1aXJlKCcuLi91dGlsL2NhbnZhcy5qcycpLFxyXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxyXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpLFxyXG4gICAgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheC5qcycpLFxyXG4gICAgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpLFxyXG5cclxuICAgIFN0eWxlID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGUuanMnKSxcclxuICAgIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuLi9zdHlsZS9hbmltYXRpb25sb29wLmpzJyksXHJcbiAgICBHTFBhaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXIvcGFpbnRlci5qcycpLFxyXG5cclxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0uanMnKSxcclxuICAgIEhhc2ggPSByZXF1aXJlKCcuL2hhc2guanMnKSxcclxuICAgIEhhbmRsZXJzID0gcmVxdWlyZSgnLi9oYW5kbGVycy5qcycpLFxyXG4gICAgU291cmNlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZS5qcycpLFxyXG4gICAgRWFzaW5ncyA9IHJlcXVpcmUoJy4vZWFzaW5ncy5qcycpLFxyXG4gICAgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZy5qcycpLFxyXG4gICAgTGF0TG5nQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZ2JvdW5kcy5qcycpLFxyXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxyXG4gICAgR2x5cGhTb3VyY2UgPSByZXF1aXJlKCcuLi9zeW1ib2wvZ2x5cGhzb3VyY2UuanMnKSxcclxuICAgIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi9jb250cm9sL2F0dHJpYnV0aW9uLmpzJyk7XHJcblxyXG4vLyBhbGxvdyByZWRlZmluaW5nIE1hcCBoZXJlIChqc2hpbnQgdGhpbmtzIGl0J3MgZ2xvYmFsKVxyXG4vLyBqc2hpbnQgLVcwNzlcclxuXHJcbnZhciBNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5pbmhlcml0KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcbiAgICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggJiYgbmV3IEhhc2godGhpcyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgICAgICAgdmFyIGIgPSBMYXRMbmdCb3VuZHMuY29udmVydChvcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ubGF0UmFuZ2UgPSBbYi5nZXRTb3V0aCgpLCBiLmdldE5vcnRoKCldO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb25TdHlsZUNoYW5nZSA9IHRoaXMuX29uU3R5bGVDaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX3VwZGF0ZUJ1Y2tldHMgPSB0aGlzLl91cGRhdGVCdWNrZXRzLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5fc2V0dXBDb250YWluZXIoKTtcclxuICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zLmludGVyYWN0aXZlICYmIG5ldyBIYW5kbGVycyh0aGlzKTtcclxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKE1hdGgubWF4KG9wdGlvbnMubnVtV29ya2VycywgMSksIHRoaXMpO1xyXG5cclxuICAgICAvLyBkb24ndCBzZXQgcG9zaXRpb24gZnJvbSBvcHRpb25zIGlmIHNldCB0aHJvdWdoIGhhc2hcclxuICAgIGlmICghdGhpcy5oYXNoIHx8ICF0aGlzLmhhc2gub25oYXNoKCkpIHtcclxuICAgICAgICB0aGlzLnNldFZpZXcob3B0aW9ucy5jZW50ZXIsIG9wdGlvbnMuem9vbSwgb3B0aW9ucy5iZWFyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcclxuICAgIHRoaXMuc3RhY2tzID0ge307XHJcblxyXG4gICAgdGhpcy5yZXNpemUoKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3R5bGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnN0eWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGFqYXguZ2V0SlNPTihvcHRpb25zLnN0eWxlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShkYXRhKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkgdGhpcy5hZGRDb250cm9sKG5ldyBBdHRyaWJ1dGlvbigpKTtcclxufTtcclxuXHJcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIEV2ZW50ZWQpO1xyXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFYXNpbmdzKTtcclxudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwge1xyXG5cclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBjZW50ZXI6IFswLCAwXSxcclxuICAgICAgICB6b29tOiAwLFxyXG4gICAgICAgIGJlYXJpbmc6IDAsXHJcblxyXG4gICAgICAgIG1pblpvb206IDAsXHJcbiAgICAgICAgbWF4Wm9vbTogMjAsXHJcbiAgICAgICAgbnVtV29ya2VyczogYnJvd3Nlci5oYXJkd2FyZUNvbmN1cnJlbmN5IC0gMSxcclxuXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgaGFzaDogZmFsc2UsXHJcblxyXG4gICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZXNbaWRdID0gc291cmNlO1xyXG4gICAgICAgIHNvdXJjZS5pZCA9IGlkO1xyXG4gICAgICAgIGlmIChzb3VyY2Uub25BZGQpIHtcclxuICAgICAgICAgICAgc291cmNlLm9uQWRkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc291cmNlLmVuYWJsZWQpIHNvdXJjZS5maXJlKCdzb3VyY2UuYWRkJywge3NvdXJjZTogc291cmNlfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2lkXTtcclxuICAgICAgICBpZiAoc291cmNlLm9uUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5vblJlbW92ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tpZF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyZSgnc291cmNlLnJlbW92ZScsIHtzb3VyY2U6IHNvdXJjZX0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDb250cm9sOiBmdW5jdGlvbihjb250cm9sKSB7XHJcbiAgICAgICAgY29udHJvbC5hZGRUbyh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2V0IHRoZSBtYXAncyBjZW50ZXIsIHpvb20sIGFuZCBiZWFyaW5nXHJcbiAgICBzZXRWaWV3OiBmdW5jdGlvbihjZW50ZXIsIHpvb20sIGJlYXJpbmcpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHIuem9vbSAhPT0gK3pvb20sXHJcbiAgICAgICAgICAgIGJlYXJpbmdDaGFuZ2VkID0gdHIuYmVhcmluZyAhPT0gK2JlYXJpbmc7XHJcblxyXG4gICAgICAgIHRyLmNlbnRlciA9IExhdExuZy5jb252ZXJ0KGNlbnRlcik7XHJcbiAgICAgICAgdHIuem9vbSA9ICt6b29tO1xyXG4gICAgICAgIHRyLmJlYXJpbmcgPSArYmVhcmluZztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXHJcbiAgICAgICAgICAgIC5fbW92ZSh6b29tQ2hhbmdlZCwgYmVhcmluZ0NoYW5nZWQpXHJcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENlbnRlcjogZnVuY3Rpb24oY2VudGVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5nZXRab29tKCksIHRoaXMuZ2V0QmVhcmluZygpKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xyXG4gICAgICAgIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB0aGlzLmdldEJlYXJpbmcoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcpIHtcclxuICAgICAgICB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCksIGJlYXJpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uY2VudGVyOyB9LFxyXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS56b29tOyB9LFxyXG4gICAgZ2V0QmVhcmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5iZWFyaW5nOyB9LFxyXG5cclxuICAgIC8vIERldGVjdCB0aGUgbWFwJ3MgbmV3IHdpZHRoIGFuZCBoZWlnaHQgYW5kIHJlc2l6ZSBpdC5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gMCwgaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggfHwgNDAwO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMzAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fY29uc3RyYWluKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUuc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc3ByaXRlLnJlc2l6ZSh0aGlzLnBhaW50ZXIuZ2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXHJcbiAgICAgICAgICAgIC5fbW92ZSgpXHJcbiAgICAgICAgICAgIC5maXJlKCdyZXNpemUnKVxyXG4gICAgICAgICAgICAuZmlyZSgnbW92ZWVuZCcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCAwKSksXHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odGhpcy50cmFuc2Zvcm0uc2l6ZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludChMYXRMbmcuY29udmVydChsYXRsbmcpKTtcclxuICAgIH0sXHJcbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24oUG9pbnQuY29udmVydChwb2ludCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgIHZhciBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgdmFyIG1hcCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHBvaW50ID0gUG9pbnQuY29udmVydChwb2ludCk7XHJcblxyXG4gICAgICAgIHV0aWwuYXN5bmNFYWNoKE9iamVjdC5rZXlzKHRoaXMuc291cmNlcyksIGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gbWFwLnNvdXJjZXNbaWRdO1xyXG4gICAgICAgICAgICBzb3VyY2UuZmVhdHVyZXNBdChwb2ludCwgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBmZWF0dXJlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vblN0eWxlQ2hhbmdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHN0eWxlLCB0aGlzLmFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLnN0eWxlLnN0eWxlc2hlZXQuc291cmNlcztcclxuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkU291cmNlKGlkLCBTb3VyY2UuY3JlYXRlKHNvdXJjZXNbaWRdKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdseXBoU291cmNlID0gbmV3IEdseXBoU291cmNlKHRoaXMuc3R5bGUuc3R5bGVzaGVldC5nbHlwaHMsIHRoaXMucGFpbnRlci5nbHlwaEF0bGFzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdHlsZS5vbignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3RpbGVzRGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGVCdWNrZXRzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlR2x5cGhzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlyZSgnc3R5bGUuY2hhbmdlJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfbW92ZTogZnVuY3Rpb24gKHpvb20sIHJvdGF0ZSkge1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZSh6b29tKS5maXJlKCdtb3ZlJyk7XHJcblxyXG4gICAgICAgIGlmICh6b29tKSB0aGlzLmZpcmUoJ3pvb20nKTtcclxuICAgICAgICBpZiAocm90YXRlKSB0aGlzLmZpcmUoJ3JvdGF0ZScpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gbWFwIHNldHVwIGNvZGVcclxuXHJcbiAgICBfc2V0dXBDb250YWluZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyID0gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1tYXAnKTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcywgY29udGFpbmVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3NldHVwUGFpbnRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jYW52YXMuZ2V0V2ViR0xDb250ZXh0KCk7XHJcblxyXG4gICAgICAgIGlmICghZ2wpIHtcclxuICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGFpbnRlciA9IG5ldyBHTFBhaW50ZXIoZ2wsIHRoaXMudHJhbnNmb3JtKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NvbnRleHRMb3N0OiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQpIHtcclxuICAgICAgICAgICAgYnJvd3Nlci5jYW5jZWxGcmFtZSh0aGlzLl9mcmFtZUlkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2FsbGJhY2tzIGZyb20gd2ViIHdvcmtlcnNcclxuXHJcbiAgICAnZGVidWcgbWVzc2FnZSc6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBkYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ2FsZXJ0IG1lc3NhZ2UnOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgYWxlcnQuYXBwbHkod2luZG93LCBkYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ2dldCBzcHJpdGUganNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zdHlsZS5zcHJpdGU7XHJcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgJ2dldCBnbHlwaHMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZS5nZXRSZWN0cyhwYXJhbXMuZm9udHN0YWNrLCBwYXJhbXMuY29kZXBvaW50cywgcGFyYW1zLmlkLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbmRlcmluZ1xyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24odXBkYXRlU3R5bGUpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRoaXMuX3N0eWxlRGlydHkgfHwgdXBkYXRlU3R5bGU7XHJcbiAgICAgICAgdGhpcy5fdGlsZXNEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDYWxsIHdoZW4gYSAocmUtKXJlbmRlciBvZiB0aGUgbWFwIGlzIHJlcXVpcmVkLCBlLmcuIHdoZW4gdGhlIHVzZXIgcGFubmVkIG9yIHpvb21lZCxmIG9yIG5ldyBkYXRhIGlzIGF2YWlsYWJsZS5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbGVzRGlydHkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZXNbaWRdLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3JlbmRlckdyb3Vwcyh0aGlzLnN0eWxlLmxheWVyR3JvdXBzKTtcclxuICAgICAgICB0aGlzLmZpcmUoJ3JlbmRlcicpO1xyXG5cclxuICAgICAgICB0aGlzLl9mcmFtZUlkID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcHBlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcGFpbnQgfHwgIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVuZGVyR3JvdXBzOiBmdW5jdGlvbihncm91cHMpIHtcclxuICAgICAgICB0aGlzLnBhaW50ZXIucHJlcGFyZUJ1ZmZlcnMoKTtcclxuXHJcbiAgICAgICAgdmFyIGksIGxlbiwgZ3JvdXAsIHNvdXJjZTtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBncm91cHNcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlc1tncm91cC5zb3VyY2VdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyU3RlbmNpbCgpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnJlbmRlcihncm91cCk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuZHJhdyh1bmRlZmluZWQsIHRoaXMuc3R5bGUsIGdyb3VwLCB7IGJhY2tncm91bmQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9yZXJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcmFtZUlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBicm93c2VyLmZyYW1lKHRoaXMucmVuZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9vblN0eWxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF91cGRhdGVTdHlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zdHlsZS5yZWNhbGN1bGF0ZSh0aGlzLnRyYW5zZm9ybS56b29tKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3VwZGF0ZUdseXBoczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdCgnc2V0IGdseXBocycsIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5nbHlwaHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfdXBkYXRlQnVja2V0czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gVHJhbnNmZXIgYSBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIHN0eWxlIHRvIHRoZSB3b3JrZXJzLiBUaGV5IG9ubHlcclxuICAgICAgICAvLyBuZWVkIHRoZSBidWNrZXQgaW5mb3JtYXRpb24gdG8ga25vdyB3aGF0IGZlYXR1cmVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgdGlsZS5cclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KCdzZXQgYnVja2V0cycsIHRoaXMuc3R5bGUub3JkZXJlZEJ1Y2tldHMpO1xyXG5cclxuICAgICAgICAvLyBjbGVhcnMgYWxsIHRpbGVzIHRvIHJlY2FsY3VsYXRlIGdlb21ldHJpZXMgKGZvciBjaGFuZ2VzIHRvIGxpbmVjYXBzLCBsaW5lam9pbnMsIC4uLilcclxuICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuc291cmNlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNbc10ubG9hZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG51dGlsLmV4dGVuZEFsbChNYXAucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gZGVidWcgY29kZVxyXG4gICAgX2RlYnVnOiBmYWxzZSxcclxuICAgIGdldCBkZWJ1ZygpIHsgcmV0dXJuIHRoaXMuX2RlYnVnOyB9LFxyXG4gICAgc2V0IGRlYnVnKHZhbHVlKSB7IHRoaXMuX2RlYnVnID0gdmFsdWU7IHRoaXMuX3JlcmVuZGVyKCk7IH0sXHJcblxyXG4gICAgLy8gY29udGludW91cyByZXBhaW50XHJcbiAgICBfcmVwYWludDogZmFsc2UsXHJcbiAgICBnZXQgcmVwYWludCgpIHsgcmV0dXJuIHRoaXMuX3JlcGFpbnQ7IH0sXHJcbiAgICBzZXQgcmVwYWludCh2YWx1ZSkgeyB0aGlzLl9yZXBhaW50ID0gdmFsdWU7IHRoaXMuX3JlcmVuZGVyKCk7IH0sXHJcblxyXG4gICAgLy8gcG9seWdvbiBhbnRpYWxpYXNpbmdcclxuICAgIF9hbnRpYWxpYXNpbmc6IHRydWUsXHJcbiAgICBnZXQgYW50aWFsaWFzaW5nKCkgeyByZXR1cm4gdGhpcy5fYW50aWFsaWFzaW5nOyB9LFxyXG4gICAgc2V0IGFudGlhbGlhc2luZyh2YWx1ZSkgeyB0aGlzLl9hbnRpYWxpYXNpbmcgPSB2YWx1ZTsgdGhpcy5fcmVyZW5kZXIoKTsgfSxcclxuXHJcbiAgICAvLyBzaG93IHZlcnRpY2VzXHJcbiAgICBfdmVydGljZXM6IGZhbHNlLFxyXG4gICAgZ2V0IHZlcnRpY2VzKCkgeyByZXR1cm4gdGhpcy5fdmVydGljZXM7IH0sXHJcbiAgICBzZXQgdmVydGljZXModmFsdWUpIHsgdGhpcy5fdmVydGljZXMgPSB2YWx1ZTsgdGhpcy5fcmVyZW5kZXIoKTsgfSxcclxuXHJcbiAgICAvLyBzaG93IHZlcnRpY2VzXHJcbiAgICBfbG9hZE5ld1RpbGVzOiB0cnVlLFxyXG4gICAgZ2V0IGxvYWROZXdUaWxlcygpIHsgcmV0dXJuIHRoaXMuX2xvYWROZXdUaWxlczsgfSxcclxuICAgIHNldCBsb2FkTmV3VGlsZXModmFsdWUpIHsgdGhpcy5fbG9hZE5ld1RpbGVzID0gdmFsdWU7IHRoaXMudXBkYXRlKCk7IH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWN0b3I7XHJcblxyXG5mdW5jdGlvbiBBY3Rvcih0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XHJcbiAgICB0aGlzLmNhbGxiYWNrSUQgPSAwO1xyXG4gICAgdGhpcy5yZWNlaXZlID0gdGhpcy5yZWNlaXZlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWNlaXZlLCBmYWxzZSk7XHJcbn1cclxuXHJcbkFjdG9yLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGEsXHJcbiAgICAgICAgY2FsbGJhY2s7XHJcblxyXG4gICAgaWYgKGRhdGEudHlwZSA9PSAnPHJlc3BvbnNlPicpIHtcclxuICAgICAgICBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2RhdGEuaWRdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcclxuICAgICAgICBjYWxsYmFjayhkYXRhLmVycm9yIHx8IG51bGwsIGRhdGEuZGF0YSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmlkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRbZGF0YS50eXBlXShkYXRhLmRhdGEsIGZ1bmN0aW9uIHJlc3BvbnNlKGVyciwgZGF0YSwgYnVmZmVycykge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3RyeWluZyB0byBjbG9uZScsIGRhdGEsIGJ1ZmZlcnMsIG1lc3NhZ2UudGFyZ2V0KTtcclxuICAgICAgICAgICAgbWVzc2FnZS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJzxyZXNwb25zZT4nLFxyXG4gICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID8gU3RyaW5nKGVycikgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgICB9LCBidWZmZXJzKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRbZGF0YS50eXBlXShkYXRhLmRhdGEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWN0b3IucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycykge1xyXG4gICAgdmFyIGlkID0gbnVsbDtcclxuICAgIGlmIChjYWxsYmFjaykgdGhpcy5jYWxsYmFja3NbaWQgPSB0aGlzLmNhbGxiYWNrSUQrK10gPSBjYWxsYmFjaztcclxuICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKHsgdHlwZTogdHlwZSwgaWQ6IFN0cmluZyhpZCksIGRhdGE6IGRhdGEgfSwgYnVmZmVycyk7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xyXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICB9O1xyXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICAgICAgdHJ5IHsgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTsgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gICAgcmV0dXJuIHhocjtcclxufTtcclxuXHJcbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcclxuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICB9O1xyXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB4aHIucmVzcG9uc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gICAgcmV0dXJuIHhocjtcclxufTtcclxuXHJcbmV4cG9ydHMuZ2V0SW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcclxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjYWxsYmFjayhudWxsLCBpbWcpO1xyXG4gICAgfTtcclxuICAgIGltZy5zcmMgPSB1cmw7XHJcbiAgICBpbWcuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SW1hZ2VEYXRhKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIGltZztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldEltYWdlRGF0YShpbWcpIHtcclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XHJcbiAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBmcmFtZU5hbWUgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnO1xyXG4gICAgaWYgKHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiAnbW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcclxuICAgIGlmICh3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gJ3dlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSc7XHJcbiAgICBpZiAod2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gJ21zUmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcclxufSkoKTtcclxuXHJcbmV4cG9ydHMuZnJhbWUgPSBmdW5jdGlvbihmbikge1xyXG4gICAgcmV0dXJuIHdpbmRvd1tmcmFtZU5hbWVdKGZuKTtcclxufTtcclxuXHJcbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgKHdpbmRvdy5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSkoaWQpO1xyXG59O1xyXG5cclxuZXhwb3J0cy50aW1lZCA9IGZ1bmN0aW9uIChmbiwgZHVyLCBjdHgpIHtcclxuICAgIGlmICghZHVyKSB7XHJcbiAgICAgICAgZm4uY2FsbChjdHgsIDEpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWJvcnQgPSBmYWxzZSxcclxuICAgICAgICBzdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XHJcblxyXG4gICAgZnVuY3Rpb24gdGljayhub3cpIHtcclxuICAgICAgICBpZiAoYWJvcnQpIHJldHVybjtcclxuICAgICAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSkgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgaWYgKG5vdyA+PSBzdGFydCArIGR1cikge1xyXG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm4uY2FsbChjdHgsIChub3cgLSBzdGFydCkgLyBkdXIpO1xyXG4gICAgICAgICAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgYWJvcnQgPSB0cnVlOyB9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdXBwb3J0cyA9IFtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJzsgfSxcclxuXHJcbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnOyB9LFxyXG5cclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIShBcnJheS5wcm90b3R5cGUgJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5ldmVyeSAmJlxyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciAmJlxyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmXHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zb21lICYmXHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlICYmXHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISEoRnVuY3Rpb24ucHJvdG90eXBlICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSxcclxuICAgICAgICAgICAgICAgICEhKE9iamVjdC5rZXlzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRnJvemVuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiZcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZWFsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGlmICgnc3VwcG9ydHNDb250ZXh0JyBpbiBjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMuc3VwcG9ydHNDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiZcclxuICAgICAgICAgICAgICAgICghIWNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8ICEhY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdXb3JrZXInIGluIHdpbmRvdzsgfVxyXG4gICAgXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFzdXBwb3J0c1tpXSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RldmljZVBpeGVsUmF0aW8nLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xyXG5cclxuZnVuY3Rpb24gQ2FudmFzKHBhcmVudCwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY2FudmFzJyk7XHJcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgcGFyZW50Ll9jb250ZXh0TG9zdC5iaW5kKHBhcmVudCksIGZhbHNlKTtcclxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgcGFyZW50Ll9jb250ZXh0UmVzdG9yZWQuYmluZChwYXJlbnQpLCBmYWxzZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xyXG59XHJcblxyXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuXHJcbiAgICAvLyBSZXF1ZXN0IHRoZSByZXF1aXJlZCBjYW52YXMgc2l6ZSB0YWtpbmcgdGhlIHBpeGVscmF0aW8gaW50byBhY2NvdW50LlxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd2lkdGg7XHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaGVpZ2h0O1xyXG5cclxuICAgIC8vIE1haW50YWluIHRoZSBzYW1lIGNhbnZhcyBzaXplLCBwb3RlbnRpYWxseSBkb3duc2NhbGluZyBpdCBmb3IgSGlEUEkgZGlzcGxheXNcclxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxufTtcclxuXHJcbkNhbnZhcy5wcm90b3R5cGUuZ2V0V2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCB7XHJcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgIGRlcHRoOiBmYWxzZVxyXG4gICAgfSk7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yLmpzJyk7XHJcblxyXG52YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xyXG52YXIgd29ya2VyRmlsZSA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xyXG52YXIgYWJzb2x1dGUgPSB3b3JrZXJGaWxlLmluZGV4T2YoJ2h0dHAnKSAhPT0gLTE7XHJcblxyXG5cclxuLy8gTWFuYWdlcyB0aGUgV2ViV29ya2Vyc1xyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XHJcbmZ1bmN0aW9uIERpc3BhdGNoZXIobGVuZ3RoLCBwYXJlbnQpIHtcclxuICAgIHRoaXMuYWN0b3JzID0gW107XHJcbiAgICB0aGlzLmN1cnJlbnRBY3RvciA9IDA7XHJcblxyXG4gICAgdmFyIHVybCwgYmxvYiwgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3MgZG9tYWluIGlzc3VlcyB3ZSBjYW4ndCBsb2FkIGl0IGRpcmVjdGx5IHdpdGggdGhlIHVybCxcclxuICAgICAgICAvLyBzbyBjcmVhdGUgYSBibG9iIGFuZCBvYmplY3QgdXJsIGFuZCBsb2FkIHRoYXRcclxuICAgICAgICBpZiAoYWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFsnaW1wb3J0U2NyaXB0cyhcIicgKyB3b3JrZXJGaWxlICsgJ1wiKTsnXSwge3R5cGUgOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9KTtcclxuICAgICAgICAgICAgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXJsID0gd29ya2VyRmlsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XHJcbiAgICAgICAgdmFyIGFjdG9yID0gbmV3IEFjdG9yKHdvcmtlciwgcGFyZW50KTtcclxuICAgICAgICBhY3Rvci5uYW1lID0gXCJXb3JrZXIgXCIgKyBpO1xyXG4gICAgICAgIHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5EaXNwYXRjaGVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5hY3RvcnNbaV0uc2VuZCh0eXBlLCBkYXRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRpc3BhdGNoZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgdGFyZ2V0SUQsIGJ1ZmZlcnMpIHtcclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0SUQgIT09ICdudW1iZXInIHx8IGlzTmFOKHRhcmdldElEKSkge1xyXG4gICAgICAgIC8vIFVzZSByb3VuZCByb2JpbiB0byBzZW5kIHJlcXVlc3RzIHRvIHdlYiB3b3JrZXJzLlxyXG4gICAgICAgIHRhcmdldElEID0gdGhpcy5jdXJyZW50QWN0b3IgPSAodGhpcy5jdXJyZW50QWN0b3IgKyAxKSAlIHRoaXMuYWN0b3JzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFjdG9yc1t0YXJnZXRJRF0uc2VuZCh0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycyk7XHJcbiAgICByZXR1cm4gdGFyZ2V0SUQ7XHJcbn07XHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEhUVFBfVVJMOiAnaHR0cDovL2EudGlsZXMubWFwYm94LmNvbS92NCcsXHJcbiAgICBIVFRQU19VUkw6ICdodHRwczovL2EudGlsZXMubWFwYm94LmNvbS92NCcsXHJcbiAgICBGT1JDRV9IVFRQUzogZmFsc2UsXHJcbiAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogdHJ1ZVxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgIGlmIChjbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbn1cclxuXHJcbnZhciBkb2NFbCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiB7fSxcclxuICAgIHNlbGVjdFByb3AgPVxyXG4gICAgICAgICd1c2VyU2VsZWN0JyBpbiBkb2NFbCA/ICd1c2VyU2VsZWN0JyA6XHJcbiAgICAgICAgJ01velVzZXJTZWxlY3QnIGluIGRvY0VsID8gJ01velVzZXJTZWxlY3QnIDpcclxuICAgICAgICAnV2Via2l0VXNlclNlbGVjdCcgaW4gZG9jRWwgPyAnV2Via2l0VXNlclNlbGVjdCcgOiBudWxsLFxyXG4gICAgdXNlclNlbGVjdDtcclxuXHJcbmV4cG9ydHMuZGlzYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG5cclxuICAgIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICAgIGVsc2UgaWYgKHNlbGVjdFByb3ApIHtcclxuICAgICAgICB1c2VyU2VsZWN0ID0gZG9jRWwuc3R5bGVbc2VsZWN0UHJvcF07XHJcbiAgICAgICAgZG9jRWwuc3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuZW5hYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcblxyXG4gICAgaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgZWxzZSBpZiAoc2VsZWN0UHJvcCkgZG9jRWwuc3R5bGVbc2VsZWN0UHJvcF0gPSB1c2VyU2VsZWN0O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBvbjogZnVuY3Rpb24odHlwZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGZuKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG9mZjogZnVuY3Rpb24odHlwZSwgZm4pIHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaXJlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICBkYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGEpO1xyXG4gICAgICAgIHV0aWwuZXh0ZW5kKGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaXN0ZW5zOiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pO1xyXG4gICAgfVxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBocztcclxuZnVuY3Rpb24gR2x5cGhzKGJ1ZmZlciwgZW5kKSB7XHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHRoaXMuc3RhY2tzID0ge307XHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XHJcblxyXG4gICAgdmFyIHZhbCwgdGFnO1xyXG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xyXG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xyXG4gICAgICAgIGlmICh0YWcgPT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgZm9udHN0YWNrID0gdGhpcy5yZWFkRm9udHN0YWNrKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzW2ZvbnRzdGFjay5uYW1lXSA9IGZvbnRzdGFjaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3NraXBwaW5nIHRpbGUgdGFnICcgKyB0YWcpO1xyXG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuR2x5cGhzLnByb3RvdHlwZS5yZWFkRm9udHN0YWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xyXG4gICAgdmFyIGZvbnRzdGFjayA9IHsgZ2x5cGhzOiB7fSB9O1xyXG5cclxuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XHJcbiAgICB2YXIgdmFsLCB0YWc7XHJcbiAgICB2YXIgZW5kID0gYnVmZmVyLnBvcyArIGJ5dGVzO1xyXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xyXG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xyXG5cclxuICAgICAgICBpZiAodGFnID09IDEpIHtcclxuICAgICAgICAgICAgZm9udHN0YWNrLm5hbWUgPSBidWZmZXIucmVhZFN0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDIpIHtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgZm9udHN0YWNrLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMykge1xyXG4gICAgICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLnJlYWRHbHlwaCgpO1xyXG4gICAgICAgICAgICBmb250c3RhY2suZ2x5cGhzW2dseXBoLmlkXSA9IGdseXBoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb250c3RhY2s7XHJcbn07XHJcblxyXG5HbHlwaHMucHJvdG90eXBlLnJlYWRHbHlwaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcclxuICAgIHZhciBnbHlwaCA9IHt9O1xyXG5cclxuICAgIHZhciBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XHJcbiAgICB2YXIgdmFsLCB0YWc7XHJcbiAgICB2YXIgZW5kID0gYnVmZmVyLnBvcyArIGJ5dGVzO1xyXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xyXG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xyXG5cclxuICAgICAgICBpZiAodGFnID09IDEpIHtcclxuICAgICAgICAgICAgZ2x5cGguaWQgPSBidWZmZXIucmVhZFZhcmludCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDIpIHtcclxuICAgICAgICAgICAgZ2x5cGguYml0bWFwID0gYnVmZmVyLnJlYWRCdWZmZXIoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSAzKSB7XHJcbiAgICAgICAgICAgIGdseXBoLndpZHRoID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA0KSB7XHJcbiAgICAgICAgICAgIGdseXBoLmhlaWdodCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNSkge1xyXG4gICAgICAgICAgICBnbHlwaC5sZWZ0ID0gYnVmZmVyLnJlYWRTVmFyaW50KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNikge1xyXG4gICAgICAgICAgICBnbHlwaC50b3AgPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA3KSB7XHJcbiAgICAgICAgICAgIGdseXBoLmFkdmFuY2UgPSBidWZmZXIucmVhZFZhcmludCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnbHlwaDtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsLCBhY2Nlc3NUb2tlbikge1xyXG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBjb25maWcuQUNDRVNTX1RPS0VOO1xyXG5cclxuICAgIGlmICghYWNjZXNzVG9rZW4gJiYgY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggR0wuICcgK1xyXG4gICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaHR0cHMgPSBjb25maWcuRk9SQ0VfSFRUUFMgfHxcclxuICAgICAgICAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaHR0cHM6JyA9PT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wpO1xyXG5cclxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9ebWFwYm94OlxcL1xcLy8sIChodHRwcyA/IGNvbmZpZy5IVFRQU19VUkwgOiBjb25maWcuSFRUUF9VUkwpICsgJy8nKTtcclxuICAgIHVybCArPSB1cmwuaW5kZXhPZignPycpICE9PSAtMSA/ICcmYWNjZXNzX3Rva2VuPScgOiAnP2FjY2Vzc190b2tlbj0nO1xyXG5cclxuICAgIGlmIChjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcclxuICAgICAgICBpZiAoYWNjZXNzVG9rZW5bMF0gPT09ICdzJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIHB1YmxpYyBhY2Nlc3MgdG9rZW4gKHBrLiopIHdpdGggTWFwYm94IEdMIEpTLCBub3QgYSBzZWNyZXQgYWNjZXNzIHRva2VuIChzay4qKS4gJyArXHJcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVybCArPSBhY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTb3VyY2VVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XHJcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8vKSlcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG5cclxuICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwgKyAnLmpzb24nLCBhY2Nlc3NUb2tlbik7XHJcblxyXG4gICAgLy8gVGlsZUpTT04gcmVxdWVzdHMgbmVlZCBhIHNlY3VyZSBmbGFnIGFwcGVuZGVkIHRvIHRoZWlyIFVSTHMgc29cclxuICAgIC8vIHRoYXQgdGhlIHNlcnZlciBrbm93cyB0byBzZW5kIFNTTC1pZmllZCByZXNvdXJjZSByZWZlcmVuY2VzLlxyXG4gICAgaWYgKHVybC5pbmRleE9mKCdodHRwcycpID09PSAwKVxyXG4gICAgICAgIHVybCArPSAnJnNlY3VyZSc7XHJcblxyXG4gICAgcmV0dXJuIHVybDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcclxuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCh1cmwsIGFjY2Vzc1Rva2VuKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogQSBbbW9zdC1yZWNlbnRseS11c2VkIGNhY2hlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMpXHJcbiAqIHdpdGggaGFzaCBsb29rdXAgbWFkZSBwb3NzaWJsZSBieSBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIGluIHBhcmFsbGVsIHRvXHJcbiAqIGFuIGFycmF5IG9mIGRpY3Rpb25hcnkgb2YgdmFsdWVzXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1SVUNhY2hlO1xyXG5mdW5jdGlvbiBNUlVDYWNoZShsZW5ndGgsIG9uUmVtb3ZlKSB7XHJcbiAgICB0aGlzLm1heCA9IGxlbmd0aDtcclxuICAgIHRoaXMub25SZW1vdmUgPSBvblJlbW92ZTtcclxuICAgIHRoaXMucmVzZXQoKTtcclxufVxyXG5cclxuLypcclxuICogQ2xlYXJzIHRoZSBjYWNoZVxyXG4gKi9cclxuTVJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmxpc3QgPSB7fTtcclxuICAgIHRoaXMub3JkZXIgPSBbXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qXHJcbiAqIEFkZCBhIGtleSwgdmFsdWUgY29tYmluYXRpb24gdG8gdGhlIGNhY2hlLCB0cmltbWluZyBpdHMgc2l6ZSBpZiB0aGlzIHB1c2hlc1xyXG4gKiBpdCBvdmVyIG1heCBsZW5ndGguXHJcbiAqL1xyXG5NUlVDYWNoZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCBkYXRhKSB7XHJcbiAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XHJcbiAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcclxuXHJcbiAgICBpZiAodGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xyXG4gICAgICAgIGlmIChyZW1vdmVkRGF0YSkgdGhpcy5vblJlbW92ZShyZW1vdmVkRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYGtleWAgaXMgcHJlc2VudFxyXG4gKi9cclxuTVJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLmxpc3Q7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBMaXN0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxyXG4gKi9cclxuTVJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm9yZGVyO1xyXG59O1xyXG5cclxuLypcclxuICogR2V0IHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBhIHNwZWNpZmljIGtleS4gSWYgdGhlIGtleSBpcyBub3QgZm91bmQsXHJcbiAqIHJldHVybnMgYG51bGxgXHJcbiAqL1xyXG5NUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMubGlzdFtrZXldO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuICAgIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZihrZXkpLCAxKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVG9rZW5zO1xyXG5cclxudmFyIHRva2VuUGF0dGVybiA9IC97KFtcXHctXSspfS87XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlVG9rZW5zKHByb3BlcnRpZXMsIGV4cHJlc3Npb24pIHtcclxuICAgIHZhciBtYXRjaDtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciB0ZXh0ID0gZXhwcmVzc2lvbjtcclxuICAgIHdoaWxlICgobWF0Y2ggPSB0ZXh0Lm1hdGNoKHRva2VuUGF0dGVybikpKSB7XHJcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgcHJvcGVydGllc1ttYXRjaFsxXV0gPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9wZXJ0aWVzW21hdGNoWzFdXTtcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKG1hdGNoWzBdLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVW5pdEJlemllciA9IHJlcXVpcmUoJ3VuaXRiZXppZXInKTtcclxuXHJcbmV4cG9ydHMuZWFzZUN1YmljSW5PdXQgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XHJcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcclxuICAgIHZhciB0MiA9IHQgKiB0LFxyXG4gICAgICAgIHQzID0gdDIgKiB0O1xyXG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcclxufTtcclxuXHJcbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XHJcbiAgICB2YXIgYmV6aWVyID0gbmV3IFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KTtcclxuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmVhc2UgPSBleHBvcnRzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xyXG5cclxuZXhwb3J0cy5pbnRlcnAgPSBmdW5jdGlvbiAoYSwgYiwgdCkge1xyXG4gICAgcmV0dXJuIChhICogKDEgLSB0KSkgKyAoYiAqIHQpO1xyXG59O1xyXG5cclxuZXhwb3J0cy5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICBjWzBdICo9IGNbM107XHJcbiAgICBjWzFdICo9IGNbM107XHJcbiAgICBjWzJdICo9IGNbM107XHJcbiAgICByZXR1cm4gYztcclxufTtcclxuXHJcbmV4cG9ydHMuYXN5bmNFYWNoID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcclxuICAgIHZhciByZW1haW5pbmcgPSBhcnJheS5sZW5ndGg7XHJcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgIGZ1bmN0aW9uIGNoZWNrKCkgeyBpZiAoLS1yZW1haW5pbmcgPT09IDApIGNhbGxiYWNrKCk7IH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGZuKGFycmF5W2ldLCBjaGVjayk7XHJcbn07XHJcblxyXG5leHBvcnRzLmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKG9iaiwgb3RoZXIpIHtcclxuICAgIHZhciBkaWZmZXJlbmNlID0gW107XHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmICghKGkgaW4gb3RoZXIpKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcclxufTtcclxuXHJcbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xyXG4gICAgZm9yICh2YXIgaSBpbiBzcmMpIHtcclxuICAgICAgICBkZXN0W2ldID0gc3JjW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn07XHJcblxyXG5leHBvcnRzLmV4dGVuZEFsbCA9IGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcclxuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufTtcclxuXHJcbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHByb3BzKSB7XHJcbiAgICB2YXIgcGFyZW50UHJvdG8gPSB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nID8gcGFyZW50LnByb3RvdHlwZSA6IHBhcmVudCxcclxuICAgICAgICBwcm90byA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdG8pO1xyXG4gICAgZXhwb3J0cy5leHRlbmRBbGwocHJvdG8sIHByb3BzKTtcclxuICAgIHJldHVybiBwcm90bztcclxufTtcclxuXHJcbnZhciBpZCA9IDE7XHJcblxyXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGlkKys7XHJcbn07XHJcblxyXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcbiAgICBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG4gICAgICAgIGxvY2sgPSBmYWxzZTtcclxuICAgICAgICBpZiAoYXJncykge1xyXG4gICAgICAgICAgICB3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobG9jaykge1xyXG4gICAgICAgICAgICAvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuICAgICAgICAgICAgbG9jayA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gd3JhcHBlckZuO1xyXG59O1xyXG5cclxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZuLCB0aW1lKSB7XHJcbiAgICB2YXIgdGltZXIsIGFyZ3M7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHJcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9LCB0aW1lKTtcclxuICAgIH07XHJcbn07XHJcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtel0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsInZhciBnZW9qc29uQXJlYSA9IHJlcXVpcmUoJ2dlb2pzb24tYXJlYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJld2luZDtcblxuZnVuY3Rpb24gcmV3aW5kKGdqLCBvdXRlcikge1xuICAgIHN3aXRjaCAoKGdqICYmIGdqLnR5cGUpIHx8IG51bGwpIHtcbiAgICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZ2ouZmVhdHVyZXMgPSBnai5mZWF0dXJlcy5tYXAoY3VycnlPdXRlcihyZXdpbmQsIG91dGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgICAgZ2ouZ2VvbWV0cnkgPSByZXdpbmQoZ2ouZ2VvbWV0cnksIG91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdChnaiwgb3V0ZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VycnlPdXRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIGEoXywgYik7IH07XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3QoXywgb3V0ZXIpIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IGNvcnJlY3RSaW5ncyhfLmNvb3JkaW5hdGVzLCBvdXRlcik7XG4gICAgfSBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBfLmNvb3JkaW5hdGVzLm1hcChjdXJyeU91dGVyKGNvcnJlY3RSaW5ncywgb3V0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RSaW5ncyhfLCBvdXRlcikge1xuICAgIG91dGVyID0gISFvdXRlcjtcbiAgICBfWzBdID0gd2luZChfWzBdLCAhb3V0ZXIpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgXy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfW2ldID0gd2luZChfW2ldLCBvdXRlcik7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiB3aW5kKF8sIGRpcikge1xuICAgIHJldHVybiBjdyhfKSA9PT0gZGlyID8gXyA6IF8ucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBjdyhfKSB7XG4gICAgcmV0dXJuIGdlb2pzb25BcmVhLnJpbmcoXykgPj0gMDtcbn1cbiIsInZhciB3Z3M4NCA9IHJlcXVpcmUoJ3dnczg0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5tb2R1bGUuZXhwb3J0cy5yaW5nID0gcmluZ0FyZWE7XG5cbmZ1bmN0aW9uIGdlb21ldHJ5KF8pIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHJldHVybiBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzKTtcbiAgICBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHZhciBhcmVhID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhICs9IHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmVhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9seWdvbkFyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBhcmVhIG9mIHRoZSBwb2x5Z29uIHdlcmUgaXQgcHJvamVjdGVkIG9udG9cbiAqICAgICB0aGUgZWFydGguICBOb3RlIHRoYXQgdGhpcyBhcmVhIHdpbGwgYmUgcG9zaXRpdmUgaWYgcmluZyBpcyBvcmllbnRlZFxuICogICAgIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiAgICAgUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogICAgIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3IGh0dHA6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9kc3BhY2UvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBSZXR1cm5zOlxuICoge2Zsb2F0fSBUaGUgYXBwcm94aW1hdGUgc2lnbmVkIGdlb2Rlc2ljIGFyZWEgb2YgdGhlIHBvbHlnb24gaW4gc3F1YXJlXG4gKiAgICAgbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcblxuICAgIGlmIChjb29yZHMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgcDEsIHAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHAxID0gY29vcmRzW2ldO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbaSArIDFdO1xuICAgICAgICAgICAgYXJlYSArPSByYWQocDJbMF0gLSBwMVswXSkgKiAoMiArIE1hdGguc2luKHJhZChwMVsxXSkpICsgTWF0aC5zaW4ocmFkKHAyWzFdKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYSA9IGFyZWEgKiB3Z3M4NC5SQURJVVMgKiB3Z3M4NC5SQURJVVMgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiByYWQoXykge1xuICAgIHJldHVybiBfICogTWF0aC5QSSAvIDE4MDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiJHZlcnNpb25cIjogNSxcclxuICBcIiRyb290XCI6IHtcclxuICAgIFwidmVyc2lvblwiOiB7XHJcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgNVxyXG4gICAgICBdLFxyXG4gICAgICBcImRvY1wiOiBcIlN0eWxlc2hlZXQgdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgNS5cIlxyXG4gICAgfSxcclxuICAgIFwiY29uc3RhbnRzXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiY29uc3RhbnRzXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiQW4gb2JqZWN0IG9mIGNvbnN0YW50cyB0byBiZSByZWZlcmVuY2VkIGluIGxheWVycy5cIlxyXG4gICAgfSxcclxuICAgIFwic291cmNlc1wiOiB7XHJcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcclxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxyXG4gICAgICBcImRvY1wiOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zIGZvciBsYXllcnMgdG8gcHVsbCBmcm9tLlwiXHJcbiAgICB9LFxyXG4gICAgXCJsYXllcnNcIjoge1xyXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXHJcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxyXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIGxheWVycy4gVGhlIG9yZGVyIG9mIGxheWVycyBjb2luY2lkZXMgd2l0aCB0aGUgb3JkZXIgdGhleSB3aWxsIGJlIGRyYXduLlwiXHJcbiAgICB9LFxyXG4gICAgXCJzcHJpdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJzcHJpdGVcIixcclxuICAgICAgXCJkb2NcIjogXCJTcHJpdGUgZGVmaW5pdGlvbi5cIlxyXG4gICAgfSxcclxuICAgIFwiZ2x5cGhzXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVmFsaWQgdG9rZW5zIGFyZSB7Zm9udHN0YWNrfSBhbmQge3JhbmdlfS5cIlxyXG4gICAgfSxcclxuICAgIFwidHJhbnNpdGlvblwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInRyYW5zaXRpb25cIixcclxuICAgICAgXCJkb2NcIjogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcy5cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJzcHJpdGVcIjogW3tcclxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLlwiXHJcbiAgfV0sXHJcbiAgXCJjb25zdGFudHNcIjoge1xyXG4gICAgXCIqXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxyXG4gICAgICBcImRvY1wiOiBcIkEgY29uc3RhbnQgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIHZlcmJhdGltIGluIHRoZSByZWZlcmVuY2luZyBwbGFjZS4gVGhpcyBjYW4gYmUgYW55dGhpbmcsIGluY2x1ZGluZyBvYmplY3RzIGFuZCBhcnJheXMuIEFsbCB2YXJpYWJsZSBuYW1lcyBtdXN0IGJlIHByZWZpeGVkIHdpdGggYW4gYEBgIHN5bWJvbC5cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJzb3VyY2VzXCI6IHtcclxuICAgIFwiKlwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInNvdXJjZVwiLFxyXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwiXHJcbiAgICB9XHJcbiAgfSxcclxuICBcInNvdXJjZVwiOiB7XHJcbiAgICBcInR5cGVcIjoge1xyXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXHJcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcclxuICAgICAgXCJ2YWx1ZXNcIjogW1xyXG4gICAgICAgIFwidmVjdG9yXCIsXHJcbiAgICAgICAgXCJyYXN0ZXJcIixcclxuICAgICAgICBcImdlb2pzb25cIixcclxuICAgICAgICBcInZpZGVvXCJcclxuICAgICAgXSxcclxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcclxuICAgIH0sXHJcbiAgICBcInVybFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxtYXBpZD5gLlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0aWxlc1wiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXHJcbiAgICB9LFxyXG4gICAgXCJtaW56b29tXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcclxuICAgIH0sXHJcbiAgICBcIm1heHpvb21cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDIyLFxyXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcclxuICAgIH0sXHJcbiAgICBcInRpbGVTaXplXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiA1MTIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gdmlzdWFsIHNpemUgKGluIHB4KSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxyXG4gICAgfSxcclxuICAgIFwiKlwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIipcIixcclxuICAgICAgXCJkb2NcIjogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcclxuICAgIH1cclxuICB9LFxyXG4gIFwibGF5ZXJcIjoge1xyXG4gICAgXCJpZFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRvY1wiOiBcIlVuaXF1ZSBsYXllciBuYW1lLlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0eXBlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJmaWxsXCIsXHJcbiAgICAgICAgXCJsaW5lXCIsXHJcbiAgICAgICAgXCJzeW1ib2xcIixcclxuICAgICAgICBcInJhc3RlclwiLFxyXG4gICAgICAgIFwiYmFja2dyb3VuZFwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxyXG4gICAgfSxcclxuICAgIFwicmVmXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiUmVmZXJlbmNlcyBhbm90aGVyIGxheWVyIHRvIGNvcHkgYHNvdXJjZWAsIGBzb3VyY2VfbGF5ZXJgLCBgZmlsdGVyYCwgYW5kIGByZW5kZXJgIHByb3BlcnRpZXMgZnJvbS4gVGhpcyBhbGxvd3MgdGhlIGxheWVycyB0byBzaGFyZSBwcm9jZXNzaW5nIGFuZCBiZSBtb3JlIGVmZmljaWVudC5cIlxyXG4gICAgfSxcclxuICAgIFwic291cmNlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLlwiXHJcbiAgICB9LFxyXG4gICAgXCJzb3VyY2UtbGF5ZXJcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcclxuICAgIH0sXHJcbiAgICBcIm1pbi16b29tXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcclxuICAgIH0sXHJcbiAgICBcIm1heC16b29tXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcclxuICAgIH0sXHJcbiAgICBcImludGVyYWN0aXZlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICBcImRvY1wiOiBcIkVuYWJsZSBxdWVyeWluZyBvZiBmZWF0dXJlIGRhdGEgZnJvbSB0aGlzIGxheWVyIGZvciBpbnRlcmFjdGl2aXR5LlwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcclxuICAgIH0sXHJcbiAgICBcInJlbmRlclwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInJlbmRlclwiLFxyXG4gICAgICBcImRvY1wiOiBcIlN5bWJvbGl6ZXIgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHZpc3VhbGl6ZSB0aGlzIGxheWVyLiBJZiB1bnNwZWNpZmllZCBvciBudWxsLCB0aGlzIGxheWVyIGlzIG5vdCB0cmVhdGVkIGFzIGEgc3ltYm9saXplciBhbmQgb25seSBleGlzdHMgdG8gaGF2ZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCB0byBvdGhlciBsYXllcnMgdXNpbmcgcmVmLlwiXHJcbiAgICB9LFxyXG4gICAgXCJmaWx0ZXJcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcclxuICAgICAgXCJkb2NcIjogXCJBcnJheSBvciBvYmplY3Qgb2YgZmlsdGVycyBvciBleHByZXNzaW9ucy5cIlxyXG4gICAgfSxcclxuICAgIFwibGF5ZXJzXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgXCJ2YWx1ZVwiOiBcImxheWVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiSWYgYHR5cGVgIGlzIGByYXN0ZXJgLCB0aGUgY2hpbGQgbGF5ZXJzIGFyZSBjb21wb3NpdGVkIHRvZ2V0aGVyIG9udG8gdGhlIHByZXZpb3VzIGxldmVsIGxheWVyIGxldmVsLlwiXHJcbiAgICB9LFxyXG4gICAgXCJzdHlsZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImNsYXNzXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXHJcbiAgICB9LFxyXG4gICAgXCJzdHlsZS4qXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiY2xhc3NcIixcclxuICAgICAgXCJkb2NcIjogXCJPdmVycmlkZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLiBUaGUgY2xhc3MgbmFtZSBpcyB0aGUgcGFydCBhZnRlciB0aGUgZmlyc3QgZG90LlwiXHJcbiAgICB9XHJcbiAgfSxcclxuICBcInJlbmRlclwiOiBbXHJcbiAgICBcInJlbmRlcl9maWxsXCIsXHJcbiAgICBcInJlbmRlcl9saW5lXCIsXHJcbiAgICBcInJlbmRlcl9zeW1ib2xcIixcclxuICAgIFwicmVuZGVyX3Jhc3RlclwiLFxyXG4gICAgXCJyZW5kZXJfYmFja2dyb3VuZFwiXHJcbiAgXSxcclxuICBcInJlbmRlcl9iYWNrZ3JvdW5kXCI6IHtcclxuICB9LFxyXG4gIFwicmVuZGVyX2ZpbGxcIjoge1xyXG4gIH0sXHJcbiAgXCJyZW5kZXJfbGluZVwiOiB7XHJcbiAgICBcImxpbmUtY2FwXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJidXR0XCIsXHJcbiAgICAgICAgXCJyb3VuZFwiLFxyXG4gICAgICAgIFwic3F1YXJlXCJcclxuICAgICAgXSxcclxuICAgICAgXCJkZWZhdWx0XCI6IFwiYnV0dFwiLFxyXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIlxyXG4gICAgfSxcclxuICAgIFwibGluZS1qb2luXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJiZXZlbFwiLFxyXG4gICAgICAgIFwicm91bmRcIixcclxuICAgICAgICBcIm1pdGVyXCJcclxuICAgICAgXSxcclxuICAgICAgXCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcclxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCJcclxuICAgIH0sXHJcbiAgICBcImxpbmUtbWl0ZXItbGltaXRcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIlxyXG4gICAgfSxcclxuICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMSxcclxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuXCJcclxuICAgIH1cclxuICB9LFxyXG4gIFwicmVuZGVyX3N5bWJvbFwiOiB7XHJcbiAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcImVudW1cIixcclxuICAgICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgICAgIFwicG9pbnRcIixcclxuICAgICAgICAgICAgXCJsaW5lXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXHJcbiAgICAgICAgXCJkb2NcIjogXCJQbGFjZW1lbnQgb2YgYSBsYWJlbCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuIGBMaW5lYCBjYW4gb25seSBiZSB1c2VkIG9uIExpbmVTdHJpbmdzIGFuZCBQb2x5Z29ucy5cIlxyXG4gICAgfSxcclxuICAgIFwic3ltYm9sLW1pbi1kaXN0YW5jZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMjUwLFxyXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMgKHB4KVwiXHJcbiAgICB9LFxyXG4gICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcclxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXHJcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzLiBTeW1ib2xzIHRoYXQgY3Jvc3MgdGlsZSBlZGdlcyBtYXkgY2F1c2UgY29sbGlzaW9ucyBpbiBzb21lIGNhc2VzLiBUaGlzIHByb3BlcnR5IHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxyXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgdGV4dC5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxyXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd29uJ3QgYWZmZWN0IHBsYWNlbWVudCBvZiBvdGhlciBpY29ucyBhbmQgdGV4dC5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcclxuICAgICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRleHQgY2FuIGJlIHNob3duIHdpdGhvdXQgaXRzIGNvcnJlc3BvbmRpbmcgaWNvbi5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXHJcbiAgICAgIFwidmFsdWVzXCI6IFtcclxuICAgICAgICBcIm1hcFwiLFxyXG4gICAgICAgIFwidmlld3BvcnRcIlxyXG4gICAgICBdLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxyXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcm90YXRlZFwiXHJcbiAgICB9LFxyXG4gICAgXCJpY29uLW1heC1zaXplXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxyXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFtb3VudCB0byBzY2FsZSB0aGUgaWNvbiBieS5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1pbWFnZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRvY1wiOiBcIkEgc3RyaW5nIHdpdGgge3Rva2Vuc30gcmVwbGFjZWQsIHJlZmVyZW5jaW5nIHRoZSBkYXRhIHByb3BlcnR5IHRvIHB1bGwgZnJvbS5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1yb3RhdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDAsXHJcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVncmVlcy5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1wYWRkaW5nXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxyXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIGljb24gYm91bmRpbmcgYm94IHRvIGF2b2lkIGljb24gY29sbGlzaW9ucyAocHgpLlwiXHJcbiAgICB9LFxyXG4gICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcclxuICAgICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93blwiXHJcbiAgICB9LFxyXG4gICAgXCJpY29uLW9mZnNldFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJsZW5ndGhcIjogMixcclxuICAgICAgXCJkZWZhdWx0XCI6IFtcclxuICAgICAgICAwLFxyXG4gICAgICAgIDBcclxuICAgICAgXSxcclxuICAgICAgXCJkb2NcIjogXCJJY29uJ3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcclxuICAgICAgXCJ2YWx1ZXNcIjogW1xyXG4gICAgICAgIFwibWFwXCIsXHJcbiAgICAgICAgXCJ2aWV3cG9ydFwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiBvciB0ZXh0IHdoZW4gbWFwIGlzIHJvdGF0ZWRcIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC1maWVsZFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJcIixcclxuICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gRmVhdHVyZSBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQgdXNpbmcgdG9rZW5zIGxpa2Uge2ZpZWxkX25hbWV9LlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LWZvbnRcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgXCJkb2NcIjogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LW1heC1zaXplXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcclxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBzaXplIHRleHQgd2lsbCBiZSBkaXNwbGF5ZWQuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAxNSxcclxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nIChlbSkuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDEuMixcclxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMCxcclxuICAgICAgXCJkb2NcIjogXCJUZXh0IGtlcm5pbmcgdmFsdWUgKGVtKS5cIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJjZW50ZXJcIixcclxuICAgICAgICBcImxlZnRcIixcclxuICAgICAgICBcInJpZ2h0XCJcclxuICAgICAgXSxcclxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtaG9yaXpvbnRhbC1hbGlnblwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcclxuICAgICAgXCJ2YWx1ZXNcIjogW1xyXG4gICAgICAgIFwibGVmdFwiLFxyXG4gICAgICAgIFwiY2VudGVyXCIsXHJcbiAgICAgICAgXCJyaWdodFwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxyXG4gICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgYWxpZ25tZW50IG9mIHRoZSB0ZXh0IHJlbGF0aXZlIHRvIHRoZSBhbmNob3IuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtdmVydGljYWwtYWxpZ25cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXHJcbiAgICAgIFwidmFsdWVzXCI6IFtcclxuICAgICAgICBcInRvcFwiLFxyXG4gICAgICAgIFwiY2VudGVyXCIsXHJcbiAgICAgICAgXCJib3R0b21cIlxyXG4gICAgICBdLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcclxuICAgICAgXCJkb2NcIjogXCJWZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgcmVsYXRpdmUgdG8gdGhlIGFuY2hvci5cIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC1tYXgtYW5nbGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxyXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFuZ2xlIGNoYW5nZSwgaW4gZGVncmVlcywgYWxsb3dlZCBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtcm90YXRlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlZ3JlZXMuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtcGFkZGluZ1wiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMixcclxuICAgICAgXCJkb2NcIjogXCJQYWRkaW5nIHZhbHVlIGFyb3VuZCB0ZXh0IGJvdW5kaW5nIGJveCB0byBhdm9pZCBsYWJlbCBjb2xsaXNpb25zIChweCkuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXHJcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93blwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcclxuICAgICAgXCJ2YWx1ZXNcIjogW1xyXG4gICAgICAgIFwibm9uZVwiLFxyXG4gICAgICAgIFwidXBwZXJjYXNlXCIsXHJcbiAgICAgICAgXCJsb3dlcmNhc2VcIlxyXG4gICAgICBdLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LW9mZnNldFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJsZW5ndGhcIjogMixcclxuICAgICAgXCJkZWZhdWx0XCI6IFtcclxuICAgICAgICAwLFxyXG4gICAgICAgIDBcclxuICAgICAgXVxyXG4gICAgfSxcclxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXHJcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgbGFiZWxzLlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcclxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCB3b24ndCBhZmZlY3QgcGxhY2VtZW50IG9mIG90aGVyIGljb25zIGFuZCBsYWJlbHMuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtb3B0aW9uYWxcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcclxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXHJcbiAgICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCBpY29ucyBjYW4gYmUgc2hvd24gd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQuXCJcclxuICAgIH1cclxuICB9LFxyXG4gIFwicmVuZGVyX3Jhc3RlclwiOiB7XHJcbiAgICBcInJhc3Rlci1zaXplXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJkZWZhdWx0XCI6IDI1NixcclxuICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dHVyZSBpbWFnZSBzaXplIChpbiBwaXhlbHMpIHZlY3RvciBsYXllcnMgd2lsbCBiZSByYXN0ZXJpemVkIGF0LiBXaWxsIGF1dG9tYXRpY2FsbHkgYnkgc2NhbGVkIHRvIG1hdGNoIHRoZSB2aXN1YWwgdGlsZSBzaXplLlwiXHJcbiAgICB9LFxyXG4gICAgXCJyYXN0ZXItYmx1clwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImRvY1wiOiBcIkJsdXIgcmFkaXVzIHRvIGFwcGx5IHRvIHRoZSByYXN0ZXIgdGV4dHVyZSBiZWZvcmUgZGlzcGxheS5cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJmaWx0ZXJcIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfZXhwcmVzc2lvblwiLFxyXG4gICAgICBcImRvY1wiOiBcIlZhcmlvdXMgZmlsdGVyIGV4cHJlc3Npb25zLiBVbmxlc3Mgb3ZlcnJpZGRlbiBieSBwYXJlbnQsIHRoZXNlIGFyZSBpbnRlcnByZXRlZCBhcyBgQU5EYC5cIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgXCJ2YWx1ZVwiOiBcImZpbHRlcl9leHByZXNzaW9uXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVmFyaW91cyBmaWx0ZXIgZXhwcmVzc2lvbnMuIFVubGVzcyBvdmVycmlkZGVuIGJ5IHBhcmVudCwgdGhlc2UgYXJlIGludGVycHJldGVkIGFzIGBPUmAuXCJcclxuICAgIH1cclxuICBdLFxyXG4gIFwiZmlsdGVyX2V4cHJlc3Npb25cIjoge1xyXG4gICAgXCImXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiQU5EIG9wZXJhdG9yLlwiXHJcbiAgICB9LFxyXG4gICAgXCJ8XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiT1Igb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIl5cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcclxuICAgICAgXCJkb2NcIjogXCJYT1Igb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIiFcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcclxuICAgICAgXCJkb2NcIjogXCJOT1Igb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIiR0eXBlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJQb2ludFwiLFxyXG4gICAgICAgIFwiTGluZVN0cmluZ1wiLFxyXG4gICAgICAgIFwiUG9seWdvblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZG9jXCI6IFwiR2VvbWV0cnkgdHlwZSB0aGF0IGZlYXR1cmVzIG11c3QgbWF0Y2guXCJcclxuICAgIH0sXHJcbiAgICBcIipcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX2NvbXBhcmlzb25cIixcclxuICAgICAgICBcImRvY1wiOiBcIkFyYml0YXJpbHkgbmFtZWQgZmVhdHVyZSBtZW1iZXIuIEEgY29tcGFyaXNvbiBvYmplY3QgZGVmaW5pbmcgYSBmaWx0ZXIgZXhwcmVzc2lvbi5cIlxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXHJcbiAgICAgICAgXCJkb2NcIjogXCJBcmJpdGFyaWx5IG5hbWVkIGZlYXR1cmUgbWVtYmVyLiBBIGZpbHRlcl92YWx1ZSBpbXBsaWVzIHRoZSBlcXVhbGl0eSAoc3RyaW5nL251bWJlci9ib29sZWFuKSBvciBzZXQgbWVtYmVyc2hpcCBvcGVyYXRvciAoYXJyYXkpLlwiXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIFwiZmlsdGVyX2NvbXBhcmlzb25cIjoge1xyXG4gICAgXCI9PVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxyXG4gICAgICBcImRvY1wiOiBcIkVxdWFsaXR5IG9wZXJhdG9yLlwiXHJcbiAgICB9LFxyXG4gICAgXCIhPVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxyXG4gICAgICBcImRvY1wiOiBcIkluZXF1YWxpdHkgb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIj5cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfdmFsdWVcIixcclxuICAgICAgXCJkb2NcIjogXCJHcmVhdGVyIHRoYW4gb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIj49XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiR3JlYXRlciBvciBlcXVhbCB0aGFuIG9wZXJhdG9yLlwiXHJcbiAgICB9LFxyXG4gICAgXCI8XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiTGVzcyB0aGFuIG9wZXJhdG9yLlwiXHJcbiAgICB9LFxyXG4gICAgXCI8PVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxyXG4gICAgICBcImRvY1wiOiBcIkxlc3MgdGhhbiBvciBlcXVhbCBvcGVyYXRvci5cIlxyXG4gICAgfSxcclxuICAgIFwiaW5cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInZhbHVlXCI6IFwiZmlsdGVyX3ByaW1pdGl2ZVwiLFxyXG4gICAgICBcImRvY1wiOiBcIlNldCBtZW1iZXIgb3BlcmF0b3IuXCJcclxuICAgIH0sXHJcbiAgICBcIiFpblwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiTm90IGluIHNldCBvcGVyYXRvci5cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJmaWx0ZXJfdmFsdWVcIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCJcclxuICAgIH1cclxuICBdLFxyXG4gIFwiZmlsdGVyX3ByaW1pdGl2ZVwiOiBbXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXHJcbiAgICB9XHJcbiAgXSxcclxuICBcImZ1bmN0aW9uXCI6IHtcclxuICAgIFwic3RvcHNcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXHJcbiAgICAgIFwidmFsdWVcIjogXCJmdW5jdGlvbl9zdG9wXCJcclxuICAgIH0sXHJcbiAgICBcImJhc2VcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDEsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcclxuICAgIH1cclxuICB9LFxyXG4gIFwiZnVuY3Rpb25fc3RvcFwiOiB7XHJcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgXCJ2YWx1ZVwiOiBbXCJudW1iZXJcIiwgXCJjb2xvclwiXSxcclxuICAgIFwibGVuZ3RoXCI6IDIsXHJcbiAgICBcImRvY1wiOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcclxuICB9LFxyXG4gIFwiY2xhc3NcIjogW1xyXG4gICAgXCJjbGFzc19maWxsXCIsXHJcbiAgICBcImNsYXNzX2xpbmVcIixcclxuICAgIFwiY2xhc3Nfc3ltYm9sXCIsXHJcbiAgICBcImNsYXNzX3Jhc3RlclwiLFxyXG4gICAgXCJjbGFzc19iYWNrZ3JvdW5kXCJcclxuICBdLFxyXG4gIFwiY2xhc3NfZmlsbFwiOiB7XHJcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIlxyXG4gICAgfSxcclxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJkZWZhdWx0XCI6IDEsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJmaWxsLWNvbG9yXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IFtcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAxXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwibGVuZ3RoXCI6IDIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXHJcbiAgICB9LFxyXG4gICAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXHJcbiAgICAgIFwidmFsdWVzXCI6IFtcclxuICAgICAgICBcIm1hcFwiLFxyXG4gICAgICAgIFwidmlld3BvcnRcIlxyXG4gICAgICBdLFxyXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiXHJcbiAgICB9LFxyXG4gICAgXCJmaWxsLWltYWdlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLlwiXHJcbiAgICB9XHJcbiAgfSxcclxuICBcImNsYXNzX2xpbmVcIjoge1xyXG4gICAgXCJsaW5lLW9wYWNpdHlcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRlZmF1bHRcIjogMSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcImxpbmUtY29sb3JcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogW1xyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDFcclxuICAgICAgXSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwibGluZS10cmFuc2xhdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwibGVuZ3RoXCI6IDIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXHJcbiAgICB9LFxyXG4gICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXHJcbiAgICAgIFwidmFsdWVzXCI6IFtcclxuICAgICAgICBcIm1hcFwiLFxyXG4gICAgICAgIFwidmlld3BvcnRcIlxyXG4gICAgICBdLFxyXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiXHJcbiAgICB9LFxyXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIkxpbmUgd2lkdGggKGluIHB4KVwiXHJcbiAgICB9LFxyXG4gICAgXCJsaW5lLW9mZnNldFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMCxcclxuICAgICAgXCJkb2NcIjogXCJMaW5lIGNhc2luZyB3aGVyZSBgbGluZS1vZmZzZXRgIGluZGljYXRlcyB0b3RhbCB3aWR0aC4gQFRPRE8gcmVuYW1lP1wiLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJsaW5lLWJsdXJcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDAsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiTGluZSBibHVyLCBpbiBwaXhlbHMuXCJcclxuICAgIH0sXHJcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImxlbmd0aFwiOiAyLFxyXG4gICAgICBcImRlZmF1bHRcIjogW1xyXG4gICAgICAgIDEsXHJcbiAgICAgICAgLTFcclxuICAgICAgXSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwibGluZS1pbWFnZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy5cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJjbGFzc19zeW1ib2xcIjoge1xyXG4gICAgXCJpY29uLW9wYWNpdHlcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDEsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcImljb24tc2l6ZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcclxuICAgICAgXCJkb2NcIjogXCJUaGUgYW1vdW50IHRvIHNjYWxlIHRoZSBpY29uIGJ5LiAxIGlzIG9yaWdpbmFsIHNpemUsIDMgdHJpcGxlcyB0aGUgc2l6ZS5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi1jb2xvclwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMVxyXG4gICAgICBdLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbi4gVGhpcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiXHJcbiAgICB9LFxyXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogW1xyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDBcclxuICAgICAgXSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcclxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCJcclxuICAgIH0sXHJcbiAgICBcImljb24taGFsby13aWR0aFwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMCxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcclxuICAgICAgXCJkb2NcIjogXCJIb3cgZmFyIGF3YXkgdGhlIGhhbG8gaXMgZnJvbSB0aGUgaWNvbiBvdXRsaW5lLCBpbiBwaXhlbHMuXCJcclxuICAgIH0sXHJcbiAgICBcImljb24taGFsby1ibHVyXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUsIGluIHBpeGVscy5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwibGVuZ3RoXCI6IDIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiQW4gaWNvbidzIG9mZnNldCwgaW4gcGl4ZWxzLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxyXG4gICAgfSxcclxuICAgIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJtYXBcIixcclxuICAgICAgICBcInZpZXdwb3J0XCJcclxuICAgICAgXSxcclxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LXNpemVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDE2LFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc2l6ZSBpbiBwaXhlbHMuIElmIHVuc3BlY2lmaWVkLCB0aGUgdGV4dCB3aWxsIGJlIGFzIGJpZyBhcyBhbGxvd2VkIGJ5IHRoZSBsYXllciBkZWZpbml0aW9uLlwiXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IFtcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAxXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcInRleHQtaGFsby1jb2xvclwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMFxyXG4gICAgICBdLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDAsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiSG93IGZhciBhd2F5IHRoZSBoYWxvIGlzIGZyb20gdGhlIGZvbnQgb3V0bGluZSwgaW4gcGl4ZWxzLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplIChweCkuXCJcclxuICAgIH0sXHJcbiAgICBcInRleHQtaGFsby1ibHVyXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUsIGluIHBpeGVscy5cIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwibGVuZ3RoXCI6IDIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiBbXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwXHJcbiAgICAgIF0sXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwiZG9jXCI6IFwiQSBsYWJlbCdzIG9mZnNldCwgaW4gcGl4ZWxzLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxyXG4gICAgfSxcclxuICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxyXG4gICAgICBcInZhbHVlc1wiOiBbXHJcbiAgICAgICAgXCJtYXBcIixcclxuICAgICAgICBcInZpZXdwb3J0XCJcclxuICAgICAgXSxcclxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXCJjbGFzc19yYXN0ZXJcIjoge1xyXG4gICAgXCJyYXN0ZXItb3BhY2l0eVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlZ3JlZXMuXCJcclxuICAgIH0sXHJcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImxlbmd0aFwiOiAyLFxyXG4gICAgICBcImRlZmF1bHRcIjogW1xyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMVxyXG4gICAgICBdLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMCxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogMzAwLFxyXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxyXG4gICAgICBcImRvY1wiOiBcIkR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgZmFkZSB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuXCJcclxuICAgIH1cclxuICB9LFxyXG4gIFwiY2xhc3NfYmFja2dyb3VuZFwiOiB7XHJcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxyXG4gICAgICBcImRlZmF1bHRcIjogW1xyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDFcclxuICAgICAgXSxcclxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxyXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICB9LFxyXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJkZWZhdWx0XCI6IDEsXHJcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcclxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcclxuICAgIH1cclxuICB9LFxyXG4gIFwidHJhbnNpdGlvblwiOiB7XHJcbiAgICBcImR1cmF0aW9uXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXHJcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBpdCB0YWtlcyBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcclxuICAgIH0sXHJcbiAgICBcImRlbGF5XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxyXG4gICAgICBcImRvY1wiOiBcIlRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9idWY7XG5mdW5jdGlvbiBQcm90b2J1ZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cblByb3RvYnVmLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5idWYubGVuZ3RoOyB9XG59O1xuXG5Qcm90b2J1Zi5WYXJpbnQgPSAwO1xuUHJvdG9idWYuSW50NjQgPSAxO1xuUHJvdG9idWYuTWVzc2FnZSA9IDI7XG5Qcm90b2J1Zi5TdHJpbmcgPSAyO1xuUHJvdG9idWYuUGFja2VkID0gMjtcblByb3RvYnVmLkludDMyID0gNTtcblxuUHJvdG9idWYucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJ1ZiA9IG51bGw7XG59O1xuXG4vLyA9PT0gUkVBRElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZFVJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkVUludDY0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50NjRMRSh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWREb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsID0gaWVlZTc1NC5yZWFkKHRoaXMuYnVmLCB0aGlzLnBvcywgdHJ1ZSwgNTIsIDgpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkVmFyaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLmJ1Zltwb3NdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmW3Bvc107XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyAxXSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgIHJldHVybiAodGhpcy5idWZbcG9zXSAmIDB4N2YpIHwgKHRoaXMuYnVmW3BvcyArIDFdIDw8IDcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZbcG9zICsgMl0gPD0gMHg3Zikge1xuICAgICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0pIDw8IDE0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZbcG9zICsgM10gPD0gMHg3Zikge1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0gJiAweDdmKSA8PCAxNCB8ICh0aGlzLmJ1Zltwb3MgKyAzXSkgPDwgMjE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyA0XSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDU7XG4gICAgICAgIHJldHVybiAoKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0gJiAweDdmKSA8PCAxNCB8ICh0aGlzLmJ1Zltwb3MgKyAzXSkgPDwgMjEpICsgKHRoaXMuYnVmW3BvcyArIDRdICogMjY4NDM1NDU2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNraXAoUHJvdG9idWYuVmFyaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcIlRPRE86IEhhbmRsZSA2KyBieXRlIHZhcmludHNcIik7XG4gICAgfVxufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRTVmFyaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIGlmIChudW0gPiAyMTQ3NDgzNjQ3KSB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IEhhbmRsZSBudW1iZXJzID49IDJeMzAnKTtcbiAgICAvLyB6aWd6YWcgZW5jb2RpbmdcbiAgICByZXR1cm4gKChudW0gPj4gMSkgXiAtKG51bSAmIDEpKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICB2YXIgcCA9IHRoaXMucG9zO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcyArIGJ5dGVzO1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB3aGlsZSAocCA8IGVuZCkge1xuICAgICAgICBpZiAoYltwXSA8PSAweDdGKSBzdHIgKz0gY2hyKGJbcCsrXSk7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhCRikgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IGNvZGVwb2ludDogJyArIGJbcF0pO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4REYpIHN0ciArPSBjaHIoKGJbcCsrXSAmIDB4MUYpIDw8IDYgfCAoYltwKytdICYgMHgzRikpO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RUYpIHN0ciArPSBjaHIoKGJbcCsrXSAmIDB4MUYpIDw8IDEyIHwgKGJbcCsrXSAmIDB4M0YpIDw8IDYgfCAoYltwKytdICYgMHgzRikpO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RjcpIHAgKz0gNDsgLy8gV2UgY2FuJ3QgaGFuZGxlIHRoZXNlIGNvZGVwb2ludHMgaW4gSlMsIHNvIHNraXAuXG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhGQikgcCArPSA1O1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RkQpIHAgKz0gNjtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggY29kZXBvaW50OiAnICsgYltwXSk7XG4gICAgfVxuICAgIHRoaXMucG9zICs9IGJ5dGVzO1xuICAgIHJldHVybiBzdHI7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1Zi5zdWJhcnJheSh0aGlzLnBvcywgdGhpcy5wb3MgKyBieXRlcyk7XG4gICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkUGFja2VkID0gZnVuY3Rpb24odHlwZSkge1xuICAgIC8vIFRPRE86IGJvdW5kcyBjaGVja2luZ1xuICAgIHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcyArIGJ5dGVzO1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXNbJ3JlYWQnICsgdHlwZV0oKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8qIHZhcmludCAqLyBjYXNlIFByb3RvYnVmLlZhcmludDogd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdID4gMHg3Zik7IGJyZWFrO1xuICAgICAgICAvKiA2NCBiaXQgKi8gY2FzZSBQcm90b2J1Zi5JbnQ2NDogdGhpcy5wb3MgKz0gODsgYnJlYWs7XG4gICAgICAgIC8qIGxlbmd0aCAqLyBjYXNlIFByb3RvYnVmLk1lc3NhZ2U6IHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpOyB0aGlzLnBvcyArPSBieXRlczsgYnJlYWs7XG4gICAgICAgIC8qIDMyIGJpdCAqLyBjYXNlIFByb3RvYnVmLkludDMyOiB0aGlzLnBvcyArPSA0OyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59O1xuXG4vLyA9PT0gV1JJVElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWcgPSBmdW5jdGlvbih0YWcsIHR5cGUpIHtcbiAgICB0aGlzLndyaXRlVmFyaW50KCh0YWcgPDwgMykgfCB0eXBlKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFsbG9jID0gZnVuY3Rpb24obWluKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoIDwgdGhpcy5wb3MgKyBtaW4pIGxlbmd0aCAqPSAyO1xuICAgIGlmIChsZW5ndGggIT0gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgfVxufTtcblxuUHJvdG9idWYucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLnBvcyk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVQYWNrZWQgPSBmdW5jdGlvbih0eXBlLCB0YWcsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciBtZXNzYWdlID0gbmV3IFByb3RvYnVmKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZXNzYWdlWyd3cml0ZScgKyB0eXBlXShpdGVtc1tpXSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gbWVzc2FnZS5maW5pc2goKTtcblxuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5QYWNrZWQpO1xuICAgIHRoaXMud3JpdGVCdWZmZXIoZGF0YSk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVVSW50MzIgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkVUludDMyID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuSW50MzIpO1xuICAgIHRoaXMud3JpdGVVSW50MzIodmFsKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVZhcmludCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwgPD0gMHgzZmZmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYygyKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDApICYgMHg3Zik7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHgwMCB8ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmZikge1xuICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiAwKSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gNykgJiAweDdmKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDAwIHwgKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4ZmZmZmZmZikge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiAwKSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gNykgJiAweDdmKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4MDAgfCAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbCA+IDApIHtcbiAgICAgICAgICAgIHZhciBiID0gdmFsICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gMTI4KTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSBiIHw9IDB4ODBcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gYjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZFZhcmludCA9IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLlZhcmludCk7XG4gICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlU1ZhcmludCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh2YWwgPj0gMCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCAqIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsICogLTIgLSAxKTtcbiAgICB9XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWdnZWRTVmFyaW50ID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuVmFyaW50KTtcbiAgICB0aGlzLndyaXRlU1ZhcmludCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEJvb2xlYW4gPSBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgIHRoaXMud3JpdGVUYWdnZWRWYXJpbnQodGFnLCBCb29sZWFuKHZhbCkpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICB0aGlzLndyaXRlVmFyaW50KGJ5dGVzKTtcbiAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IGJ5dGVzO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkU3RyaW5nID0gZnVuY3Rpb24odGFnLCBzdHIpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuU3RyaW5nKTtcbiAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVGbG9hdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICB0aGlzLmJ1Zi53cml0ZUZsb2F0TEUodmFsLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEZsb2F0ID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuSW50MzIpO1xuICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlRG91YmxlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZERvdWJsZSA9IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLkludDY0KTtcbiAgICB0aGlzLndyaXRlRG91YmxlKHZhbCk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSBieXRlcztcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEJ1ZmZlciA9IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLlN0cmluZyk7XG4gICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlTWVzc2FnZSA9IGZ1bmN0aW9uKHRhZywgcHJvdG9idWYpIHtcbiAgICB2YXIgYnVmZmVyID0gcHJvdG9idWYuZmluaXNoKCk7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLk1lc3NhZ2UpO1xuICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBxdWV1ZShwYXJhbGxlbGlzbSkge1xuICAgIHZhciBxLFxuICAgICAgICB0YXNrcyA9IFtdLFxuICAgICAgICBzdGFydGVkID0gMCwgLy8gbnVtYmVyIG9mIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHN0YXJ0ZWQgKGFuZCBwZXJoYXBzIGZpbmlzaGVkKVxuICAgICAgICBhY3RpdmUgPSAwLCAvLyBudW1iZXIgb2YgdGFza3MgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIChzdGFydGVkIGJ1dCBub3QgZmluaXNoZWQpXG4gICAgICAgIHJlbWFpbmluZyA9IDAsIC8vIG51bWJlciBvZiB0YXNrcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICAgIHBvcHBpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yID0gbnVsbCxcbiAgICAgICAgYXdhaXQgPSBub29wLFxuICAgICAgICBhbGw7XG5cbiAgICBpZiAoIXBhcmFsbGVsaXNtKSBwYXJhbGxlbGlzbSA9IEluZmluaXR5O1xuXG4gICAgZnVuY3Rpb24gcG9wKCkge1xuICAgICAgd2hpbGUgKHBvcHBpbmcgPSBzdGFydGVkIDwgdGFza3MubGVuZ3RoICYmIGFjdGl2ZSA8IHBhcmFsbGVsaXNtKSB7XG4gICAgICAgIHZhciBpID0gc3RhcnRlZCsrLFxuICAgICAgICAgICAgdCA9IHRhc2tzW2ldLFxuICAgICAgICAgICAgYSA9IHNsaWNlLmNhbGwodCwgMSk7XG4gICAgICAgIGEucHVzaChjYWxsYmFjayhpKSk7XG4gICAgICAgICsrYWN0aXZlO1xuICAgICAgICB0WzBdLmFwcGx5KG51bGwsIGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlLCByKSB7XG4gICAgICAgIC0tYWN0aXZlO1xuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IgPSBlOyAvLyBpZ25vcmUgbmV3IHRhc2tzIGFuZCBzcXVlbGNoIGFjdGl2ZSBjYWxsYmFja3NcbiAgICAgICAgICBzdGFydGVkID0gcmVtYWluaW5nID0gTmFOOyAvLyBzdG9wIHF1ZXVlZCB0YXNrcyBmcm9tIHN0YXJ0aW5nXG4gICAgICAgICAgbm90aWZ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFza3NbaV0gPSByO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZykgcG9wcGluZyB8fCBwb3AoKTtcbiAgICAgICAgICBlbHNlIG5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSBhd2FpdChlcnJvcik7XG4gICAgICBlbHNlIGlmIChhbGwpIGF3YWl0KGVycm9yLCB0YXNrcyk7XG4gICAgICBlbHNlIGF3YWl0LmFwcGx5KG51bGwsIFtlcnJvcl0uY29uY2F0KHRhc2tzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHEgPSB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICB0YXNrcy5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgICAgKytyZW1haW5pbmc7XG4gICAgICAgICAgcG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgYXdhaXQgPSBmO1xuICAgICAgICBhbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBhd2FpdCA9IGY7XG4gICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIHF1ZXVlLnZlcnNpb24gPSBcIjEuMC43XCI7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gcXVldWU7IH0pO1xuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IHF1ZXVlO1xuICBlbHNlIHRoaXMucXVldWUgPSBxdWV1ZTtcbn0pKCk7XG4iLCIvKlxuIChjKSAyMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cbiBSQnVzaCwgYSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGhpZ2gtcGVyZm9ybWFuY2UgMkQgc3BhdGlhbCBpbmRleGluZyBvZiBwb2ludHMgYW5kIHJlY3RhbmdsZXMuXG4gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KSB7XG5cbiAgICAvLyBqc2hpbnQgbmV3Y2FwOiBmYWxzZSwgdmFsaWR0aGlzOiB0cnVlXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpO1xuXG4gICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyB8fCA5KTtcbiAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxucmJ1c2gucHJvdG90eXBlID0ge1xuXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfSxcblxuICAgIHNlYXJjaDogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94O1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICBiYm94OiBlbXB0eSgpLFxuICAgICAgICAgICAgbGVhZjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgcGF0aCA9IFtdLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgaSwgcGFyZW50LCBpbmRleCwgZ29pbmdVcDtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7IC8vIGNoZWNrIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gbm9kZS5jaGlsZHJlbi5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZS5iYm94LCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0sXG4gICAgY29tcGFyZU1pblk6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIGJib3g6IG51bGwsXG4gICAgICAgICAgICAgICAgbGVhZjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBlbGltaW5hdGUgcmVjdXJzaW9uP1xuXG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGJib3g6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQuYmJveCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQuYmJveCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtLmJib3ggOiB0b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZS5iYm94LCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5zcGxpY2UodGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKSksXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5vZGUubGVhZikgbmV3Tm9kZS5sZWFmID0gdHJ1ZTtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbbm9kZSwgbmV3Tm9kZV0sXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ICsgMVxuICAgICAgICB9O1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLmJib3gsIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIC8vIGpzaGludCBldmlsOiB0cnVlXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJywgJ3JldHVybiBbYScgKyBmb3JtYXQuam9pbignLCBhJykgKyAnXTsnKTtcbiAgICB9XG59O1xuXG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIG5vZGUuYmJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94KSB7XG4gICAgdmFyIGJib3ggPSBlbXB0eSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGJib3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmJveDtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7IHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07IH1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhWzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgYVsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIGFbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBhWzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLmJib3hbMF0gLSBiLmJib3hbMF07IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLmJib3hbMV0gLSBiLmJib3hbMV07IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYVsyXSAtIGFbMF0pICogKGFbM10gLSBhWzFdKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYVsyXSAtIGFbMF0pICsgKGFbM10gLSBhWzFdKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYlsyXSwgYVsyXSkgLSBNYXRoLm1pbihiWzBdLCBhWzBdKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYlszXSwgYVszXSkgLSBNYXRoLm1pbihiWzFdLCBhWzFdKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEgKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGFbMF0sIGJbMF0pLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYVsxXSwgYlsxXSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhWzJdLCBiWzJdKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhWzBdIDw9IGJbMF0gJiZcbiAgICAgICAgICAgYVsxXSA8PSBiWzFdICYmXG4gICAgICAgICAgIGJbMl0gPD0gYVsyXSAmJlxuICAgICAgICAgICBiWzNdIDw9IGFbM107XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMgKGEsIGIpIHtcbiAgICByZXR1cm4gYlswXSA8PSBhWzJdICYmXG4gICAgICAgICAgIGJbMV0gPD0gYVszXSAmJlxuICAgICAgICAgICBiWzJdID49IGFbMF0gJiZcbiAgICAgICAgICAgYlszXSA+PSBhWzFdO1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG1pZCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cblxuLy8gc29ydCBhcnJheSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IChpbmNsdXNpdmUpIHNvIHRoYXQgdGhlIHNtYWxsZXN0IGsgZWxlbWVudHMgY29tZSBmaXJzdCAodW5vcmRlcmVkKVxuZnVuY3Rpb24gc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIGssIGNvbXBhcmUpIHtcbiAgICB2YXIgbiwgaSwgeiwgcywgc2QsIG5ld0xlZnQsIG5ld1JpZ2h0LCB0LCBqO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGkgPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKGkgLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIGkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIGkpICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgc2VsZWN0KGFyciwgbmV3TGVmdCwgbmV3UmlnaHQsIGssIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IGFycltrXTtcbiAgICAgICAgaSA9IGxlZnQ7XG4gICAgICAgIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuXG4vLyBleHBvcnQgYXMgQU1EL0NvbW1vbkpTIG1vZHVsZSBvciBnbG9iYWwgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHJidXNoOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnJidXNoID0gcmJ1c2g7XG5lbHNlIHdpbmRvdy5yYnVzaCA9IHJidXNoO1xuXG59KSgpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdEJlemllcjtcblxuZnVuY3Rpb24gVW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuICAgIHRoaXMuY3ggPSAzLjAgKiBwMXg7XG4gICAgdGhpcy5ieCA9IDMuMCAqIChwMnggLSBwMXgpIC0gdGhpcy5jeDtcbiAgICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG5cbiAgICB0aGlzLmN5ID0gMy4wICogcDF5O1xuICAgIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7XG4gICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5O1xuXG4gICAgdGhpcy5wMXggPSBwMXg7XG4gICAgdGhpcy5wMXkgPSBwMnk7XG4gICAgdGhpcy5wMnggPSBwMng7XG4gICAgdGhpcy5wMnkgPSBwMnk7XG59XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAvLyBgYXggdF4zICsgYnggdF4yICsgY3ggdCcgZXhwYW5kZWQgdXNpbmcgSG9ybmVyJ3MgcnVsZS5cbiAgICByZXR1cm4gKCh0aGlzLmF4ICogdCArIHRoaXMuYngpICogdCArIHRoaXMuY3gpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICBpZiAodHlwZW9mIGVwc2lsb24gPT09ICd1bmRlZmluZWQnKSBlcHNpbG9uID0gMWUtNjtcblxuICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSBicmVhaztcblxuICAgICAgICB0MiA9IHQyIC0geDIgLyBkMjtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGJpc2VjdGlvbiBtZXRob2QgZm9yIHJlbGlhYmlsaXR5LlxuICAgIHQwID0gMC4wO1xuICAgIHQxID0gMS4wO1xuICAgIHQyID0geDtcblxuICAgIGlmICh0MiA8IHQwKSByZXR1cm4gdDA7XG4gICAgaWYgKHQyID4gdDEpIHJldHVybiB0MTtcblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgICAgIHQwID0gdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDtcbiAgICB9XG5cbiAgICAvLyBGYWlsdXJlLlxuICAgIHJldHVybiB0Mjtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWxheWVyLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVsYXllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUoYnVmZmVyLCBlbmQpIHtcblxuICAgIHRoaXMubGF5ZXJzID0ge307XG4gICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzO1xuXG4gICAgICAgIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5yZWFkTGF5ZXIoKTtcbiAgICAgICAgICAgIGlmIChsYXllci5sZW5ndGgpIHRoaXMubGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlLnByb3RvdHlwZS5yZWFkTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyLFxuICAgICAgICBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcyxcbiAgICAgICAgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKGJ1ZmZlciwgZW5kKTtcblxuICAgIGJ1ZmZlci5wb3MgPSBlbmQ7XG5cbiAgICByZXR1cm4gbGF5ZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShidWZmZXIsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcblxuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuXG4gICAgLy8gUHVibGljXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSAtMTtcblxuICAgIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSAyKSB7XG4gICAgICAgICAgICB2YXIgdGFnRW5kID0gYnVmZmVyLnBvcyArIGJ1ZmZlci5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIucG9zIDwgdGFnRW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbYnVmZmVyLnJlYWRWYXJpbnQoKV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2J1ZmZlci5yZWFkVmFyaW50KCldO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA0KSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyA9IFsnVW5rbm93bicsICdQb2ludCcsICdMaW5lU3RyaW5nJywgJ1BvbHlnb24nXTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgYnVmZmVyLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgZW5kID0gYnVmZmVyLnBvcyArIGJ5dGVzLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIGxpbmVzID0gW10sXG4gICAgICAgIGxpbmU7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZF9sZW5ndGggPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kX2xlbmd0aCAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZF9sZW5ndGggPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcblxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmVUb1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSA3KSB7XG4gICAgICAgICAgICAvLyBjbG9zZVBvbHlnb25cbiAgICAgICAgICAgIGxpbmUucHVzaChsaW5lWzBdLmNsb25lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcblxuICAgIHJldHVybiBsaW5lcztcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICBidWZmZXIucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgYnl0ZXMgPSBidWZmZXIucmVhZFZhcmludCgpLFxuICAgICAgICBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXMsXG5cbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZF9sZW5ndGggPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kX2xlbmd0aCAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZF9sZW5ndGggPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIoYnVmZmVyLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICB2YXIgdmFsLCB0YWc7XG5cbiAgICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aDtcblxuICAgIHdoaWxlIChidWZmZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xuXG4gICAgICAgIGlmICh0YWcgPT09IDE1KSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDUpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKGJ1ZmZlci5wb3MpO1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGJ1ZmZlci5yZWFkU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godGhpcy5yZWFkRmVhdHVyZVZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5yZWFkRmVhdHVyZVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcyxcbiAgICAgICAgdmFsLCB0YWc7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFkIGZsb2F0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnJlYWREb3VibGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNCkge1xuICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWQgdWludCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA2KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA3KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJvb2xlYW4oYnVmZmVyLnJlYWRWYXJpbnQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9idWZmZXIucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG4gICAgdmFyIGVuZCA9IHRoaXMuX2J1ZmZlci5yZWFkVmFyaW50KCkgKyB0aGlzLl9idWZmZXIucG9zO1xuXG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9idWZmZXIsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIl19
